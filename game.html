<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Simple RTS Demo with Combat</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <style>
    /* Basic styling for the body and canvas */
    body { margin: 0; background-color: #333; display: flex; justify-content: center; align-items: center; min-height: 100vh; position: relative; } /* Added position relative */
    canvas { display: block; margin: 20px auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
    /* Style for the start overlay */
    #start-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        font-size: 24px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        z-index: 10000; /* Ensure it's on top */
        font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
<div id="start-overlay">Click or Tap to Start</div>

<script>
  // Global Constants
  const BARRACK_WOOD_COST = 50;
  const SPEARMAN_WOOD_COST = 5; // Cost to train a spearman
  const SPEARMAN_TRAIN_TIME = 10000; // 10 seconds training time
  const SPEARMAN_LIMIT = 3; // Max number of spearmen per side
  const SPEARMAN_HEALTH = 15; // Health for spearmen
  const SPEARMAN_DPS = 1; // Damage per second
  const SPEARMAN_ATTACK_DELAY = 1000; // Milliseconds between attacks (1 attack per second)
  const SPEARMAN_ATTACK_RANGE = 45; // Range within which spearman can attack
  const WORKER_HEALTH = 10;
  const HOUSE_HEALTH = 50;
  const BARRACK_HEALTH = 50;
  const PLAYER_HEALTH_BAR_COLOR = 0x00ff00; // Green for player units/buildings
  const AI_HEALTH_BAR_COLOR = 0xff0000; // Red for AI units/buildings
  const BUILDING_HEALTH_BAR_WIDTH = 32; // Width for building health bars
  const UNIT_HEALTH_BAR_WIDTH = 28; // Width for unit health bars
  const SPEARMAN_HEALTH_BAR_WIDTH = 40; // Width for spearman health bar
  const UNIT_COLLISION_RADIUS = 20; // Radius for checking unit overlap
  const HEALTH_BAR_HEIGHT = 8; // Main health bar height
  const TRAINING_TEXT_STYLE = { font: '14px Arial', fill: '#000000', backgroundColor: '#ffffff', padding: { x: 5, y: 2 }, borderRadius: 4 }; // Style for training text bubble


  /**
   * Represents the main scene for the RTS demo.
   * Handles game logic, asset loading, and rendering.
   */
  class DemoScene extends Phaser.Scene {
    constructor() {
      super({ key: 'DemoScene' });
      // Game state variables
      this.wood = 0; // Player's wood count
      this.aiWood = 0; // AI's wood count
      this.worker = null; // The player-controlled worker sprite
      this.house = null; // The player house sprite
      this.aiHouse = null; // AI house sprite
      this.aiWorker = null; // AI worker sprite
      this.trees = null; // Group containing tree sprites
      this.playerBarrack = null; // Reference to the player's barrack building
      this.playerBarrackBuilding = false; // Flag: Is the player barrack currently under construction?
      this.aiBarrack = null; // Reference to the AI's barrack building
      this.aiBarrackBuilding = false; // Flag: Is the AI barrack currently under construction?
      this.playerSpearmen = []; // Array for player spearmen
      this.aiSpearmen = []; // Array for AI spearmen
      this.woodText = null; // Text object to display player wood count
      this.aiWoodText = null; // Text object to display AI wood count
      this.debugText = null; // Text object for displaying debug messages
      this.workerWalkSound = null; // Sound effect for worker walking
      this.chopSound = null; // Sound effect for chopping / building
      this.spearmanAttackSound = null; // Sound effect for spearman attacking
      this.unitDieSound = null; // Sound effect for unit death
      this.gameStarted = false; // Flag to prevent logic running before start
      this.gameOver = false; // Flag to prevent multiple end game calls
      this.selectedWorker = null; // Keep track of the selected worker
      this.objectClickedRecently = false; // Flag to prevent immediate background click after object click
      this.debugHistory = []; // Array to store debug message history
      this.maxDebugHistory = 10; // Max number of debug messages to keep
    }

    /**
     * Logs a message to the on-screen debug area, maintaining a history.
     * @param {string} message The message to log.
     */
    logDebug(message) {
        if (!message) return; // Ignore empty messages

        // Add the new message to the history
        // Add timestamp for clarity
        const time = new Date();
        const timestamp = `${time.getHours()}:${String(time.getMinutes()).padStart(2, '0')}:${String(time.getSeconds()).padStart(2, '0')}`;
        this.debugHistory.push(`[${timestamp}] ${message}`);


        // If history exceeds the max size, remove the oldest message (FIFO)
        if (this.debugHistory.length > this.maxDebugHistory) {
            this.debugHistory.shift();
        }

        // Update the on-screen debug text if it exists
        if (this.debugText && this.debugText.visible) { // Only update if visible
            this.debugText.setText('Debug Output:\n' + this.debugHistory.join('\n'));
        }
         // Also log to console for easier debugging
        console.log("DEBUG:", message);
    }


    /**
     * Preloads game assets (images, spritesheets, audio).
     * This function runs before the 'create' function.
     */
    preload() {
      // Load the worker spritesheet
      this.load.spritesheet('worker_sheet', 'https://grantchen08.github.io/nezha/worker_walk.png', {
          frameWidth: 32,
          frameHeight: 64
      });
      // Load the worker chopping spritesheet
      this.load.spritesheet('worker_chop_sheet', 'https://grantchen08.github.io/nezha/worker_chop.png', {
          frameWidth: 64,
          frameHeight: 64
      });
       // Load the barrack image
      this.load.image('barrack', 'https://grantchen08.github.io/nezha/barrack.png');
      // Load the spearman walking spritesheet
      this.load.spritesheet('spearman_walk_sheet', 'https://grantchen08.github.io/nezha/spearman_walk.png', {
          frameWidth: 64,
          frameHeight: 64
      });
      // Load the spearman attacking spritesheet
      this.load.spritesheet('spearman_attack_sheet', 'https://grantchen08.github.io/nezha/spearman_attack.png', {
          frameWidth: 64,
          frameHeight: 64
      });
      // Load the walking sound effect
      this.load.audio('worker_walk', 'https://grantchen08.github.io/nezha/worker_walk.mp3');
      // Load the tree spritesheet
      this.load.spritesheet('tree_sheet', 'https://grantchen08.github.io/nezha/tree.png', {
          frameWidth: 64,
          frameHeight: 64
      });
      // Load the house image
      this.load.image('house', 'https://grantchen08.github.io/nezha/house.png');
      // Load the chopping/building sound effect
      this.load.audio('chop_sound', 'https://grantchen08.github.io/nezha/chop_tree.mp3');
      // Load the spearman attack sound effect
      this.load.audio('spearman_attack_sound', 'https://grantchen08.github.io/nezha/attack.mp3');
      // Load the unit death sound effect
      this.load.audio('unit_die_sound', 'https://grantchen08.github.io/nezha/hurt.mp3');

      // Basic error handling for asset loading
      this.load.on('loaderror', (file) => {
          const errorMsg = `Error loading ${file.key}`;
          console.error(`Error loading asset: ${file.key} from ${file.url}`);
          this.logDebug(errorMsg); // Use new log function
      });
    }

    /**
     * Creates game objects and initializes the scene.
     * This function runs once after 'preload' is complete.
     */
    create() {
      const gameWidth = this.sys.game.config.width;
      const gameHeight = this.sys.game.config.height;

      // Set background color
      this.cameras.main.setBackgroundColor('#228B22'); // Forest green

      // Initialize wood counts and display text
      this.wood = 0; // Start with 0 wood
      this.aiWood = 0;
      this.woodText = this.add.text(10, 10, 'Wood: 0', { font: '16px Arial', fill: '#ffffff' });
      this.woodText.setDepth(1000);
      this.aiWoodText = this.add.text(gameWidth - 10, 10, 'AI Wood: 0', { font: '16px Arial', fill: '#ffffff' })
          .setOrigin(1, 0) // Align to top-right
          .setDepth(1000);


      // Initialize debug text display area
      this.debugText = this.add.text(10, 40, 'Debug Output:', {
        font: '14px Arial',
        fill: '#ffffff',
        wordWrap: { width: 200 },
        lineSpacing: 4 // Add some spacing between lines
      });
      this.debugText.setDepth(1000);
      this.debugText.visible = false; // Start hidden
      this.logDebug("Click overlay to start."); // Log initial message even if hidden

      // --- Add takeDamage method to prototypes ---
      // Generic damage handling for units/buildings
      const takeDamage = function(amount, attacker) {
            if (!this.active || this.health <= 0) return; // Already dead or inactive

            this.health -= amount;
            this.scene.updateHealthBar(this); // Update visual

            if (this.health <= 0) {
                this.health = 0;
                this.scene.logDebug(`${this.getData('unitType') || 'Object'} destroyed!`);

                // Play death sound
                if (this.scene.unitDieSound) {
                    this.scene.unitDieSound.play();
                }

                // Stop attacker if this was their target
                if (attacker && attacker.attackTarget === this) {
                    this.scene.stopAttacking(attacker);
                    attacker.state = 'idle'; // Look for new target
                }
                // Additional destruction logic (remove from arrays, destroy sprite) handled in update loop cleanup
                this.active = false; // Mark as inactive for cleanup
                this.setVisible(false); // Hide immediately
                this.scene.destroyHealthBar(this); // Destroy health bar
                this.disableInteractive(); // Make non-interactive

                // Specific cleanup for barracks
                if (this.getData('unitType') === 'barrack') {
                    if (this.trainingTimer) this.trainingTimer.remove();
                    this.scene.destroyTrainingText(this);
                    this.isTraining = false;
                }
                 // Specific cleanup for workers
                 if (this.getData('unitType') === 'worker') {
                     if (this.isCutting) this.scene.stopCutting(this);
                     if (this.isBuilding) this.scene.stopBuilding(this);
                     if (this.moving) this.scene.tweens.killTweensOf(this);
                 }
                 // Specific cleanup for spearmen
                 if (this.getData('unitType') === 'spearman') {
                     if (this.isAttacking) this.scene.stopAttacking(this);
                     if (this.moving) this.scene.tweens.killTweensOf(this);
                 }

                this.scene.checkEndCondition(); // Check if house destruction ended game
            }
      };
      Phaser.GameObjects.Sprite.prototype.takeDamage = takeDamage;
      Phaser.GameObjects.Image.prototype.takeDamage = takeDamage; // Apply to Images too (house, barrack placeholder)


      // --- Player House Setup ---
      this.house = this.add.image(100, gameHeight - 100, 'house'); // Bottom-left
      this.house.setOrigin(0.5, 1);
      this.house.health = HOUSE_HEALTH;
      this.house.maxHealth = HOUSE_HEALTH;
      this.house.setData('unitType', 'house'); // Set type for health bar
      this.house.setData('isPlayer', true); // Identify side
      this.createHealthBar(this.house, BUILDING_HEALTH_BAR_WIDTH, PLAYER_HEALTH_BAR_COLOR); // Use constants

      // --- Player Worker Setup ---
      this.worker = this.add.sprite(150, gameHeight - 150, 'worker_sheet').setOrigin(0.5, 1); // Near player house
      this.worker.setFrame(0);
      this.worker.state = 'idle'; // Start idle until game starts
      this.worker.moving = false;
      this.worker.target = null; // Target object (tree or build site marker)
      this.worker.isCutting = false;
      this.worker.cuttingTarget = null; // Specific tree being cut
      this.worker.cuttingTimer = null; // Timer stored on worker
      this.worker.isBuilding = false; // Is the worker currently building?
      this.worker.buildingTarget = null; // Specific building being built
      this.worker.buildingTimer = null; // Timer for building progress
      this.worker.health = WORKER_HEALTH;
      this.worker.maxHealth = WORKER_HEALTH;
      this.worker.setData('unitType', 'worker'); // Set type for health bar
      this.worker.setData('isPlayer', true); // Identify side
      this.worker.initialChopHealth = null; // Store tree health when starting chop
      this.createHealthBar(this.worker, UNIT_HEALTH_BAR_WIDTH, PLAYER_HEALTH_BAR_COLOR); // Use constants
      this.worker.setInteractive(); // Make the worker clickable

      // --- AI House Setup ---
      this.aiHouse = this.add.image(gameWidth - 100, gameHeight - 100, 'house'); // Bottom-right
      this.aiHouse.setOrigin(0.5, 1);
      this.aiHouse.health = HOUSE_HEALTH;
      this.aiHouse.maxHealth = HOUSE_HEALTH;
      this.aiHouse.setData('unitType', 'house'); // Set type for health bar
      this.aiHouse.setData('isPlayer', false); // Identify side
      this.createHealthBar(this.aiHouse, BUILDING_HEALTH_BAR_WIDTH, AI_HEALTH_BAR_COLOR); // Use constants

      // --- AI Worker Setup ---
      this.aiWorker = this.add.sprite(gameWidth - 150, gameHeight - 150, 'worker_sheet').setOrigin(0.5, 1); // Near AI house
      this.aiWorker.setFrame(0);
      this.aiWorker.state = 'idle'; // Start idle until game starts
      this.aiWorker.moving = false;
      this.aiWorker.target = null;
      this.aiWorker.isCutting = false;
      this.aiWorker.cuttingTarget = null;
      this.aiWorker.cuttingTimer = null; // Timer stored on worker
      this.aiWorker.isBuilding = false; // AI building flag
      this.aiWorker.buildingTarget = null; // AI building target
      this.aiWorker.buildingTimer = null; // AI building timer
      this.aiWorker.health = WORKER_HEALTH;
      this.aiWorker.maxHealth = WORKER_HEALTH;
      this.aiWorker.setData('unitType', 'worker'); // Set type for health bar
      this.aiWorker.setData('isPlayer', false); // Identify side
      this.aiWorker.initialChopHealth = null; // Store tree health when starting chop
      this.createHealthBar(this.aiWorker, UNIT_HEALTH_BAR_WIDTH, AI_HEALTH_BAR_COLOR); // Use constants
      // AI worker is not interactive for the player


      // Load sounds
      this.workerWalkSound = this.sound.add('worker_walk');
      this.chopSound = this.sound.add('chop_sound'); // For chopping and building
      this.spearmanAttackSound = this.sound.add('spearman_attack_sound'); // For attacking
      this.unitDieSound = this.sound.add('unit_die_sound'); // For unit death

      // Create animations (shared)
      this.anims.create({
          key: 'worker_walk',
          frames: this.anims.generateFrameNumbers('worker_sheet', { start: 0, end: 1 }),
          frameRate: 8,
          repeat: -1
      });
      this.anims.create({
          key: 'worker_chop',
          frames: this.anims.generateFrameNumbers('worker_chop_sheet', { start: 0, end: 1 }),
          frameRate: 4, // Slower chop animation
          repeat: -1
      });
       this.anims.create({
          key: 'spearman_walk',
          frames: this.anims.generateFrameNumbers('spearman_walk_sheet', { start: 0, end: 1 }), // 2x1 grid
          frameRate: 6, // Adjust frame rate as needed
          repeat: -1
      });
       this.anims.create({
          key: 'spearman_attack',
          frames: this.anims.generateFrameNumbers('spearman_attack_sheet', { start: 0, end: 1 }), // 2x1 grid
          frameRate: 4, // Frame rate for attack animation
          repeat: -1
      });

      // --- Tree Setup ---
      this.trees = this.add.group();
      const treeCount = 20;
      for (let i = 0; i < treeCount; i++) {
        // Avoid spawning too close to *either* house base area
        let x, y;
        let tooClose;
        do {
            x = Phaser.Math.Between(50, gameWidth - 50);
            y = Phaser.Math.Between(50, gameHeight - 100); // Keep trees away from bottom edge a bit more

            const playerHouseDist = Phaser.Math.Distance.Between(x, y, this.house.x, this.house.y - this.house.height / 2);
            const aiHouseDist = Phaser.Math.Distance.Between(x, y, this.aiHouse.x, this.aiHouse.y - this.aiHouse.height / 2);
            const houseRadius = Math.max(this.house.width, this.house.height) / 2 + 36; // Use displayWidth/Height?

            tooClose = (playerHouseDist < houseRadius * 1.5) || (aiHouseDist < houseRadius * 1.5); // Increase buffer slightly

        } while (tooClose);


        let tree = this.add.sprite(x, y, 'tree_sheet').setOrigin(0.5, 1);
        tree.setFrame(0);
        tree.health = 10; // Initial health
        tree.maxHealth = 10; // Max health
        this.trees.add(tree);
        tree.setInteractive(); // Make trees clickable
      }

       // --- Input Handling ---
       this.input.on('gameobjectdown', this.handleObjectClick, this);
       this.input.on('pointerdown', this.handleBackgroundClick, this);
       // Add listener for the 'D' key
       this.input.keyboard.on('keydown-D', this.toggleDebugDisplay, this);
       // Add listener for 's' key (lowercase) to speed up
       this.input.keyboard.on('keydown-S', (event) => {
           if (event.shiftKey) { // Check if Shift is held for uppercase 'S'
               this.changeTimeScale(0.5); // Slow down
           } else {
               this.changeTimeScale(2); // Speed up (lowercase 's')
           }
       });


       // --- Start Overlay Logic ---
       const overlay = document.getElementById('start-overlay');
       if (overlay) {
            overlay.addEventListener('pointerdown', () => {
                if (!this.gameStarted && !this.gameOver) { // Ensure game not already over
                    overlay.style.display = 'none';
                    if (this.sound.context.state === 'suspended') {
                        this.sound.context.resume().then(() => {
                            console.log('Audio Context resumed!');
                            this.startGameLogic();
                        }).catch(e => console.error('Error resuming audio context:', e));
                    } else {
                         this.startGameLogic();
                    }
                }
            }, { once: true });
       } else {
           console.warn("Start overlay not found!");
           this.startGameLogic(); // Attempt to start anyway if overlay missing
       }
    }

    /**
     * Checks if a given position is occupied by another unit.
     * @param {number} x - The x-coordinate to check.
     * @param {number} y - The y-coordinate to check.
     * @param {Phaser.GameObjects.Sprite | null} excludingUnit - A unit to exclude from the check (usually the unit being spawned).
     * @returns {boolean} True if the position is occupied, false otherwise.
     */
    isPositionOccupied(x, y, excludingUnit = null) {
        const unitsToCheck = [this.worker, this.aiWorker, ...this.playerSpearmen, ...this.aiSpearmen];
        for (const unit of unitsToCheck) {
            // Check if unit exists, is active, and is not the one we're excluding
            if (unit && unit.active && unit !== excludingUnit) {
                const distance = Phaser.Math.Distance.Between(x, y, unit.x, unit.y);
                if (distance < UNIT_COLLISION_RADIUS) { // Use a radius for overlap check
                    return true; // Position is occupied
                }
            }
        }
        return false; // Position is clear
    }

    /**
     * Finds a nearby empty position around a starting point.
     * @param {number} startX - The initial x-coordinate.
     * @param {number} startY - The initial y-coordinate.
     * @param {number} maxRange - The maximum distance to search.
     * @param {Phaser.GameObjects.Sprite | null} excludingUnit - A unit to exclude from the occupancy check.
     * @returns {{x: number, y: number}} The coordinates of an empty position, or the original position if none found.
     */
    findNearbyEmptyPosition(startX, startY, maxRange = 50, excludingUnit = null) {
        // Simple random search for now
        for (let i = 0; i < 10; i++) { // Try 10 times
            const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);
            const radius = Phaser.Math.FloatBetween(UNIT_COLLISION_RADIUS, maxRange); // Search between collision radius and max range
            const checkX = startX + Math.cos(angle) * radius;
            const checkY = startY + Math.sin(angle) * radius;

            if (!this.isPositionOccupied(checkX, checkY, excludingUnit)) {
                // Found an empty spot
                // Optional: Clamp position to stay within game bounds
                // checkX = Phaser.Math.Clamp(checkX, 0, this.sys.game.config.width);
                // checkY = Phaser.Math.Clamp(checkY, 0, this.sys.game.config.height);
                return { x: checkX, y: checkY };
            }
        }
        // If no spot found after several tries, return the original position
        this.logDebug("Could not find nearby empty spot, using original spawn point.");
        return { x: startX, y: startY };
    }


    /**
     * Changes the game's time scale.
     * @param {number} factor - The factor to multiply the current time scale by (e.g., 2 to double, 0.5 to halve).
     */
    changeTimeScale(factor) {
        if (this.gameOver || !this.gameStarted) return; // Don't change speed if game not running

        // Ensure factor is positive
        if (factor <= 0) {
            this.logDebug("Invalid time scale factor.");
            return;
        }

        this.time.timeScale *= factor;

        // Optional: Clamp the time scale to reasonable limits
        this.time.timeScale = Phaser.Math.Clamp(this.time.timeScale, 0.125, 8); // e.g., min 1/8, max 8x speed

        this.logDebug(`Time scale set to ${this.time.timeScale.toFixed(3)}x`);

        // Adjust sound playback rates if desired (more complex, might need individual sound adjustment)
        // Example (adjusting global sound playback rate - might affect pitch):
        // this.sound.setRate(this.time.timeScale);
    }

    /**
     * Toggles the visibility of the debug text area.
     */
    toggleDebugDisplay() {
        if (this.debugText) {
            this.debugText.visible = !this.debugText.visible;
            // Optionally log the toggle action itself (if debug is visible)
            if (this.debugText.visible) {
                 this.logDebug(`Debug display toggled ON`);
                 // Refresh text content when turned on
                 this.debugText.setText('Debug Output:\n' + this.debugHistory.join('\n'));
            } else {
                 // If turning off, log to console instead
                 console.log("DEBUG: Debug display toggled OFF");
            }
        }
    }

    /**
     * Handles clicks on interactive game objects (worker, trees).
     * Player cannot directly command spearmen in this version.
     */
    handleObjectClick(pointer, gameObject) {
        if (this.gameOver || !this.gameStarted) return; // Ignore clicks if game over or not started
        this.objectClickedRecently = true; // Set the flag immediately
        this.logDebug(`Clicked ${gameObject.texture?.key || 'unknown object'} (Type: ${gameObject.getData('unitType')})`);

        // Only allow selecting/commanding the player worker
        if (gameObject.getData('unitType') === 'worker' && gameObject.getData('isPlayer')) {
             if (this.selectedWorker === gameObject) {
                 // Clicked the selected worker again: Deselect
                 this.logDebug('Worker deselected.');
                 this.selectedWorker.clearTint();
                 this.selectedWorker = null;
             } else {
                  // Clicked the player worker: Select it
                  if (this.selectedWorker) this.selectedWorker.clearTint(); // Deselect previous if any
                  this.logDebug('Worker selected.');
                  gameObject.setTint(0x00ffff); // Apply bright cyan tint
                  this.selectedWorker = gameObject;
             }
        } else if (this.selectedWorker) {
            // Worker is selected, check if clicked a tree
            if (gameObject.texture?.key === 'tree_sheet' && this.trees.contains(gameObject)) {
                // Clicked a tree while worker selected: Check if tree is busy
                const targetTree = gameObject;
                // Check if this specific tree is currently being cut by any worker
                const isPlayerChoppingThis = this.worker.isCutting && this.worker.cuttingTarget === targetTree;
                const isAiChoppingThis = this.aiWorker.isCutting && this.aiWorker.cuttingTarget === targetTree;
                // Also check if another worker is moving specifically to chop this tree
                const isPlayerMovingToChopThis = this.worker.moving && this.worker.target === targetTree && this.worker.state === 'moving_to_chop';
                const isAiMovingToChopThis = this.aiWorker.moving && this.aiWorker.target === targetTree && this.aiWorker.state === 'moving_to_chop';


                if (isPlayerChoppingThis || isAiChoppingThis || isPlayerMovingToChopThis || isAiMovingToChopThis) {
                    // Tree is busy or targeted - flash red and do nothing else
                    this.logDebug('Invalid command: Tree is busy or targeted.');
                    targetTree.setTintFill(0xff0000); // Red tint fill
                    this.time.delayedCall(250, () => { // Remove tint after short delay
                        if (targetTree.active) { // Check if tree still exists
                             targetTree.clearTint();
                        }
                    });
                    // Keep worker selected
                } else {
                    // Tree is available: Command worker to chop
                    const workerToCommand = this.selectedWorker;
                    this.logDebug('Commanding worker to chop selected tree.');
                    this.sendWorkerToTree(workerToCommand, targetTree);
                    // Deselect after issuing command
                    workerToCommand.clearTint();
                    this.selectedWorker = null;
                }
            } else {
                 // Clicked something else (not the worker, not a tree) while worker selected: Deselect
                 this.logDebug('Clicked other object. Deselecting worker.');
                 this.selectedWorker.clearTint();
                 this.selectedWorker = null;
            }
        } else {
             // No worker selected, clicked something other than the player worker
             this.logDebug('Clicked object, but no worker selected or target is not player worker.');
        }
    }


    /**
     * Handles clicks on the background (not on an interactive object).
     * Only moves the selected player worker.
     */
    handleBackgroundClick(pointer) {
        if (this.gameOver || !this.gameStarted) return; // Ignore clicks if game over or not started

        // Check the flag first
        if (this.objectClickedRecently) {
            this.objectClickedRecently = false; // Reset flag
            this.logDebug('BG click ignored (object clicked).');
            return; // Exit early, do not process this background click
        }

        this.logDebug('Pointer down detected.');

        // Check if the click was not on any interactive game object
        if (!pointer.targetObject) {
             this.logDebug('Clicked background.');

            // If the player worker is selected, issue move command
            if (this.selectedWorker && this.selectedWorker === this.worker) {
                const workerToMove = this.selectedWorker;
                const targetX = pointer.worldX;
                const targetY = pointer.worldY;

                this.logDebug(`Move command issued to (${Math.round(targetX)}, ${Math.round(targetY)})`);

                // --- Show flashing marker ---
                const clickMarker = this.add.circle(targetX, targetY, 10, 0xff0000, 0.8).setDepth(3000);
                 this.tweens.add({
                     targets: clickMarker,
                     alpha: 0,
                     duration: 1000, // 1 second duration
                     ease: 'Power1',
                     onComplete: () => {
                         if(clickMarker.active) clickMarker.destroy();
                     }
                 });

                // --- Stop current actions ---
                 this.logDebug('Stopping current worker actions for move command.');
                if (workerToMove.isCutting) {
                    this.stopCutting(workerToMove); // Handles partial wood
                }
                if (workerToMove.isBuilding) { // NEW: Stop building if moving
                    this.stopBuilding(workerToMove);
                }
                if (workerToMove.moving) {
                    this.tweens.killTweensOf(workerToMove); // Stop existing movement
                    workerToMove.moving = false;
                    workerToMove.target = null; // Clear old target
                    // Reset visuals immediately after stopping tween
                    workerToMove.setTexture('worker_sheet');
                    workerToMove.anims.stop('worker_walk'); // Stop specific animation
                    workerToMove.setFrame(0);
                    workerToMove.setFlipX(false); // Default to right
                     // Stop walk sound if needed
                     if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                         // Check if AI worker is also moving before stopping sound
                         if (!this.aiWorker || !this.aiWorker.moving) {
                              this.workerWalkSound.stop();
                         }
                    }
                }
                // Clear any potential targets
                workerToMove.cuttingTarget = null;
                workerToMove.buildingTarget = null;
                workerToMove.initialChopHealth = null;


                // --- Start new movement to clicked point ---
                workerToMove.state = 'moving_to_idle'; // Set a specific state
                const distance = Phaser.Math.Distance.Between(workerToMove.x, workerToMove.y, targetX, targetY);
                const speed = 100; // Pixels per second
                const duration = (distance / speed) * 1000 || 1; // Ensure duration > 0

                // Ensure walk animation plays and sprite is flipped correctly for the new path
                workerToMove.anims.play('worker_walk', true); // Use specific animation key
                if (targetX < workerToMove.x) {
                    workerToMove.setFlipX(true); // Moving left
                } else {
                    workerToMove.setFlipX(false); // Moving right
                }
                workerToMove.moving = true; // Set moving flag for the new movement

                 // Start walk sound if needed
                 if (this.workerWalkSound && !this.workerWalkSound.isPlaying) {
                     // Check if AI is also moving
                     if (!this.aiWorker || !this.aiWorker.moving) { // Start only if AI isn't moving
                          this.workerWalkSound.play({ loop: true });
                     }
                 }

                // Start the actual movement tween
                this.tweens.add({
                    targets: workerToMove,
                    x: targetX,
                    y: targetY,
                    duration: duration,
                    ease: 'Linear',
                    onComplete: () => {
                        // Check if worker still exists and is in the correct state
                        if (!workerToMove.active || workerToMove.state !== 'moving_to_idle') return;

                        workerToMove.moving = false;
                        workerToMove.state = 'idle';
                        workerToMove.setTexture('worker_sheet');
                        workerToMove.anims.stop('worker_walk'); // Stop specific animation
                        workerToMove.setFrame(0);
                        workerToMove.setFlipX(false); // Reset flip to default right on arrival
                        this.logDebug('Worker reached destination and is idle.');
                        // Stop walk sound if needed
                        if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                             // Only AI could be moving now
                             if (!this.aiWorker || !this.aiWorker.moving) {
                                  this.workerWalkSound.stop();
                             }
                        }
                    },
                    onStop: () => { // Handle interruption of *this specific* move
                         if (!workerToMove.active) return;
                         // If interrupted, just go idle where it stopped
                         workerToMove.moving = false;
                         if (workerToMove.state === 'moving_to_idle') { // Only change state if it was still moving to idle
                             workerToMove.state = 'idle';
                             workerToMove.setTexture('worker_sheet');
                             workerToMove.anims.stop('worker_walk'); // Stop specific animation
                             workerToMove.setFrame(0);
                             workerToMove.setFlipX(false);
                             this.logDebug('Worker move interrupted, going idle.');
                         }
                         // Stop walk sound if needed
                         if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                             if (!this.aiWorker || !this.aiWorker.moving) {
                                  this.workerWalkSound.stop();
                             }
                         }
                    }
                });

                // Deselect the worker visually and logically AFTER issuing the command
                workerToMove.clearTint();
                this.selectedWorker = null;


            } else {
                // No worker was selected, or selected unit wasn't the player worker
                 this.logDebug('Clicked background (no player worker selected).');
                 // Deselect any selected worker if background is clicked
                 if(this.selectedWorker) {
                     this.selectedWorker.clearTint();
                     this.selectedWorker = null;
                     this.logDebug('Worker deselected due to background click.');
                 }
            }
        }
    }


    /**
     * Starts the main game logic after user interaction.
     */
    startGameLogic() {
        this.gameStarted = true;
        this.gameOver = false;
        // Don't automatically set state to chopping, let handleWorkerState decide
        if(this.worker) this.worker.state = 'idle';
        if(this.aiWorker) this.aiWorker.state = 'idle';
        this.logDebug("Game started.");
        console.log("Game logic started.");
    }


    /**
     * Creates health bar graphics for a given unit.
     * @param {Phaser.GameObjects.Sprite | Phaser.GameObjects.Image} unit - The unit to add the health bar to.
     * @param {number} barWidth - The width of the health bar.
     * @param {number} barColor - The color of the health fill.
     */
     createHealthBar(unit, barWidth, barColor) {
        if (!unit) return;
        // const barHeight = 8; // Use global constant
        // Use displayHeight if available, otherwise height
        const unitHeight = unit.displayHeight || unit.height || 64;
        const initialYOffset = -unitHeight - 5; // Position above the unit
        const x = unit.x;
        const y = unit.y + initialYOffset;

        // Ensure previous bars are destroyed if they exist (e.g., recreating)
        if (unit.healthBarBg) unit.healthBarBg.destroy();
        if (unit.healthBarFill) unit.healthBarFill.destroy();

        unit.healthBarBg = this.add.rectangle(x, y, barWidth, HEALTH_BAR_HEIGHT, 0x333333).setOrigin(0.5);
        unit.healthBarFill = this.add.rectangle(x - barWidth / 2, y, barWidth, HEALTH_BAR_HEIGHT, barColor).setOrigin(0, 0.5);
        unit.healthBarWidth = barWidth; // Store the width on the unit

        // Explicitly set depth upon creation
        if (unit.healthBarBg) unit.healthBarBg.setDepth(unit.depth + 1);
        if (unit.healthBarFill) unit.healthBarFill.setDepth(unit.depth + 2);

        // Ensure health bars are initially drawn above the unit
        this.updateHealthBar(unit); // Call update to set initial position and fill correctly
      }

    /**
     * Creates a temporary health bar for the tree being cut.
     */
    createTreeHealthBar(tree) {
        if (!tree || !tree.active || tree.healthBarBg) return; // Don't create if it already exists or tree inactive

        const barWidth = 40; // Keep tree bar width separate
        // const barHeight = 8; // Use global constant
        const yOffset = -tree.displayHeight - 5; // Use displayHeight
        const x = tree.x;
        const y = tree.y + yOffset;

        tree.healthBarBg = this.add.rectangle(x, y, barWidth, HEALTH_BAR_HEIGHT, 0x333333).setOrigin(0.5);
        tree.healthBarFill = this.add.rectangle(x - barWidth / 2, y, barWidth, HEALTH_BAR_HEIGHT, 0xffffff).setOrigin(0, 0.5); // White for tree
        tree.healthBarWidth = barWidth;

        // Explicitly set depth upon creation
        if (tree.healthBarBg) tree.healthBarBg.setDepth(tree.depth + 1);
        if (tree.healthBarFill) tree.healthBarFill.setDepth(tree.depth + 2);

        this.updateTreeHealthBar(tree); // Update position and fill immediately
    }

     /**
       * Updates the position and fill of a specific tree's health bar.
       */
      updateTreeHealthBar(tree) {
       if (!tree || !tree.active || !tree.healthBarBg || !tree.healthBarFill) {
             // If bar doesn't exist or tree inactive, attempt to destroy remnants
             this.destroyTreeHealthBar(tree);
             return;
       }
       const barWidth = tree.healthBarWidth;
       const yOffset = -tree.displayHeight - 5; // Use displayHeight
       const x = tree.x;
       const y = tree.y + yOffset;

       tree.healthBarBg.setPosition(x, y);
       tree.healthBarFill.setPosition(x - barWidth / 2, y);

       const fillWidth = Math.max(0, (tree.health / tree.maxHealth) * barWidth);
       tree.healthBarFill.width = fillWidth;

       // Ensure health bars are drawn above the tree
       tree.healthBarBg.setDepth(tree.depth + 1);
       tree.healthBarFill.setDepth(tree.depth + 2);
      }

    /**
     * Destroys the health bar associated with a specific tree.
     */
    destroyTreeHealthBar(tree) {
        if (tree) {
            if (tree.healthBarBg) {
                tree.healthBarBg.destroy();
                tree.healthBarBg = null;
            }
            if (tree.healthBarFill) {
                tree.healthBarFill.destroy();
                tree.healthBarFill = null;
            }
        }
    }


    /**
     * Damages the tree currently being cut by the specified worker. Called by timer.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker doing the cutting.
     */
     damageTree(workerSprite) {
        if (!this.gameStarted || this.gameOver || !workerSprite || !workerSprite.isCutting || !workerSprite.cuttingTarget || !workerSprite.cuttingTarget.active) {
            this.stopCutting(workerSprite); // Stop cutting for this specific worker if state is invalid
            return;
        }

        const tree = workerSprite.cuttingTarget;
        tree.health -= 1; // Reduce health by 1 each time

        this.updateTreeHealthBar(tree); // Update the bar visually

        if (tree.health <= 0) {
            // Tree is felled
            this.cutTree(tree, workerSprite); // Pass worker to cutTree
        } else if (tree.health <= 3.3) {
            tree.setFrame(2); // Show damaged frame
        } else if (tree.health <= 6.6) {
            tree.setFrame(1); // Show slightly damaged frame
        } else {
            tree.setFrame(0); // Full health frame
        }
      }

    /**
     * Stops the current cutting process for a specific worker and resets its state.
     * Handles partial wood collection if the tree is not fully cut.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker to stop.
     */
     stopCutting(workerSprite) {
        if (!workerSprite) return;

        const treeToStopCutting = workerSprite.cuttingTarget; // Store the target before resetting
        const initialHealth = workerSprite.initialChopHealth; // Get health when chop started
        let wasCutting = workerSprite.isCutting; // Check if it *was* cutting before resetting flags

        // Clear the specific worker's timer
        if (workerSprite.cuttingTimer) {
            workerSprite.cuttingTimer.remove(false); // false = don't call callback on remove
            workerSprite.cuttingTimer = null;
        }

        workerSprite.isCutting = false; // Set flag false now
        workerSprite.cuttingTarget = null; // Clear target
        workerSprite.initialChopHealth = null; // Reset initial health tracker

        // --- Sound Stop Logic ---
        if (this.chopSound && this.chopSound.isPlaying && wasCutting) {
            // Check if the *other* worker is still cutting OR building
            let otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
            let otherBusySound = otherWorker && otherWorker.active && (otherWorker.isCutting || otherWorker.isBuilding); // Check active state

            if (!otherBusySound) { // Stop only if the other worker isn't making the sound
                this.chopSound.stop();
            }
        }

        // Reset worker appearance (only if it was actually cutting)
        if(wasCutting) {
            workerSprite.setTexture('worker_sheet');
            workerSprite.anims.stop('worker_chop'); // Stop specific animation
            workerSprite.setFrame(0);
            workerSprite.setFlipX(false); // Reset flip
        }

        // --- Partial Wood Collection & Health Bar ---
        if (wasCutting && treeToStopCutting && treeToStopCutting.active && initialHealth !== null) {
             // Check if tree health is above 0 (i.e., not felled by cutTree)
             if (treeToStopCutting.health > 0) {
                 const healthLost = initialHealth - treeToStopCutting.health;
                 const woodGained = Math.max(0, Math.floor(healthLost)); // e.g., 1 wood per HP lost

                 if (woodGained > 0) {
                     if (workerSprite === this.worker) {
                         this.wood += woodGained;
                         this.woodText.setText('Wood: ' + this.wood);
                         this.logDebug(`Stopped chopping. Gained ${woodGained} wood (partial).`);
                     } else if (workerSprite === this.aiWorker) {
                         this.aiWood += woodGained;
                         this.aiWoodText.setText('AI Wood: ' + this.aiWood);
                         this.logDebug(`AI stopped chopping. Gained ${woodGained} wood (partial).`);
                     }
                     this.checkEndCondition(); // Check if partial wood caused win
                 } else {
                      this.logDebug(`Stopped chopping. No partial wood gained.`);
                 }

                 // Update tree health bar one last time if it still exists
                 this.updateTreeHealthBar(treeToStopCutting);

             } // else: tree health is <= 0, cutTree handled wood, don't award partial

             // Destroy health bar only if the other worker isn't also cutting it
             let otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
             if (!otherWorker || !otherWorker.active || !otherWorker.isCutting || otherWorker.cuttingTarget !== treeToStopCutting) { // Check active state
                 this.destroyTreeHealthBar(treeToStopCutting);
             }

        } else if (treeToStopCutting) {
             // If not cutting or tree invalid, still try to clean up bar if needed
             let otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
             if (!otherWorker || !otherWorker.active || !otherWorker.isCutting || otherWorker.cuttingTarget !== treeToStopCutting) { // Check active state
                 this.destroyTreeHealthBar(treeToStopCutting);
             }
        }
      }


    /**
     * Finalizes cutting the tree, adds wood, removes tree, checks end condition.
     * @param {Phaser.GameObjects.Sprite} tree - The tree sprite that was cut.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker who cut the tree.
     */
    cutTree(tree, workerSprite) {
      // Stop the cutting process formally (clears timer, sounds, etc.)
      // Note: partial wood won't be awarded here because health <= 0 check in stopCutting
      this.stopCutting(workerSprite);

      if (!tree || !workerSprite) { // Check worker too
        console.warn("Attempted to cut tree with invalid tree or worker.");
        this.destroyTreeHealthBar(tree);
        if(workerSprite) workerSprite.state = 'chopping'; // Try to find new task
        return;
      }

      // Award full wood amount for felling the tree
      const woodFromFelledTree = 10;
      if (workerSprite === this.worker) {
          this.wood += woodFromFelledTree;
          this.woodText.setText('Wood: ' + this.wood);
          this.logDebug(`Tree felled! Gained ${woodFromFelledTree} wood. Total: ${this.wood}`);
      } else if (workerSprite === this.aiWorker) {
          this.aiWood += woodFromFelledTree;
          this.aiWoodText.setText('AI Wood: ' + this.aiWood);
          this.logDebug(`AI felled tree. Gained ${woodFromFelledTree} wood. Total: ${this.aiWood}`);
      }

      // Ensure worker state is reset correctly after felling
      workerSprite.isCutting = false; // Should be done by stopCutting, but ensure
      workerSprite.cuttingTarget = null;
      workerSprite.initialChopHealth = null;
      workerSprite.state = 'chopping'; // Set state to find next tree
      workerSprite.setTexture('worker_sheet');
      workerSprite.anims.stop(); // Stop any animation
      workerSprite.setFrame(0);
      workerSprite.setFlipX(false);


      // Destroy the tree health bar explicitly
      this.destroyTreeHealthBar(tree);
      this.trees.remove(tree, true, true); // Remove from group and destroy sprite

      // Check end condition AFTER wood is updated and tree removed
      this.checkEndCondition();

      // Worker automatically looks for next tree via handleWorkerState in update loop
      // State was already set to 'chopping'
    }

    /**
     * Checks if the game should end based on wood counts or house destruction.
     */
    checkEndCondition() {
        if (this.gameOver) return; // Don't check if already ended

        // Check for house destruction first
        if (this.house && !this.house.active) { // Player house destroyed
            this.endGame("Computer Wins!", '#ff0000'); // Red for loss
            return;
        }
        if (this.aiHouse && !this.aiHouse.active) { // AI house destroyed
            this.endGame("You Win!", '#ffff00'); // Yellow for win
            return;
        }

        // Check for wood win condition
        const winAmount = 100;
        if (this.wood >= winAmount) {
            this.endGame("You Win!", '#ffff00'); // Yellow for win
            return;
        }
        if (this.aiWood >= winAmount) {
            this.endGame("Computer Wins!", '#ff0000'); // Red for loss
            return;
        }

        // Check for draw (no trees left AND no units/buildings left to fight/build/chop)
        const remainingTrees = this.trees.countActive(true);
        if (remainingTrees === 0) {
            // Check if any worker is still busy
             const playerWorkerBusy = this.worker && this.worker.active && (this.worker.moving || this.worker.isCutting || this.worker.isBuilding);
             const aiWorkerBusy = this.aiWorker && this.aiWorker.active && (this.aiWorker.moving || this.aiWorker.isCutting || this.aiWorker.isBuilding);
             // Check if any spearman is busy
             const playerSpearmanBusy = this.playerSpearmen.some(s => s.active && (s.moving || s.isAttacking));
             const aiSpearmanBusy = this.aiSpearmen.some(s => s.active && (s.moving || s.isAttacking));
             // Check if barracks are busy
             const playerBarrackBusy = this.playerBarrack && this.playerBarrack.active && (this.playerBarrack.isBuilding || this.playerBarrack.isTraining);
             const aiBarrackBusy = this.aiBarrack && this.aiBarrack.active && (this.aiBarrack.isBuilding || this.aiBarrack.isTraining);


            if (!playerWorkerBusy && !aiWorkerBusy && !playerSpearmanBusy && !aiSpearmanBusy && !playerBarrackBusy && !aiBarrackBusy) { // Only draw if no trees AND nothing else is happening
                 this.endGame("Draw!", '#ffffff'); // White for draw
                 return;
            }
        }
    }

    /**
     * Ends the game, displaying a message and stopping activity.
     */
    endGame(message, color = '#ffffff') {
        if (this.gameOver) return; // Prevent multiple calls

        this.gameOver = true;
        this.gameStarted = false; // Stop main game logic in update

        this.logDebug(`Game Over: ${message}`); // Use new log function

        this.add.text(this.sys.game.config.width / 2, this.sys.game.config.height / 2,
                                         message,
                                         { font: '48px Arial', fill: color, align: 'center' })
                                         .setOrigin(0.5)
                                         .setDepth(2000); // Ensure message is on top

        // Stop everything
        this.input.enabled = false; // Disable input on game over
        this.tweens.killAll(); // Stop all movement tweens

        // Stop sounds
        if (this.workerWalkSound && this.workerWalkSound.isPlaying) this.workerWalkSound.stop();
        if (this.chopSound && this.chopSound.isPlaying) this.chopSound.stop();
        if (this.spearmanAttackSound && this.spearmanAttackSound.isPlaying) this.spearmanAttackSound.stop(); // Stop attack sound
        // this.sound.stopAll(); // Use with caution if other sounds exist

        // Stop timers and reset workers visually/state-wise
        [this.worker, this.aiWorker].forEach(w => {
            if (w && w.active) { // Check active
                 if (w.isCutting) this.stopCutting(w);
                 if (w.isBuilding) this.stopBuilding(w); // Stop building too
                 w.state = 'idle'; // Ensure state is idle
                 w.moving = false; // Ensure moving is false
                 w.target = null; // Clear target
                 w.setTexture('worker_sheet');
                 w.anims.stop();
                 w.setFrame(0);
                 w.setFlipX(false);
            }
        });
        // Clean up spearmen
        [...this.playerSpearmen, ...this.aiSpearmen].forEach(spearman => {
             if (spearman && spearman.active) { // Check active
                 if(spearman.isAttacking) this.stopAttacking(spearman); // Stop attacking
                 spearman.state = 'idle';
                 spearman.moving = false;
                 spearman.attackTarget = null;
                 spearman.setTexture('spearman_walk_sheet');
                 spearman.anims.stop();
                 spearman.setFrame(0);
                 spearman.setFlipX(false);
                 // Don't destroy here, let update loop handle cleanup based on active flag
             }
        });
        // this.playerSpearmen = []; // Don't clear arrays, let update handle inactive
        // this.aiSpearmen = [];

        // Clean up barracks
        [this.playerBarrack, this.aiBarrack].forEach(barrack => {
             if (barrack && barrack.active) { // Check active
                 if (barrack.trainingTimer) barrack.trainingTimer.remove();
                 // this.destroyHealthBar(barrack); // Health bar destroyed in takeDamage
                 this.destroyTrainingText(barrack); // Destroy text bubble
                 barrack.isTraining = false;
             }
        });


         // Destroy any remaining tree health bars
         if (this.trees) {
            this.trees.getChildren().forEach(tree => this.destroyTreeHealthBar(tree));
         }


        console.log("Game Over:", message);
    }


    /**
     * Updates the position and fill of a unit's health bar.
     */
    updateHealthBar(unit) {
        // Only update if the unit and its health bars are active/exist
        if (!unit || !unit.active || !unit.healthBarBg || !unit.healthBarFill || !unit.healthBarBg.active || !unit.healthBarFill.active) {
             this.destroyHealthBar(unit); // Attempt cleanup if invalid
            return;
        }

        // --- Update existing bar ---
        const barWidth = unit.healthBarWidth;
         // Use displayHeight if available, otherwise height
        const unitHeight = unit.displayHeight || unit.height || 64;
        const yOffset = -unitHeight - 5; // Position above unit
        const x = unit.x;
        const y = unit.y + yOffset;

        unit.healthBarBg.setPosition(x, y);
        unit.healthBarFill.setPosition(x - barWidth / 2, y);

        // Ensure health and maxHealth are valid numbers
        const currentHealth = typeof unit.health === 'number' ? unit.health : 0;
        const maxHealth = typeof unit.maxHealth === 'number' && unit.maxHealth > 0 ? unit.maxHealth : 1;
        const fillRatio = Math.max(0, Math.min(1, currentHealth / maxHealth)); // Clamp between 0 and 1

        const fillWidth = fillRatio * barWidth;
        unit.healthBarFill.width = fillWidth;

        // Set depth based on the unit's depth (handled in main update loop)
        // if (unit.healthBarBg) unit.healthBarBg.setDepth(unit.depth + 1);
        // if (unit.healthBarFill) unit.healthBarFill.setDepth(unit.depth + 2);
    }

     /**
       * Destroys the health bar associated with any unit/building.
       */
      destroyHealthBar(unit) {
        if (unit) {
            if (unit.healthBarBg) {
                unit.healthBarBg.destroy();
                unit.healthBarBg = null;
            }
            if (unit.healthBarFill) {
                unit.healthBarFill.destroy();
                unit.healthBarFill = null;
            }
        }
      }

     /**
       * Creates a training progress text bubble for a barrack.
       * @param {Phaser.GameObjects.Sprite} barrack - The barrack to add the text to.
       */
      createTrainingText(barrack) {
        if (!barrack || !barrack.active || barrack.trainingText) return; // Added active check

        this.logDebug("Creating training text..."); // Debug log
        this.destroyTrainingText(barrack); // Ensure previous is destroyed

        barrack.trainingText = this.add.text(0, 0, '0%', TRAINING_TEXT_STYLE)
            .setOrigin(0.5, 1); // Origin at bottom-center for positioning above

        if (!barrack.trainingText) {
             this.logDebug("ERROR: Failed to create text object!");
             return;
        }
        // Initial update will set position and text
        this.updateTrainingText(barrack);
        this.logDebug("Training text created."); // Debug log
      }

     /**
       * Updates the position and content of a barrack's training text bubble.
       * @param {Phaser.GameObjects.Sprite} barrack - The barrack whose text to update.
       */
      updateTrainingText(barrack) {
        // Check if the text object exists and training is active before proceeding
        if (!barrack || !barrack.active || !barrack.isTraining || !barrack.trainingText || !barrack.trainingText.active) { // Added active check for text
             this.destroyTrainingText(barrack); // Clean up if invalid state
             return;
        }

        // Double-check timer existence here just for getting progress
        if (!barrack.trainingTimer) {
             return; // Exit if timer is gone, spawnSpearman will handle cleanup
        }


        const text = barrack.trainingText;

        // Calculate position above the barrack (and above health bar)
        const unitHeight = barrack.displayHeight || barrack.height || 64;
        const yOffset = -unitHeight - 5 - HEALTH_BAR_HEIGHT - 5; // Above health bar + spacing
        const x = barrack.x;
        const y = barrack.y + yOffset;
        text.setPosition(x, y);

        // Update text based on timer progress
        const progress = barrack.trainingTimer.getProgress(); // Value between 0 and 1
        const percent = Math.floor(progress * 100);
        text.setText(percent + '%');

        // Update depth relative to barrack - ensure it stays on top (handled in main update)
        // text.setDepth(barrack.depth + 10);
      }

     /**
       * Destroys the training text bubble associated with a barrack.
       * @param {Phaser.GameObjects.Sprite} barrack - The barrack whose text to destroy.
       */
      destroyTrainingText(barrack) {
        if (barrack && barrack.trainingText && barrack.trainingText.active) { // Added active check
            // this.logDebug("Destroying training text."); // Debug log - can be spammy
            barrack.trainingText.destroy();
            barrack.trainingText = null;
        }
      }


    /**
     * Finds the closest active tree to the specified worker, avoiding trees targeted by the other worker.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker to find the closest tree for.
     * @returns {Phaser.GameObjects.Sprite | null} The closest tree or null if none found or available.
     */
    findClosestTree(workerSprite) {
        if (!workerSprite || !this.trees) return null;

        const activeTrees = this.trees.getChildren().filter(tree => tree.active);
        if (activeTrees.length === 0) {
            return null; // No trees left at all
        }

        let closestTree = null;
        let minDistance = Infinity;
        const workerIsPlayer = workerSprite.getData('isPlayer');

        activeTrees.forEach(tree => {
            // --- Target Avoidance Logic ---
            let isTreeBusy = false;
            const otherWorker = workerIsPlayer ? this.aiWorker : this.worker;

            // Check if player worker is targeting/cutting this tree
            if (this.worker && this.worker.active && this.worker !== workerSprite) {
                 if (this.worker.isCutting && this.worker.cuttingTarget === tree) isTreeBusy = true;
                 if (this.worker.moving && this.worker.target === tree && this.worker.state === 'moving_to_chop') isTreeBusy = true;
            }
             // Check if AI worker is targeting/cutting this tree
             if (this.aiWorker && this.aiWorker.active && this.aiWorker !== workerSprite) {
                 if (this.aiWorker.isCutting && this.aiWorker.cuttingTarget === tree) isTreeBusy = true;
                 if (this.aiWorker.moving && this.aiWorker.target === tree && this.aiWorker.state === 'moving_to_chop') isTreeBusy = true;
             }


            if (isTreeBusy) {
                return; // Skip this tree, it's claimed by the other worker
            }
            // --- End Target Avoidance ---

            const distance = Phaser.Math.Distance.Between(workerSprite.x, workerSprite.y, tree.x, tree.y);
            if (distance < minDistance) {
                minDistance = distance;
                closestTree = tree;
            }
        });

        return closestTree;
    }

    /**
     * Sends the specified worker to move towards and cut a specific tree.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker to send.
     * @param {Phaser.GameObjects.Sprite} tree - The target tree.
     */
    sendWorkerToTree(workerSprite, tree) {
        if (!tree || !tree.active || !workerSprite || !workerSprite.active || this.gameOver) { // Added active check for worker
             this.logDebug('Cannot send worker: Invalid target/worker or game over.');
            return;
        }

         // --- Stop any existing actions before sending to tree ---
         const workerId = workerSprite.getData('isPlayer') ? 'Player' : 'AI';
         this.logDebug(`Sending ${workerId} worker to tree.`);
         if (workerSprite.isCutting) {
             this.stopCutting(workerSprite); // Will handle partial wood
         }
          if (workerSprite.isBuilding) {
             this.stopBuilding(workerSprite);
         }
         if (workerSprite.moving) {
             this.tweens.killTweensOf(workerSprite); // Stop existing movement
             workerSprite.moving = false;
             // Don't reset state here, it will be set below
             // Reset visuals immediately after stopping tween
             workerSprite.setTexture('worker_sheet');
             workerSprite.anims.stop(); // Stop any animation
             workerSprite.setFrame(0);
             workerSprite.setFlipX(false); // Default to right
             // Stop walk sound if needed
             if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                 let otherWorker = workerId === 'Player' ? this.aiWorker : this.worker;
                 if (!otherWorker || !otherWorker.active || !otherWorker.moving) { // Check active state
                      this.workerWalkSound.stop();
                 }
            }
         }
         // Clear any potential targets
         workerSprite.target = null; // Clear previous move/build target
         workerSprite.cuttingTarget = null;
         workerSprite.buildingTarget = null;
         workerSprite.initialChopHealth = null; // Ensure this is clear before new move
         // --- End Stop Actions ---


        workerSprite.target = tree; // Set the target tree for movement
        workerSprite.moving = true; // Set moving flag
        workerSprite.state = 'moving_to_chop'; // Use a specific state

        const offset = 30; // How close the worker gets to the tree center (adjust as needed)
        const targetY = tree.y; // Move to the same Y level as the tree base
        let targetX;
        let faceRightOnArrival; // Determines the direction to *face* when chopping (not moving)

        // Determine target X based on which side of the tree the worker is on
        if (workerSprite.x <= tree.x) {
            targetX = tree.x - offset; // Approach from the left
            faceRightOnArrival = true; // Need to face right (flipX=false) to chop tree at right
        } else {
            targetX = tree.x + offset; // Approach from the right
            faceRightOnArrival = false; // Need to face left (flipX=true) to chop tree at left
        }

        this.logDebug(`${workerId} worker moving to tree at (${Math.round(tree.x)}, ${Math.round(tree.y)}). Target: (${Math.round(targetX)}, ${Math.round(targetY)})`);


        const distance = Phaser.Math.Distance.Between(workerSprite.x, workerSprite.y, targetX, targetY);
        const speed = 100; // Pixels per second
        const duration = (distance / speed) * 1000 || 1; // Ensure duration > 0

        workerSprite.anims.play('worker_walk', true); // Play walking animation

        // --- Sound Start Logic ---
        if (this.workerWalkSound && !this.workerWalkSound.isPlaying) {
             // Check if the other worker is also moving
             let otherWorker = workerId === 'Player' ? this.aiWorker : this.worker;
             if (!otherWorker || !otherWorker.active || !otherWorker.moving) { // Start only if other isn't moving (and active)
                  this.workerWalkSound.play({ loop: true });
             }
        }
        // --- End Sound Start Logic ---


        // Flip sprite based on movement direction
        if (targetX < workerSprite.x) {
             workerSprite.setFlipX(true); // Moving left
        } else {
             workerSprite.setFlipX(false); // Moving right
        }

        // Start the movement tween
        this.tweens.add({
          targets: workerSprite,
          x: targetX,
          y: targetY,
          duration: duration,
          ease: 'Linear',
          onComplete: () => { // Use arrow function for correct 'this' scope
            // --- Movement Completion Logic ---
             // Check if worker/target still valid and in correct state
             if (!workerSprite.active || workerSprite.state !== 'moving_to_chop' || !workerSprite.target || !workerSprite.target.active) {
                 if (workerSprite.active && workerSprite.state === 'moving_to_chop') {
                     this.logDebug(`${workerId} reached location, but target invalid or state changed.`);
                     workerSprite.state = 'idle'; // Go idle if target invalid
                     workerSprite.setTexture('worker_sheet');
                     workerSprite.anims.stop();
                     workerSprite.setFrame(0);
                     workerSprite.setFlipX(false);
                 }
                 workerSprite.moving = false;
                 workerSprite.target = null;
                 // Stop walk sound if needed
                 if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                     let otherWorker = workerId === 'Player' ? this.aiWorker : this.worker;
                     if (!otherWorker || !otherWorker.active || !otherWorker.moving) { // Check active state
                        this.workerWalkSound.stop();
                     }
                 }
                 return;
             }


            workerSprite.moving = false; // Set moving false *before* checking others

            // --- Sound Stop Logic on Arrival ---
            if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                let otherWorker = workerId === 'Player' ? this.aiWorker : this.worker;
                if (!otherWorker || !otherWorker.active || !otherWorker.moving) { // Stop only if other worker isn't moving (and active)
                     this.workerWalkSound.stop();
                }
            }
            // --- End Sound Stop Logic ---

            // Check if the target tree is still valid and hasn't been claimed by the other worker
            const actualTree = workerSprite.target; // Get the target again
            workerSprite.target = null; // Clear the movement target

            // Check again if other worker snagged this tree while moving
            let otherWorker = workerId === 'Player' ? this.aiWorker : this.worker;
             if (otherWorker && otherWorker.active && ((otherWorker.isCutting && otherWorker.cuttingTarget === actualTree) || (otherWorker.moving && otherWorker.target === actualTree && otherWorker.state === 'moving_to_chop'))) {
                 // Other worker claimed this tree, find another
                 this.logDebug(`${workerId} Tree claimed by other worker. Finding another.`);
                 workerSprite.state = 'chopping'; // Re-enter state to find new tree automatically
                 workerSprite.setTexture('worker_sheet'); // Reset visual
                 workerSprite.anims.stop();
                 workerSprite.setFrame(0);
                 return; // Exit onComplete early
             }

            // --- Start Cutting ---
            workerSprite.state = 'chopping'; // Update state
            workerSprite.isCutting = true;
            workerSprite.cuttingTarget = actualTree; // Set the cutting target
            workerSprite.initialChopHealth = actualTree.health; // Store current health
            this.logDebug(`${workerId} reached tree. Starting cut (H:${actualTree.health})`);

            this.createTreeHealthBar(actualTree); // Show health bar

            // Set flip based on OPPOSITE of faceRightOnArrival to face the tree
            workerSprite.setFlipX(!faceRightOnArrival);
            workerSprite.setTexture('worker_chop_sheet'); // Switch to chopping texture
            workerSprite.anims.play('worker_chop', true); // Play chopping animation

            // --- Chop Sound Start Logic ---
             if (this.chopSound && !this.chopSound.isPlaying) {
                 // Check if other worker is also chopping/building
                 let otherWorkerBusy = otherWorker && otherWorker.active && (otherWorker.isCutting || otherWorker.isBuilding); // Check active state
                 if (!otherWorkerBusy) { // Start only if no one else is making the sound
                      this.chopSound.play({ loop: true });
                 }
             }
            // --- End Chop Sound Start Logic ---

            // Store timer on the worker
            workerSprite.cuttingTimer = this.time.addEvent({
                delay: 1000, // Damage every second
                callback: () => this.damageTree(workerSprite),
                callbackScope: this,
                loop: true
            });
            // --- End Start Cutting ---

            // --- End Movement Completion Logic ---
          },
          onStop: () => { // Handle tween being stopped externally (e.g., target destroyed or new command)
             if (!workerSprite.active) return; // Worker might have been destroyed
             const wasMoving = workerSprite.moving; // Check if it was actually moving
             workerSprite.moving = false;
             workerSprite.target = null; // Ensure target is cleared

             // If stopped while moving to chop, try chopping again (find new tree)
             if (workerSprite.state === 'moving_to_chop') {
                 workerSprite.state = 'chopping'; // Let handleWorkerState find a new tree
                 this.logDebug(`${workerId} worker move to tree interrupted, trying to find tree.`);
             } else if (workerSprite.state === 'moving_to_idle'){
                 // If it was moving to idle and stopped, just become idle
                 workerSprite.state = 'idle';
                 this.logDebug(`${workerId} worker move interrupted, going idle.`);
             } // If state was already changed (e.g., by background click), don't override

             // Reset visuals only if it was actually moving
             if(wasMoving) {
                 workerSprite.setTexture('worker_sheet');
                 workerSprite.anims.stop();
                 workerSprite.setFrame(0);
                 workerSprite.setFlipX(false); // Reset flip to default (facing right)
             }

             // Stop walk sound if needed
             if (this.workerWalkSound && this.workerWalkSound.isPlaying && wasMoving) {
                 let otherWorker = workerId === 'Player' ? this.aiWorker : this.worker;
                 if (!otherWorker || !otherWorker.active || !otherWorker.moving) { // Check active state
                      this.workerWalkSound.stop();
                 }
             }
          }
        });
    }

     /**
       * Starts the process of building a barrack for a specific side.
       * @param {Phaser.GameObjects.Sprite} workerSprite - The worker doing the building.
       * @param {string} side - 'player' or 'ai'.
       */
      startBuildingBarrack(workerSprite, side = 'player') {
       const isPlayer = side === 'player';
       const woodCount = isPlayer ? this.wood : this.aiWood;
       const existingBarrack = isPlayer ? this.playerBarrack : this.aiBarrack;
       // Check if the *specific* barrack for this side is already built OR currently being built
       const isBuildingThisBarrack = isPlayer ? this.playerBarrackBuilding : this.aiBarrackBuilding;
       const house = isPlayer ? this.house : this.aiHouse;
       const woodCost = BARRACK_WOOD_COST;

       // Ensure worker, house exist and are active. Check wood cost. Check if barrack already exists or is being built.
       if (!workerSprite || !workerSprite.active || !house || !house.active || (existingBarrack && existingBarrack.active) || isBuildingThisBarrack || woodCount < woodCost ) {
           // this.logDebug(`Cannot start ${side} barrack (invalid conditions). Existing: ${!!existingBarrack}, Building: ${isBuildingThisBarrack}, Wood: ${woodCount}`);
           // If AI failed, ensure it goes back to chopping (if idle)
           if (!isPlayer && workerSprite.state === 'idle') workerSprite.state = 'chopping';
           return;
       }

       this.logDebug(`Starting ${side} barrack construction.`);

       if (isPlayer) {
           this.playerBarrackBuilding = true;
           this.wood -= woodCost;
           this.woodText.setText('Wood: ' + this.wood);
       } else {
           this.aiBarrackBuilding = true;
           this.aiWood -= woodCost;
           this.aiWoodText.setText('AI Wood: ' + this.aiWood);
       }

       // --- Stop any existing actions ---
       if (workerSprite.isCutting) this.stopCutting(workerSprite);
       if (workerSprite.isBuilding) this.stopBuilding(workerSprite); // Should not happen, but safety check
       if (workerSprite.moving) {
           this.tweens.killTweensOf(workerSprite);
           workerSprite.moving = false;
           workerSprite.target = null;
           workerSprite.setTexture('worker_sheet');
           workerSprite.anims.stop();
           workerSprite.setFrame(0);
           workerSprite.setFlipX(false);
            if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                let otherWorker = isPlayer ? this.aiWorker : this.worker;
                if (!otherWorker || !otherWorker.active || !otherWorker.moving) { // Check active state
                    this.workerWalkSound.stop();
                }
            }
       }
       workerSprite.cuttingTarget = null;
       workerSprite.buildingTarget = null;
       workerSprite.initialChopHealth = null;
       // --- End Stop Actions ---

       // Determine build location
       const buildX = isPlayer ? house.x + 80 : house.x - 80; // Player right, AI left
       const buildY = house.y;

       // Create the barrack sprite
       const newBarrack = this.add.sprite(buildX, buildY, 'barrack').setOrigin(0.5, 1);
       newBarrack.health = 0; // Start with 0 health
       newBarrack.maxHealth = BARRACK_HEALTH;
       newBarrack.isBuilding = true; // Flag indicating construction phase
       newBarrack.isTraining = false; // Barrack not training initially
       newBarrack.trainingTimer = null;
       newBarrack.trainingText = null; // Add property for text bubble
       newBarrack.setData('unitType', 'barrack'); // Set data for health bar logic
       newBarrack.setData('isPlayer', isPlayer); // Set side
       newBarrack.setAlpha(0.5); // Start semi-transparent
       // Use constants for color and width
       const barColor = isPlayer ? PLAYER_HEALTH_BAR_COLOR : AI_HEALTH_BAR_COLOR;
       this.createHealthBar(newBarrack, BUILDING_HEALTH_BAR_WIDTH, barColor);

       if (isPlayer) {
           this.playerBarrack = newBarrack;
       } else {
           this.aiBarrack = newBarrack;
       }

       // --- Send worker to build site ---
       workerSprite.state = 'moving_to_build';
       workerSprite.target = newBarrack; // Target the building placeholder

       const offset = 40;
       const targetYBuild = buildY;
       let targetXBuild;
       let faceRightOnArrivalBuild;

       if (workerSprite.x <= buildX) {
           targetXBuild = buildX - offset;
           faceRightOnArrivalBuild = true; // Face right towards building
       } else {
           targetXBuild = buildX + offset;
           faceRightOnArrivalBuild = false; // Face left towards building
       }

       const distance = Phaser.Math.Distance.Between(workerSprite.x, workerSprite.y, targetXBuild, targetYBuild);
       const speed = 100;
       const duration = (distance / speed) * 1000 || 1;

       workerSprite.anims.play('worker_walk', true);
       if (targetXBuild < workerSprite.x) workerSprite.setFlipX(true);
       else workerSprite.setFlipX(false);
       workerSprite.moving = true;

        if (this.workerWalkSound && !this.workerWalkSound.isPlaying) {
            let otherWorker = isPlayer ? this.aiWorker : this.worker;
            if (!otherWorker || !otherWorker.active || !otherWorker.moving) { // Check active state
                 this.workerWalkSound.play({ loop: true });
            }
        }

       this.tweens.add({
           targets: workerSprite,
           x: targetXBuild,
           y: targetYBuild,
           duration: duration,
           ease: 'Linear',
           onComplete: () => {
               // Check if worker and target barrack are still valid and state is correct
               if (!workerSprite.active || workerSprite.state !== 'moving_to_build' || !workerSprite.target || !workerSprite.target.active) {
                   if(workerSprite.active && workerSprite.state === 'moving_to_build') {
                        this.logDebug(`${side} worker reached build site, but target invalid or state changed.`);
                        workerSprite.state = 'idle'; // Go idle
                        workerSprite.setTexture('worker_sheet');
                        workerSprite.anims.stop();
                        workerSprite.setFrame(0);
                        workerSprite.setFlipX(false);
                        // Attempt to cancel the build if the placeholder still exists and is building
                        const barrackToCancel = workerSprite.target; // Target might still be set
                        if (barrackToCancel && barrackToCancel.active && barrackToCancel.isBuilding) {
                            this.cancelBuilding(barrackToCancel, side, woodCost);
                        } else {
                             // Ensure build flag is reset if barrack was already destroyed
                             if(isPlayer) this.playerBarrackBuilding = false; else this.aiBarrackBuilding = false;
                        }
                   }
                   workerSprite.moving = false;
                   workerSprite.target = null;
                   // Stop walk sound if needed
                   if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                       let otherWorker = isPlayer ? this.aiWorker : this.worker;
                       if (!otherWorker || !otherWorker.active || !otherWorker.moving) { // Check active state
                        this.workerWalkSound.stop();
                       }
                   }
                   return;
               }

               workerSprite.moving = false;
                if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                    let otherWorker = isPlayer ? this.aiWorker : this.worker;
                    if (!otherWorker || !otherWorker.active || !otherWorker.moving) { // Check active state
                        this.workerWalkSound.stop();
                    }
               }

               // --- Start Building ---
               workerSprite.state = 'building';
               workerSprite.isBuilding = true;
               // Keep workerSprite.target pointing to the barrack placeholder
               workerSprite.buildingTarget = workerSprite.target; // Explicitly set buildingTarget

               this.logDebug(`${side} worker arrived at build site. Starting construction.`);

               workerSprite.setFlipX(!faceRightOnArrivalBuild); // Face the building site
               workerSprite.setTexture('worker_chop_sheet'); // Use 'chop' anim for building
               workerSprite.anims.play('worker_chop', true);

               // Start building sound (using chop sound)
               if (this.chopSound && !this.chopSound.isPlaying) {
                   // Check if other worker is also chopping/building
                   let otherWorker = isPlayer ? this.aiWorker : this.worker;
                   let otherWorkerBusy = otherWorker && otherWorker.active && (otherWorker.isCutting || otherWorker.isBuilding); // Check active state
                   if (!otherWorkerBusy) { // Start only if no one else is making the sound
                        this.chopSound.play({ loop: true });
                   }
               }

               // Start building timer
               workerSprite.buildingTimer = this.time.addEvent({
                   delay: 1000, // 1 health per second (adjust for build time)
                   callback: () => this.buildStructure(workerSprite),
                   callbackScope: this,
                   loop: true
               });
           },
            onStop: () => { // If move to build is interrupted
               if (!workerSprite.active) return; // Worker might have been destroyed
               const wasMoving = workerSprite.moving;
               workerSprite.moving = false;

               if (workerSprite.state === 'moving_to_build') {
                   workerSprite.state = 'idle'; // Default to idle if move interrupted
                   this.logDebug(`${side} worker move to build site interrupted.`);
                   // Cancel the build process
                   const barrackToCancel = workerSprite.target; // Target might still be set
                   if(barrackToCancel && barrackToCancel.active && barrackToCancel.isBuilding) {
                       this.cancelBuilding(barrackToCancel, side, woodCost);
                   } else {
                        // Ensure build flag is reset if barrack was already destroyed
                        if(isPlayer) this.playerBarrackBuilding = false; else this.aiBarrackBuilding = false;
                   }
               } // Don't override state if already changed

               workerSprite.target = null; // Clear target

               // Reset visuals only if it was moving
               if(wasMoving) {
                    workerSprite.setTexture('worker_sheet');
                    workerSprite.anims.stop();
                    workerSprite.setFrame(0);
                    workerSprite.setFlipX(false);
               }

                if (this.workerWalkSound && this.workerWalkSound.isPlaying && wasMoving) {
                    let otherWorker = isPlayer ? this.aiWorker : this.worker;
                    if (!otherWorker || !otherWorker.active || !otherWorker.moving) { // Check active state
                        this.workerWalkSound.stop();
                    }
                }

           }
       });
      }

    /**
     * Cancels the building process, destroys the placeholder, refunds wood.
     * @param {Phaser.GameObjects.Sprite} barrackPlaceholder - The barrack sprite being built.
     * @param {string} side - 'player' or 'ai'.
     * @param {number} woodCost - The amount of wood to refund.
     */
    cancelBuilding(barrackPlaceholder, side, woodCost) {
        if (!barrackPlaceholder || !barrackPlaceholder.active) return;

        this.logDebug(`Cancelling ${side} barrack construction.`);
        this.destroyHealthBar(barrackPlaceholder);
        // Training text shouldn't exist yet, but check just in case
        this.destroyTrainingText(barrackPlaceholder);
        barrackPlaceholder.destroy(); // Remove placeholder

        const isPlayer = side === 'player';
        if (isPlayer) {
            this.playerBarrack = null;
            this.playerBarrackBuilding = false;
            this.wood += woodCost;
            this.woodText.setText('Wood: ' + this.wood);
            this.logDebug(`Player refunded ${woodCost} wood.`);
        } else {
            this.aiBarrack = null;
            this.aiBarrackBuilding = false;
            this.aiWood += woodCost;
            this.aiWoodText.setText('AI Wood: ' + this.aiWood);
            this.logDebug(`AI refunded ${woodCost} wood.`);
        }
    }


     /**
       * Increases health of the structure being built. Called by timer.
       * @param {Phaser.GameObjects.Sprite} workerSprite - The worker doing the building.
       */
      buildStructure(workerSprite) {
       // Check worker validity and building state
       if (this.gameOver || !workerSprite || !workerSprite.active || !workerSprite.isBuilding || !workerSprite.buildingTarget || !workerSprite.buildingTarget.active) {
            this.stopBuilding(workerSprite); // Stop if state is invalid
            // If the target disappeared but the worker is still trying to build, ensure build flag is reset
            if(workerSprite && workerSprite.active && workerSprite.isBuilding && !workerSprite.buildingTarget) {
                 const side = workerSprite.getData('isPlayer') ? 'player' : 'ai';
                 this.logDebug(`Build target disappeared while ${side} worker was building.`);
                 this.stopBuilding(workerSprite);
                 workerSprite.state = 'idle'; // Go idle
            }
            return;
       }

       const building = workerSprite.buildingTarget;
       // Build rate can be adjusted here (e.g., building.health += 5;)
       building.health += 1; // Increase health by 1 per timer tick (currently 1/sec)

       // Update progress visuals
       this.updateHealthBar(building);
       building.setAlpha(0.5 + 0.5 * (building.health / building.maxHealth)); // Become less transparent

       // Check for completion
       if (building.health >= building.maxHealth) {
            building.health = building.maxHealth; // Cap health
            building.setAlpha(1); // Fully visible
            building.isBuilding = false; // Mark as complete (no longer under construction)
            this.updateHealthBar(building); // Final bar update

            const side = workerSprite.getData('isPlayer') ? 'Player' : 'AI';
            this.logDebug(`${side} barrack construction complete!`);

            // Update the correct building flag
            if (workerSprite.getData('isPlayer')) {
                this.playerBarrackBuilding = false;
            } else {
                this.aiBarrackBuilding = false;
            }

            // Stop the worker's building action
            this.stopBuilding(workerSprite);
            // Set worker back to finding trees (or idle if none)
            workerSprite.state = 'chopping';
       }
      }

      /**
       * Stops the current building process for a specific worker.
       * @param {Phaser.GameObjects.Sprite} workerSprite - The worker to stop.
       */
      stopBuilding(workerSprite) {
       if (!workerSprite || !workerSprite.isBuilding) return;

       const side = workerSprite.getData('isPlayer') ? 'Player' : 'AI';
       // this.logDebug(`Stopping ${side} building action.`); // Can be spammy

       // Clear timer
       if (workerSprite.buildingTimer) {
           workerSprite.buildingTimer.remove(false);
           workerSprite.buildingTimer = null;
       }

       // Stop building sound (chop sound) only if the other worker isn't chopping/building
       if (this.chopSound && this.chopSound.isPlaying) {
           const otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
           const otherWorkerBusy = otherWorker && otherWorker.active && (otherWorker.isCutting || otherWorker.isBuilding); // Check active state

           if (!otherWorkerBusy) { // Stop if the other worker isn't making the sound
                this.chopSound.stop();
           }
       }


       // Reset worker state and visuals
       workerSprite.isBuilding = false;
       workerSprite.buildingTarget = null; // Clear target
       workerSprite.setTexture('worker_sheet');
       workerSprite.anims.stop('worker_chop'); // Stop specific animation
       workerSprite.setFrame(0);
       workerSprite.setFlipX(false);
       // Don't reset state here, let the calling function decide the next state (e.g., 'chopping' or 'idle')
      }


    /**
     * Handles a worker's state machine logic.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker whose state to handle.
     */
    handleWorkerState(workerSprite) {
        if (!this.gameStarted || this.gameOver || !workerSprite || !workerSprite.active) return; // Exit if game not running or worker invalid

        const isPlayer = workerSprite.getData('isPlayer');
        const side = isPlayer ? 'player' : 'ai';

        // --- Check for Build Order ---
        // Only initiate build if idle (not moving, cutting, or already building)
        if (!workerSprite.moving && !workerSprite.isCutting && !workerSprite.isBuilding) {
             const woodCount = isPlayer ? this.wood : this.aiWood;
             const existingBarrack = isPlayer ? this.playerBarrack : this.aiBarrack;
             const isBuildingThisBarrack = isPlayer ? this.playerBarrackBuilding : this.aiBarrackBuilding;
             const house = isPlayer ? this.house : this.aiHouse;

             if (house && house.active && !(existingBarrack && existingBarrack.active) && !isBuildingThisBarrack && woodCount >= BARRACK_WOOD_COST) {
                 this.startBuildingBarrack(workerSprite, side);
                 return; // Prioritize building
             }
        }


        // --- Default Actions (Chopping/Idle) ---
        // Only act if the worker is not currently busy moving, cutting, or building
        if (!workerSprite.moving && !workerSprite.isCutting && !workerSprite.isBuilding) {
            if (workerSprite.state === 'chopping' || workerSprite.state === 'idle') { // Treat idle as wanting to chop if possible
                // Worker is idle or finished previous task - find a tree
                const closestTree = this.findClosestTree(workerSprite);
                if (closestTree) {
                     if (workerSprite.state === 'idle') {
                         this.logDebug(`${side} worker idle, finding tree.`);
                     }
                    this.sendWorkerToTree(workerSprite, closestTree);
                } else {
                    // No available trees left for this worker
                    if (workerSprite.state !== 'idle') { // Only log if state changes
                        workerSprite.state = 'idle';
                         this.logDebug(`No available trees. ${side} Worker idle.`);
                         // Reset visuals to idle
                         workerSprite.setTexture('worker_sheet');
                         workerSprite.anims.stop();
                         workerSprite.setFrame(0);
                         workerSprite.setFlipX(false);
                    }
                    // Check for draw condition again here, in case this was the last action
                    this.checkEndCondition();
                }
            }
             // Reset state if somehow stuck in a moving/building state without the flag set
             else if (workerSprite.state === 'moving_to_chop' || workerSprite.state === 'moving_to_idle' || workerSprite.state === 'moving_to_build' || workerSprite.state === 'building') {
                 this.logDebug(`${side} Worker stuck in ${workerSprite.state} without flag. Resetting to idle.`);
                 workerSprite.state = 'idle';
                 workerSprite.setTexture('worker_sheet');
                 workerSprite.anims.stop();
                 workerSprite.setFrame(0);
                 workerSprite.setFlipX(false);
             }
        }
        // If worker is moving, cutting, or building, the relevant callbacks/timers handle state changes
    }

    /**
     * Handles the training logic for a given barrack.
     * @param {Phaser.GameObjects.Sprite} barrack - The barrack to check for training.
     * @param {boolean} isPlayer - True if this is the player's barrack.
     */
     handleBarrackTraining(barrack, isPlayer) {
        // Barrack must exist, be active, NOT be under construction, and NOT already training
        if (!barrack || !barrack.active || barrack.isBuilding || barrack.isTraining) {
            return;
        }

        const spearmanArray = isPlayer ? this.playerSpearmen : this.aiSpearmen;
        const woodCount = isPlayer ? this.wood : this.aiWood;
        const side = isPlayer ? 'Player' : 'AI';

        // Check unit limit and wood cost
        if (spearmanArray.length < SPEARMAN_LIMIT && woodCount >= SPEARMAN_WOOD_COST) {
            // Start training
            barrack.isTraining = true;
            if (isPlayer) {
                this.wood -= SPEARMAN_WOOD_COST;
                this.woodText.setText('Wood: ' + this.wood);
            } else {
                this.aiWood -= SPEARMAN_WOOD_COST;
                this.aiWoodText.setText('AI Wood: ' + this.aiWood);
            }
             this.logDebug(`${side} Barrack starts training spearman (${spearmanArray.length + 1}/${SPEARMAN_LIMIT}). Cost: ${SPEARMAN_WOOD_COST}`);


            // Create the text bubble
            this.createTrainingText(barrack);

            barrack.trainingTimer = this.time.addEvent({
                delay: SPEARMAN_TRAIN_TIME,
                callback: () => this.spawnSpearman(barrack, isPlayer),
                callbackScope: this
            });
        }
    }

    /**
     * Spawns a spearman near the specified barrack.
     * @param {Phaser.GameObjects.Sprite} barrack - The barrack that finished training.
     * @param {boolean} isPlayer - True if this is the player's barrack.
     */
     spawnSpearman(barrack, isPlayer) {
        // Check if barrack still valid and was training
        if (!barrack || !barrack.active || !barrack.isTraining) {
             this.logDebug("Spawn cancelled: Barrack invalid or not training.");
             this.destroyTrainingText(barrack); // Clean up text if spawn cancelled
            return;
        }

        barrack.isTraining = false;
        barrack.trainingTimer = null; // Clear timer reference
        this.destroyTrainingText(barrack); // Destroy the text bubble on completion

        const spearmanArray = isPlayer ? this.playerSpearmen : this.aiSpearmen;
        const side = isPlayer ? 'Player' : 'AI';

        // Double-check limit before spawning
        if (spearmanArray.length >= SPEARMAN_LIMIT) {
            this.logDebug(`Spawn cancelled: ${side} spearman limit reached.`);
            return;
        }

        const initialSpawnX = barrack.x + (isPlayer ? 40 : -40); // Spawn slightly offset
        const initialSpawnY = barrack.y;

        // Check if initial position is occupied and find a new one if needed
        // Pass the spearman being spawned (null initially) to avoid self-collision check
        let finalSpawnPos = { x: initialSpawnX, y: initialSpawnY };
        let needsToMove = false;
        if (this.isPositionOccupied(initialSpawnX, initialSpawnY, null)) { // Pass null as excludingUnit
            this.logDebug("Spawn point occupied, finding nearby spot...");
            finalSpawnPos = this.findNearbyEmptyPosition(initialSpawnX, initialSpawnY, 50, null); // Pass null
            if (finalSpawnPos.x !== initialSpawnX || finalSpawnPos.y !== initialSpawnY) {
                needsToMove = true;
            }
        }

        // Create the spearman at the final position initially
        const spearman = this.add.sprite(finalSpawnPos.x, finalSpawnPos.y, 'spearman_walk_sheet').setOrigin(0.5, 1);
        spearman.health = SPEARMAN_HEALTH;
        spearman.maxHealth = SPEARMAN_HEALTH;
        spearman.state = 'idle'; // Start idle
        spearman.moving = false; // Not moving initially
        spearman.attackTarget = null; // No initial target
        spearman.isAttacking = false; // Not attacking initially
        spearman.attackTimer = null; // No attack timer initially
        spearman.setData('unitType', 'spearman'); // Set data for health bar logic
        spearman.setData('isPlayer', isPlayer); // Set side
        spearman.setFrame(0); // Start frame
        spearman.setFlipX(!isPlayer); // Player faces right, AI faces left initially

        // Add to the correct array
        spearmanArray.push(spearman);

        // Create health bar
        const barColor = isPlayer ? PLAYER_HEALTH_BAR_COLOR : AI_HEALTH_BAR_COLOR;
        this.createHealthBar(spearman, SPEARMAN_HEALTH_BAR_WIDTH, barColor);

        this.logDebug(`${side} spearman spawned! (${spearmanArray.length}/${SPEARMAN_LIMIT}) at (${Math.round(finalSpawnPos.x)}, ${Math.round(finalSpawnPos.y)})`);

        // If the final position is different from the initial check point, tween the spearman from initial to final
        if (needsToMove) {
             this.logDebug(`Spearman moving from initial spawn (${Math.round(initialSpawnX)}, ${Math.round(initialSpawnY)}) to final (${Math.round(finalSpawnPos.x)}, ${Math.round(finalSpawnPos.y)})`);
             // Temporarily place spearman at initial spot for the tween start
             spearman.setPosition(initialSpawnX, initialSpawnY);
             spearman.state = 'moving'; // State during spawn adjustment move
             spearman.moving = true;
             spearman.anims.play('spearman_walk', true);

             const distance = Phaser.Math.Distance.Between(initialSpawnX, initialSpawnY, finalSpawnPos.x, finalSpawnPos.y);
             const speed = 80; // Slower walk speed for spawn adjustment
             const duration = (distance / speed) * 1000 || 1;

             if (finalSpawnPos.x < initialSpawnX) spearman.setFlipX(true);
             else spearman.setFlipX(false);

             this.tweens.add({
                 targets: spearman,
                 x: finalSpawnPos.x,
                 y: finalSpawnPos.y,
                 duration: duration,
                 ease: 'Linear',
                 onComplete: () => {
                     if (!spearman.active) return;
                     spearman.moving = false;
                     spearman.state = 'idle'; // Become idle after spawn move
                     spearman.anims.stop();
                     spearman.setTexture('spearman_walk_sheet'); // Ensure correct texture
                     spearman.setFrame(0); // Reset frame
                     spearman.setFlipX(!isPlayer); // Reset initial facing direction
                     this.logDebug("Spearman finished spawn move.");
                 },
                 onStop: () => { // If interrupted (e.g., game ends during spawn move)
                      if (!spearman.active) return;
                      spearman.moving = false;
                      spearman.state = 'idle';
                      spearman.anims.stop();
                      spearman.setTexture('spearman_walk_sheet');
                      spearman.setFrame(0);
                      spearman.setFlipX(!isPlayer);
                      this.logDebug("Spearman spawn move interrupted.");
                 }
             });
        }
    }

    // --- NEW COMBAT FUNCTIONS ---

    /**
     * Finds the closest active enemy target for a unit.
     * @param {Phaser.GameObjects.Sprite} unit - The unit searching for a target.
     * @returns {Phaser.GameObjects.Sprite | Phaser.GameObjects.Image | null} The closest enemy target or null.
     */
    findClosestEnemyTarget(unit) {
        if (!unit || !unit.active) return null;

        const isPlayerUnit = unit.getData('isPlayer');
        let potentialTargets = [];

        // Add enemy workers, spearmen, barracks, and house to potential targets
        if (isPlayerUnit) {
            if (this.aiWorker && this.aiWorker.active) potentialTargets.push(this.aiWorker);
            if (this.aiBarrack && this.aiBarrack.active) potentialTargets.push(this.aiBarrack);
            if (this.aiHouse && this.aiHouse.active) potentialTargets.push(this.aiHouse);
            potentialTargets = potentialTargets.concat(this.aiSpearmen.filter(s => s.active));
        } else {
            if (this.worker && this.worker.active) potentialTargets.push(this.worker);
            if (this.playerBarrack && this.playerBarrack.active) potentialTargets.push(this.playerBarrack);
            if (this.house && this.house.active) potentialTargets.push(this.house);
            potentialTargets = potentialTargets.concat(this.playerSpearmen.filter(s => s.active));
        }

        if (potentialTargets.length === 0) {
            return null; // No valid targets found
        }

        let closestTarget = null;
        let minDistanceSq = Infinity; // Use squared distance for efficiency

        potentialTargets.forEach(target => {
            const distanceSq = Phaser.Math.Distance.Squared(unit.x, unit.y, target.x, target.y);
            if (distanceSq < minDistanceSq) {
                minDistanceSq = distanceSq;
                closestTarget = target;
            }
        });

        return closestTarget;
    }

     /**
      * Sends a spearman to move within attack range of a target.
      * @param {Phaser.GameObjects.Sprite} spearman - The spearman to send.
      * @param {Phaser.GameObjects.Sprite | Phaser.GameObjects.Image} target - The target enemy.
      */
      sendSpearmanToAttack(spearman, target) {
        if (!spearman || !spearman.active || !target || !target.active || this.gameOver) {
            if(spearman && spearman.active) spearman.state = 'idle'; // Reset state if target invalid
            return;
        }

        const side = spearman.getData('isPlayer') ? 'Player' : 'AI';
        this.logDebug(`${side} spearman moving to attack ${target.getData('unitType') || 'target'}.`);

        // --- Stop any existing actions ---
        if (spearman.isAttacking) this.stopAttacking(spearman);
        if (spearman.moving) {
            this.tweens.killTweensOf(spearman);
            spearman.moving = false;
            // Reset visuals
            spearman.setTexture('spearman_walk_sheet');
            spearman.anims.stop();
            spearman.setFrame(0);
            // Don't stop walk sound yet, will be restarted if needed
        }
        spearman.attackTarget = null; // Clear old attack target before setting new move target
        // --- End Stop Actions ---

        spearman.target = target; // Set movement target
        spearman.moving = true;
        spearman.state = 'moving_to_attack';

        // Calculate target position slightly offset from the actual target center
        const angleToTarget = Phaser.Math.Angle.Between(spearman.x, spearman.y, target.x, target.y);
        // Target a point just outside the attack range initially
        const targetX = target.x - Math.cos(angleToTarget) * (SPEARMAN_ATTACK_RANGE - 5); // Move slightly closer than exact range
        const targetY = target.y - Math.sin(angleToTarget) * (SPEARMAN_ATTACK_RANGE - 5);


        const distance = Phaser.Math.Distance.Between(spearman.x, spearman.y, targetX, targetY);
        const speed = 80; // Spearman move speed
        const duration = (distance / speed) * 1000 || 1;

        spearman.anims.play('spearman_walk', true);
        if (targetX < spearman.x) spearman.setFlipX(true);
        else spearman.setFlipX(false);

        // Start walk sound if needed (checking other units)
        if (this.workerWalkSound && !this.workerWalkSound.isPlaying) {
             let playerWorkerMoving = this.worker && this.worker.active && this.worker.moving;
             let aiWorkerMoving = this.aiWorker && this.aiWorker.active && this.aiWorker.moving;
             // Check other spearmen moving (excluding self)
             let otherSpearmanMoving = this.playerSpearmen.some(s => s.active && s !== spearman && s.moving) || this.aiSpearmen.some(s => s.active && s !== spearman && s.moving);
             if (!playerWorkerMoving && !aiWorkerMoving && !otherSpearmanMoving) {
                  this.workerWalkSound.play({ loop: true });
             }
         }

        this.tweens.add({
            targets: spearman,
            x: targetX,
            y: targetY,
            duration: duration,
            ease: 'Linear',
            onComplete: () => {
                // Check if spearman & target still valid and state correct
                if (!spearman.active || spearman.state !== 'moving_to_attack' || !spearman.target || !spearman.target.active) {
                    if(spearman.active && spearman.state === 'moving_to_attack') {
                         this.logDebug(`${side} spearman reached attack location, but target invalid/state changed.`);
                         spearman.state = 'idle'; // Go idle
                         spearman.setTexture('spearman_walk_sheet');
                         spearman.anims.stop();
                         spearman.setFrame(0);
                         spearman.setFlipX(!spearman.getData('isPlayer')); // Reset facing
                    }
                    spearman.moving = false;
                    spearman.target = null;
                    // Stop walk sound if needed
                    if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                         let playerWorkerMoving = this.worker && this.worker.active && this.worker.moving;
                         let aiWorkerMoving = this.aiWorker && this.aiWorker.active && this.aiWorker.moving;
                         let otherSpearmanMoving = this.playerSpearmen.some(s => s.active && s.moving) || this.aiSpearmen.some(s => s.active && s.moving);
                         if (!playerWorkerMoving && !aiWorkerMoving && !otherSpearmanMoving) this.workerWalkSound.stop();
                    }
                    return;
                }

                spearman.moving = false;
                // Stop walk sound if needed (check other units)
                if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                     let playerWorkerMoving = this.worker && this.worker.active && this.worker.moving;
                     let aiWorkerMoving = this.aiWorker && this.aiWorker.active && this.aiWorker.moving;
                     let otherSpearmanMoving = this.playerSpearmen.some(s => s.active && s !== spearman && s.moving) || this.aiSpearmen.some(s => s.active && s !== spearman && s.moving);
                     if (!playerWorkerMoving && !aiWorkerMoving && !otherSpearmanMoving) this.workerWalkSound.stop();
                 }

                // Re-check distance, start attacking if close enough
                const finalTarget = spearman.target; // Get target again
                spearman.target = null; // Clear movement target
                const finalDistance = Phaser.Math.Distance.Between(spearman.x, spearman.y, finalTarget.x, finalTarget.y);

                if (finalDistance <= SPEARMAN_ATTACK_RANGE) {
                    this.startAttacking(spearman, finalTarget);
                } else {
                    // Target moved away or calculation was off, go back to idle to re-evaluate
                    this.logDebug(`${side} spearman arrived but target out of range (${finalDistance.toFixed(0)} > ${SPEARMAN_ATTACK_RANGE}). Re-evaluating.`);
                    spearman.state = 'idle';
                    spearman.setTexture('spearman_walk_sheet');
                    spearman.anims.stop();
                    spearman.setFrame(0);
                    spearman.setFlipX(!spearman.getData('isPlayer')); // Reset facing
                }
            },
            onStop: () => { // If move is interrupted
                if (!spearman.active) return;
                const wasMoving = spearman.moving;
                spearman.moving = false;
                spearman.target = null; // Clear movement target

                if (spearman.state === 'moving_to_attack') {
                     spearman.state = 'idle'; // Go idle if move interrupted
                     this.logDebug(`${side} spearman move to attack interrupted.`);
                }

                // Reset visuals if it was moving
                if(wasMoving) {
                    spearman.setTexture('spearman_walk_sheet');
                    spearman.anims.stop();
                    spearman.setFrame(0);
                    spearman.setFlipX(!spearman.getData('isPlayer')); // Reset facing
                }

                // Stop walk sound if needed (check other units)
                if (this.workerWalkSound && this.workerWalkSound.isPlaying && wasMoving) {
                     let playerWorkerMoving = this.worker && this.worker.active && this.worker.moving;
                     let aiWorkerMoving = this.aiWorker && this.aiWorker.active && this.aiWorker.moving;
                     let otherSpearmanMoving = this.playerSpearmen.some(s => s.active && s.moving) || this.aiSpearmen.some(s => s.active && s.moving);
                     if (!playerWorkerMoving && !aiWorkerMoving && !otherSpearmanMoving) this.workerWalkSound.stop();
                 }
            }
        });
      }

     /**
       * Starts the attack sequence for a spearman.
       * @param {Phaser.GameObjects.Sprite} spearman - The attacking spearman.
       * @param {Phaser.GameObjects.Sprite | Phaser.GameObjects.Image} target - The target being attacked.
       */
      startAttacking(spearman, target) {
        if (!spearman || !spearman.active || !target || !target.active || spearman.isAttacking || this.gameOver) {
            return;
        }

        const side = spearman.getData('isPlayer') ? 'Player' : 'AI';
        this.logDebug(`${side} spearman starting attack on ${target.getData('unitType') || 'target'}.`);

        spearman.state = 'attacking';
        spearman.isAttacking = true;
        spearman.attackTarget = target; // Set the actual attack target

        // Face the target
        if (target.x < spearman.x) spearman.setFlipX(true);
        else spearman.setFlipX(false);

        // Play attack animation
        spearman.setTexture('spearman_attack_sheet');
        spearman.anims.play('spearman_attack', true);

        // Start attack sound
        if (this.spearmanAttackSound && !this.spearmanAttackSound.isPlaying) {
             this.spearmanAttackSound.play({ loop: true });
        }

        // Start attack timer
        spearman.attackTimer = this.time.addEvent({
            delay: SPEARMAN_ATTACK_DELAY,
            callback: () => this.damageTarget(spearman), // Pass spearman to damage function
            callbackScope: this,
            loop: true
        });
      }

    /**
     * Stops the attack sequence for a spearman.
     * @param {Phaser.GameObjects.Sprite} spearman - The spearman to stop attacking.
     */
    stopAttacking(spearman) {
        if (!spearman || !spearman.isAttacking) return;

        const side = spearman.getData('isPlayer') ? 'Player' : 'AI';
        // this.logDebug(`${side} spearman stopping attack.`); // Can be spammy

        // Clear timer
        if (spearman.attackTimer) {
            spearman.attackTimer.remove(false);
            spearman.attackTimer = null;
        }

        spearman.isAttacking = false;
        spearman.attackTarget = null; // Clear target

        // Stop attack sound
        if (this.spearmanAttackSound && this.spearmanAttackSound.isPlaying) {
             this.spearmanAttackSound.stop();
        }

        // Reset visuals (only if still active)
        if (spearman.active) {
            spearman.setTexture('spearman_walk_sheet');
            spearman.anims.stop('spearman_attack');
            spearman.setFrame(0);
            spearman.setFlipX(!spearman.getData('isPlayer')); // Reset facing
        }
        // Don't reset state here, let handleSpearmanState decide next action (usually 'idle')
    }

    /**
     * Applies damage to the spearman's current target. Called by attack timer.
     * @param {Phaser.GameObjects.Sprite} spearman - The attacking spearman.
     */
    damageTarget(spearman) {
        if (this.gameOver || !spearman || !spearman.active || !spearman.isAttacking || !spearman.attackTarget || !spearman.attackTarget.active) {
            // If spearman is still marked as attacking but target is invalid, stop attacking
            if (spearman && spearman.active && spearman.isAttacking) {
                 this.stopAttacking(spearman);
                 spearman.state = 'idle'; // Look for new target
            }
            return;
        }

        const target = spearman.attackTarget;
        const side = spearman.getData('isPlayer') ? 'Player' : 'AI';

        // Check range before applying damage
        const distance = Phaser.Math.Distance.Between(spearman.x, spearman.y, target.x, target.y);
        if (distance > SPEARMAN_ATTACK_RANGE) {
            this.logDebug(`${side} spearman target moved out of range. Stopping attack.`);
            this.stopAttacking(spearman);
            spearman.state = 'idle'; // Re-evaluate target
            return;
        }

        // Apply damage using the target's takeDamage method
        // this.logDebug(`${side} spearman attacking ${target.getData('unitType')} (H:${target.health})`); // Spammy
        target.takeDamage(SPEARMAN_DPS, spearman); // Pass attacker

        // takeDamage handles target destruction and stopping the attacker
    }

    /**
     * Handles a spearman's state machine logic (Idle, MovingToAttack, Attacking).
     * @param {Phaser.GameObjects.Sprite} spearman - The spearman whose state to handle.
     */
    handleSpearmanState(spearman) {
        if (!this.gameStarted || this.gameOver || !spearman || !spearman.active) return;

        const side = spearman.getData('isPlayer') ? 'Player' : 'AI';

        // Only act if idle (not moving or attacking)
        if (spearman.state === 'idle' && !spearman.moving && !spearman.isAttacking) {
            // Find closest enemy target
            const target = this.findClosestEnemyTarget(spearman);

            if (target) {
                // Check if target is already in range
                const distance = Phaser.Math.Distance.Between(spearman.x, spearman.y, target.x, target.y);
                if (distance <= SPEARMAN_ATTACK_RANGE) {
                    this.startAttacking(spearman, target);
                } else {
                    // Target found but out of range, move towards it
                    this.sendSpearmanToAttack(spearman, target);
                }
            } else {
                // No targets found, remain idle (or could add patrol logic here)
                // Ensure visuals are idle
                 spearman.setTexture('spearman_walk_sheet');
                 spearman.anims.stop();
                 spearman.setFrame(0);
                 spearman.setFlipX(!spearman.getData('isPlayer')); // Reset facing
            }
        }
        // If spearman is moving_to_attack or attacking, the relevant callbacks/timers handle state changes
        // Exception: If attacking and target becomes invalid, damageTarget handles stopping the attack and setting state to idle.
        else if (spearman.state === 'attacking' && (!spearman.attackTarget || !spearman.attackTarget.active)) {
             this.logDebug(`${side} spearman's target disappeared while attacking. Stopping.`);
             this.stopAttacking(spearman);
             spearman.state = 'idle'; // Look for new target immediately
        }
         // Safety check: If stuck in moving state without a target
         else if (spearman.state === 'moving_to_attack' && !spearman.moving) {
              this.logDebug(`${side} spearman stuck in moving_to_attack without moving flag. Resetting to idle.`);
              spearman.state = 'idle';
              spearman.target = null; // Clear target just in case
              spearman.setTexture('spearman_walk_sheet');
              spearman.anims.stop();
              spearman.setFrame(0);
              spearman.setFlipX(!spearman.getData('isPlayer')); // Reset facing
         }
    }

    // --- END NEW COMBAT FUNCTIONS ---


    /**
     * Game loop update function. Runs continuously.
     */
    update(time, delta) {
        if (!this.gameStarted || this.gameOver) return; // Stop updates if game hasn't started or is over

        // --- Handle Worker States ---
        if (this.worker && this.worker.active) {
             this.handleWorkerState(this.worker);
        }
        if (this.aiWorker && this.aiWorker.active) {
             this.handleWorkerState(this.aiWorker);
        }

        // --- Handle Barrack Training ---
        this.handleBarrackTraining(this.playerBarrack, true);
        this.handleBarrackTraining(this.aiBarrack, false);

        // --- Handle Spearman States --- <<< NEW
        this.playerSpearmen.forEach(s => { if (s.active) this.handleSpearmanState(s); });
        this.aiSpearmen.forEach(s => { if (s.active) this.handleSpearmanState(s); });


        // --- Unit Cleanup (Remove inactive units from arrays) --- <<< MODIFIED
        this.playerSpearmen = this.playerSpearmen.filter(s => s.active);
        this.aiSpearmen = this.aiSpearmen.filter(s => s.active);
        // Workers, Houses, Barracks are single instances, their destruction is handled
        // by setting active=false in takeDamage. We check their active status elsewhere.


        // --- Depth Sorting & Visual Updates ---
        const depthSortedSprites = [];
        // Add active units, buildings, and trees to the sorting array
        if (this.worker && this.worker.active) depthSortedSprites.push(this.worker);
        if (this.aiWorker && this.aiWorker.active) depthSortedSprites.push(this.aiWorker);
        if (this.house && this.house.active) depthSortedSprites.push(this.house);
        if (this.aiHouse && this.aiHouse.active) depthSortedSprites.push(this.aiHouse);
        if (this.playerBarrack && this.playerBarrack.active) depthSortedSprites.push(this.playerBarrack);
        if (this.aiBarrack && this.aiBarrack.active) depthSortedSprites.push(this.aiBarrack);
        this.playerSpearmen.forEach(s => { if (s.active) depthSortedSprites.push(s); });
        this.aiSpearmen.forEach(s => { if (s.active) depthSortedSprites.push(s); });


        if (this.trees) {
            this.trees.getChildren().forEach(tree => {
                if (tree.active) {
                    depthSortedSprites.push(tree);
                    // Update active tree health bar position continuously
                    if(tree.healthBarBg) {
                         this.updateTreeHealthBar(tree);
                    }
                } else {
                    // Ensure health bar is destroyed if tree becomes inactive unexpectedly
                    this.destroyTreeHealthBar(tree);
                }
            });
        }

        // Sort based on Y position (lower Y means further back, lower depth)
        depthSortedSprites.sort((a, b) => {
            const yA = a.y;
            const yB = b.y;
            if (yA < yB) return -1;
            if (yA > yB) return 1;
            return 0; // Keep original order if Y is the same
        });

        // Apply the calculated depth and update associated graphics
        depthSortedSprites.forEach((sprite, index) => {
             if (sprite.active) { // Double check active before setting depth
                 sprite.setDepth(index);
                 // Update Health Bar position and depth
                 if (sprite.healthBarBg) {
                     this.updateHealthBar(sprite); // Update position first
                     sprite.healthBarBg.setDepth(index + 1);
                     sprite.healthBarFill.setDepth(index + 2);
                 }
                 // Update Training Text position and depth (if applicable)
                 if (sprite.trainingText) {
                      this.updateTrainingText(sprite); // Update position first
                      sprite.trainingText.setDepth(index + 10); // Ensure it's on top
                 }
             }
        });


        // --- Target / Cutting / Building Checks (Handle cases where target becomes invalid) ---
        // This logic is now partially handled within the state machines and takeDamage
        // Keep checks for workers moving to invalid targets
        [this.worker, this.aiWorker].forEach( w => {
            if (!w || !w.active) return; // Skip inactive workers

            // Check 1: Worker is MOVING TO CHOP, but its target tree becomes inactive/destroyed
            if (w.moving && w.target && w.state === 'moving_to_chop' && !w.target.active) {
                const workerType = w.getData('isPlayer') ? "Player" : "AI";
                this.logDebug(`${workerType} target tree disappeared during move.`);
                this.tweens.killTweensOf(w); // Stop the movement tween (will trigger onStop)
            }
             // Check 1b: Worker is MOVING TO BUILD, but the building target becomes inactive/destroyed
             if (w.moving && w.target && w.state === 'moving_to_build' && !w.target.active) {
                 const workerType = w.getData('isPlayer') ? "Player" : "AI";
                 this.logDebug(`${workerType} build target disappeared during move.`);
                 this.tweens.killTweensOf(w); // Stop the movement tween (will trigger onStop)
             }
        });

    } // End update()
  } // End DemoScene Class

  /**
   * Phaser game configuration object.
   */
  const config = {
    type: Phaser.AUTO, // Automatically choose WebGL or Canvas
    width: 800,
    height: 600,
    parent: 'phaser-game-container', // Optional: Specify a div ID to contain the canvas
    physics: {
        default: 'arcade', // Using Arcade Physics for simplicity (though not heavily used here)
        arcade: {
            debug: false // Set to true to see physics bodies if needed
        }
    },
    scene: [DemoScene], // The scene(s) to load
    scale: {
        mode: Phaser.Scale.FIT, // Fit the game within the available space
        autoCenter: Phaser.Scale.CENTER_BOTH // Center the game canvas
    },
    render: {
        pixelArt: true // Optional: Use if assets are pixel art for sharper scaling
    }
  };

  // Create a new Phaser game instance when the window loads
  window.onload = () => {
     // Add data types to prototypes for easier health bar handling (already done in create)
     // Phaser.GameObjects.Image.prototype.unitType = '';
     // Phaser.GameObjects.Sprite.prototype.unitType = '';

     const game = new Phaser.Game(config);

     // Assign types after scene creation (or within create method)
     // This is now handled within the create() method using setData('unitType', ...)
     /*
     game.scene.scenes[0].events.on('create', () => {
         const scene = game.scene.scenes[0];
         // ... setData calls are now in create() ...
     });
     */

  };

</script>
</body>
</html>
