<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Simple RTS Demo with Fog of War</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <style>
    /* Basic styling for the body and canvas */
    body { margin: 0; background-color: #333; display: flex; justify-content: center; align-items: center; min-height: 100vh; position: relative; } /* Added position relative */
    canvas { display: block; margin: 20px auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
    /* Style for the start overlay */
    #start-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        font-size: 24px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        z-index: 10000; /* Ensure it's on top */
        font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
<div id="start-overlay">Click or Tap to Start</div>

<script>
  // Global Constants
  const BARRACK_WOOD_COST = 50;
  const SPEARMAN_WOOD_COST = 5; // Cost to train a spearman
  const SPEARMAN_TRAIN_TIME = 10000; // 10 seconds training time
  const SPEARMAN_LIMIT = 3; // Max number of spearmen per side
  const SPEARMAN_HEALTH = 15; // Health for spearmen
  const SPEARMAN_DPS = 1; // Damage per second
  const SPEARMAN_ATTACK_DELAY = 1000; // Milliseconds between attacks (1 attack per second)
  const SPEARMAN_ATTACK_RANGE = 45; // Range within which spearman can attack
  const WORKER_HEALTH = 10;
  const HOUSE_HEALTH = 50;
  const BARRACK_HEALTH = 50;
  const PLAYER_HEALTH_BAR_COLOR = 0x00ff00; // Green for player units/buildings
  const AI_HEALTH_BAR_COLOR = 0xff0000; // Red for AI units/buildings
  const BUILDING_HEALTH_BAR_WIDTH = 32; // Width for building health bars
  const UNIT_HEALTH_BAR_WIDTH = 28; // Width for unit health bars
  const SPEARMAN_HEALTH_BAR_WIDTH = 40; // Width for spearman health bar
  const UNIT_COLLISION_RADIUS = 20; // Radius for checking unit overlap
  const HEALTH_BAR_HEIGHT = 8; // Main health bar height
  const TRAINING_TEXT_STYLE = { font: '14px Arial', fill: '#000000', backgroundColor: '#ffffff', padding: { x: 5, y: 2 }, borderRadius: 4 }; // Style for training text bubble
  const FOG_CELL_SIZE = 64; // Size of fog of war grid cells
  const FOG_COLOR = 0x000000; // Black fog
  const FOG_ALPHA = 0.75; // Semi-transparent fog


  /**
   * Represents the main scene for the RTS demo.
   * Handles game logic, asset loading, and rendering.
   */
  class DemoScene extends Phaser.Scene {
    constructor() {
      super({ key: 'DemoScene' });
      // Game state variables
      this.wood = 0; // Player's wood count
      this.aiWood = 0; // AI's wood count
      this.worker = null; // The player-controlled worker sprite
      this.house = null; // The player house sprite
      this.aiHouse = null; // AI house sprite
      this.aiWorker = null; // AI worker sprite
      this.trees = null; // Group containing tree sprites
      this.playerBarrack = null; // Reference to the player's barrack building
      this.playerBarrackBuilding = false; // Flag: Is the player barrack currently under construction?
      this.aiBarrack = null; // Reference to the AI's barrack building
      this.aiBarrackBuilding = false; // Flag: Is the AI barrack currently under construction?
      this.playerSpearmen = []; // Array for player spearmen
      this.aiSpearmen = []; // Array for AI spearmen
      this.woodText = null; // Text object to display player wood count
      this.aiWoodText = null; // Text object to display AI wood count
      this.debugText = null; // Text object for displaying debug messages
      this.workerWalkSound = null; // Sound effect for worker walking
      this.chopSound = null; // Sound effect for chopping / building
      this.spearmanAttackSound = null; // Sound effect for spearman attacking
      this.unitDieSound = null; // Sound effect for unit death
      this.buildingFallSound = null; // Sound effect for building destruction
      this.gameStarted = false; // Flag to prevent logic running before start
      this.gameOver = false; // Flag to prevent multiple end game calls
      this.selectedWorker = null; // Keep track of the selected worker
      this.objectClickedRecently = false; // Flag to prevent immediate background click after object click
      this.debugHistory = []; // Array to store debug message history
      this.maxDebugHistory = 10; // Max number of debug messages to keep

      // Fog of War properties
      this.fogGrid = null; // 2D array holding visibility state (true=revealed, false=hidden)
      this.gridWidth = 0; // Number of cells horizontally
      this.gridHeight = 0; // Number of cells vertically
      this.fogRects = null; // 2D array storing references to the fog rectangle graphics
    }

    /**
     * Logs a message to the on-screen debug area, maintaining a history.
     * @param {string} message The message to log.
     */
    logDebug(message) {
        if (!message) return; // Ignore empty messages
        const time = new Date();
        const timestamp = `${time.getHours()}:${String(time.getMinutes()).padStart(2, '0')}:${String(time.getSeconds()).padStart(2, '0')}`;
        this.debugHistory.push(`[${timestamp}] ${message}`);
        if (this.debugHistory.length > this.maxDebugHistory) {
            this.debugHistory.shift();
        }
        if (this.debugText && this.debugText.visible) {
            this.debugText.setText('Debug Output:\n' + this.debugHistory.join('\n'));
        }
        console.log("DEBUG:", message);
    }


    /**
     * Preloads game assets (images, spritesheets, audio).
     */
    preload() {
      // Load assets (unchanged from previous version)
      this.load.spritesheet('worker_sheet', 'https://grantchen08.github.io/nezha/worker_walk.png', { frameWidth: 32, frameHeight: 64 });
      this.load.spritesheet('worker_chop_sheet', 'https://grantchen08.github.io/nezha/worker_chop.png', { frameWidth: 64, frameHeight: 64 });
      this.load.image('barrack', 'https://grantchen08.github.io/nezha/barrack.png');
      this.load.spritesheet('spearman_walk_sheet', 'https://grantchen08.github.io/nezha/spearman_walk.png', { frameWidth: 64, frameHeight: 64 });
      this.load.spritesheet('spearman_attack_sheet', 'https://grantchen08.github.io/nezha/spearman_attack.png', { frameWidth: 64, frameHeight: 64 });
      this.load.audio('worker_walk', 'https://grantchen08.github.io/nezha/worker_walk.mp3');
      this.load.spritesheet('tree_sheet', 'https://grantchen08.github.io/nezha/tree.png', { frameWidth: 64, frameHeight: 64 });
      this.load.image('house', 'https://grantchen08.github.io/nezha/house.png');
      this.load.audio('chop_sound', 'https://grantchen08.github.io/nezha/chop_tree.mp3');
      this.load.audio('spearman_attack_sound', 'https://grantchen08.github.io/nezha/attack.mp3');
      this.load.audio('unit_die_sound', 'https://grantchen08.github.io/nezha/hurt.mp3');
      this.load.audio('building_fall_sound', 'https://grantchen08.github.io/nezha/fall.mp3');

      this.load.on('loaderror', (file) => {
          const errorMsg = `Error loading ${file.key}`;
          console.error(`Error loading asset: ${file.key} from ${file.url}`);
          this.logDebug(errorMsg);
      });
    }

    /**
     * Creates game objects and initializes the scene.
     */
    create() {
      const gameWidth = this.sys.game.config.width;
      const gameHeight = this.sys.game.config.height;

      this.cameras.main.setBackgroundColor('#228B22'); // Forest green

      // UI Text (Wood, AI Wood, Debug) - Unchanged
      this.wood = 0; this.aiWood = 0;
      this.woodText = this.add.text(10, 10, 'Wood: 0', { font: '16px Arial', fill: '#ffffff' }).setDepth(1000);
      this.aiWoodText = this.add.text(gameWidth - 10, 10, 'AI Wood: 0', { font: '16px Arial', fill: '#ffffff' }).setOrigin(1, 0).setDepth(1000);
      this.debugText = this.add.text(10, 40, 'Debug Output:', { font: '14px Arial', fill: '#ffffff', wordWrap: { width: 200 }, lineSpacing: 4 }).setDepth(1000).setVisible(false);
      this.logDebug("Click overlay to start.");

      // --- Initialize Fog of War ---
      this.gridWidth = Math.ceil(gameWidth / FOG_CELL_SIZE);
      this.gridHeight = Math.ceil(gameHeight / FOG_CELL_SIZE);
      this.fogGrid = [];
      this.fogRects = []; // Store references to the graphics objects

      for (let y = 0; y < this.gridHeight; y++) {
          this.fogGrid[y] = [];
          this.fogRects[y] = [];
          for (let x = 0; x < this.gridWidth; x++) {
              this.fogGrid[y][x] = false; // Initially hidden
              // Create individual rectangle for each fog cell
              const fogRect = this.add.rectangle(
                  x * FOG_CELL_SIZE,
                  y * FOG_CELL_SIZE,
                  FOG_CELL_SIZE,
                  FOG_CELL_SIZE,
                  FOG_COLOR,
                  FOG_ALPHA
              ).setOrigin(0, 0).setDepth(5000); // Add rect directly to scene, depth managed here
              this.fogRects[y][x] = fogRect; // Store reference
          }
      }
      this.logDebug(`Fog grid initialized (${this.gridWidth}x${this.gridHeight})`);
      // --- End Fog of War Init ---


      // --- Add takeDamage method to prototypes --- (Unchanged)
      const takeDamage = function(amount, attacker) { /* ... same as before ... */
            if (!this.active || this.health <= 0) return; // Already dead or inactive
            this.health -= amount;
            this.scene.updateHealthBar(this); // Update visual
            if (this.health <= 0) {
                this.health = 0;
                this.scene.logDebug(`${this.getData('unitType') || 'Object'} destroyed!`);
                const unitType = this.getData('unitType');
                if (unitType === 'house' || unitType === 'barrack') {
                    if (this.scene.buildingFallSound) this.scene.buildingFallSound.play();
                } else {
                    if (this.scene.unitDieSound) this.scene.unitDieSound.play();
                }
                if (attacker && attacker.attackTarget === this) {
                    this.scene.stopAttacking(attacker);
                    attacker.state = 'idle';
                }
                this.active = false;
                this.setVisible(false);
                this.scene.destroyHealthBar(this);
                this.disableInteractive();
                if (this.getData('unitType') === 'barrack') {
                    if (this.trainingTimer) this.trainingTimer.remove();
                    this.scene.destroyTrainingText(this);
                    this.isTraining = false;
                }
                 if (this.getData('unitType') === 'worker') {
                     if (this.isCutting) this.scene.stopCutting(this);
                     if (this.isBuilding) this.scene.stopBuilding(this);
                     if (this.moving) this.scene.tweens.killTweensOf(this);
                 }
                 if (this.getData('unitType') === 'spearman') {
                     if (this.isAttacking) this.scene.stopAttacking(this);
                     if (this.moving) this.scene.tweens.killTweensOf(this);
                 }
                this.scene.checkEndCondition();
            }
      };
      Phaser.GameObjects.Sprite.prototype.takeDamage = takeDamage;
      Phaser.GameObjects.Image.prototype.takeDamage = takeDamage;


      // --- Player & AI House Setup --- (Unchanged, except for initial FoW reveal)
      this.house = this.add.image(100, gameHeight - 100, 'house').setOrigin(0.5, 1);
      this.house.health = HOUSE_HEALTH; this.house.maxHealth = HOUSE_HEALTH;
      this.house.setData('unitType', 'house'); this.house.setData('isPlayer', true);
      this.createHealthBar(this.house, BUILDING_HEALTH_BAR_WIDTH, PLAYER_HEALTH_BAR_COLOR);
      this.updateVisibilityAround(this.house); // Reveal initial FoW

      this.aiHouse = this.add.image(gameWidth - 100, gameHeight - 100, 'house').setOrigin(0.5, 1);
      this.aiHouse.health = HOUSE_HEALTH; this.aiHouse.maxHealth = HOUSE_HEALTH;
      this.aiHouse.setData('unitType', 'house'); this.aiHouse.setData('isPlayer', false);
      this.createHealthBar(this.aiHouse, BUILDING_HEALTH_BAR_WIDTH, AI_HEALTH_BAR_COLOR);
      this.updateVisibilityAround(this.aiHouse); // Reveal initial FoW

      // --- Player & AI Worker Setup --- (Unchanged, except for initial FoW reveal)
      this.worker = this.add.sprite(150, gameHeight - 150, 'worker_sheet').setOrigin(0.5, 1);
      this.worker.setFrame(0); this.worker.state = 'idle'; this.worker.moving = false; this.worker.target = null;
      this.worker.isCutting = false; this.worker.cuttingTarget = null; this.worker.cuttingTimer = null;
      this.worker.isBuilding = false; this.worker.buildingTarget = null; this.worker.buildingTimer = null;
      this.worker.health = WORKER_HEALTH; this.worker.maxHealth = WORKER_HEALTH;
      this.worker.setData('unitType', 'worker'); this.worker.setData('isPlayer', true); this.worker.initialChopHealth = null;
      this.createHealthBar(this.worker, UNIT_HEALTH_BAR_WIDTH, PLAYER_HEALTH_BAR_COLOR);
      this.worker.setInteractive();
      this.updateVisibilityAround(this.worker); // Reveal initial FoW

      this.aiWorker = this.add.sprite(gameWidth - 150, gameHeight - 150, 'worker_sheet').setOrigin(0.5, 1);
      this.aiWorker.setFrame(0); this.aiWorker.state = 'idle'; this.aiWorker.moving = false; this.aiWorker.target = null;
      this.aiWorker.isCutting = false; this.aiWorker.cuttingTarget = null; this.aiWorker.cuttingTimer = null;
      this.aiWorker.isBuilding = false; this.aiWorker.buildingTarget = null; this.aiWorker.buildingTimer = null;
      this.aiWorker.health = WORKER_HEALTH; this.aiWorker.maxHealth = WORKER_HEALTH;
      this.aiWorker.setData('unitType', 'worker'); this.aiWorker.setData('isPlayer', false); this.aiWorker.initialChopHealth = null;
      this.createHealthBar(this.aiWorker, UNIT_HEALTH_BAR_WIDTH, AI_HEALTH_BAR_COLOR);
      this.updateVisibilityAround(this.aiWorker); // Reveal initial FoW


      // Load sounds (Unchanged)
      this.workerWalkSound = this.sound.add('worker_walk');
      this.chopSound = this.sound.add('chop_sound');
      this.spearmanAttackSound = this.sound.add('spearman_attack_sound');
      this.unitDieSound = this.sound.add('unit_die_sound');
      this.buildingFallSound = this.sound.add('building_fall_sound');

      // Create animations (Unchanged)
      this.anims.create({ key: 'worker_walk', frames: this.anims.generateFrameNumbers('worker_sheet', { start: 0, end: 1 }), frameRate: 8, repeat: -1 });
      this.anims.create({ key: 'worker_chop', frames: this.anims.generateFrameNumbers('worker_chop_sheet', { start: 0, end: 1 }), frameRate: 4, repeat: -1 });
      this.anims.create({ key: 'spearman_walk', frames: this.anims.generateFrameNumbers('spearman_walk_sheet', { start: 0, end: 1 }), frameRate: 6, repeat: -1 });
      this.anims.create({ key: 'spearman_attack', frames: this.anims.generateFrameNumbers('spearman_attack_sheet', { start: 0, end: 1 }), frameRate: 4, repeat: -1 });

      // --- Tree Setup --- (Unchanged)
      this.trees = this.add.group();
      const treeCount = 20;
      for (let i = 0; i < treeCount; i++) {
        let x, y; let tooClose;
        do {
            x = Phaser.Math.Between(50, gameWidth - 50); y = Phaser.Math.Between(50, gameHeight - 100);
            const playerHouseDist = Phaser.Math.Distance.Between(x, y, this.house.x, this.house.y - this.house.height / 2);
            const aiHouseDist = Phaser.Math.Distance.Between(x, y, this.aiHouse.x, this.aiHouse.y - this.aiHouse.height / 2);
            const houseRadius = Math.max(this.house.width, this.house.height) / 2 + 36;
            tooClose = (playerHouseDist < houseRadius * 1.5) || (aiHouseDist < houseRadius * 1.5);
        } while (tooClose);
        let tree = this.add.sprite(x, y, 'tree_sheet').setOrigin(0.5, 1);
        tree.setFrame(0); tree.health = 10; tree.maxHealth = 10;
        this.trees.add(tree); tree.setInteractive();
      }

       // --- Input Handling --- (Unchanged)
       this.input.on('gameobjectdown', this.handleObjectClick, this);
       this.input.on('pointerdown', this.handleBackgroundClick, this);
       this.input.keyboard.on('keydown-D', this.toggleDebugDisplay, this);
       this.input.keyboard.on('keydown-S', (event) => {
           if (event.shiftKey) { this.changeTimeScale(0.5); } else { this.changeTimeScale(2); }
       });


       // --- Start Overlay Logic --- (Unchanged)
       const overlay = document.getElementById('start-overlay');
       if (overlay) {
            overlay.addEventListener('pointerdown', () => {
                if (!this.gameStarted && !this.gameOver) {
                    overlay.style.display = 'none';
                    if (this.sound.context.state === 'suspended') {
                        this.sound.context.resume().then(() => { console.log('Audio Context resumed!'); this.startGameLogic(); }).catch(e => console.error('Error resuming audio context:', e));
                    } else { this.startGameLogic(); }
                }
            }, { once: true });
       } else {
           console.warn("Start overlay not found!"); this.startGameLogic();
       }
    }

    // --- FOG OF WAR HELPER FUNCTIONS ---

    /**
     * Converts world coordinates (like sprite x/y) to fog grid coordinates.
     * @param {number} worldX - The world x-coordinate.
     * @param {number} worldY - The world y-coordinate.
     * @returns {{gridX: number, gridY: number}} The corresponding grid cell indices.
     */
    worldToGrid(worldX, worldY) {
        const gridX = Math.floor(worldX / FOG_CELL_SIZE);
        const gridY = Math.floor(worldY / FOG_CELL_SIZE);
        return { gridX, gridY };
    }

    /**
     * Checks if a specific fog grid cell is revealed.
     * @param {number} gridX - The grid x-index.
     * @param {number} gridY - The grid y-index.
     * @returns {boolean} True if the cell is revealed, false otherwise.
     */
    isCellRevealed(gridX, gridY) {
        // Check bounds
        if (gridY >= 0 && gridY < this.gridHeight && gridX >= 0 && gridX < this.gridWidth) {
            return this.fogGrid[gridY][gridX];
        }
        return false; // Out of bounds is not revealed
    }

    /**
     * Reveals a specific fog grid cell.
     * @param {number} gridX - The grid x-index.
     * @param {number} gridY - The grid y-index.
     */
    revealCell(gridX, gridY) {
        // Check bounds
        if (gridY >= 0 && gridY < this.gridHeight && gridX >= 0 && gridX < this.gridWidth) {
            // If already revealed, do nothing
            if (this.fogGrid[gridY][gridX]) return;

            this.fogGrid[gridY][gridX] = true; // Mark as revealed in the data grid

            // Make the corresponding fog rectangle invisible
            if (this.fogRects[gridY][gridX]) {
                this.fogRects[gridY][gridX].setVisible(false);
                // Optional: Destroy the rectangle for performance if it won't be hidden again
                // this.fogRects[gridY][gridX].destroy();
                // this.fogRects[gridY][gridX] = null;
            }
        }
    }

    /**
     * Updates fog visibility around a given game object based on its bounds.
     * Reveals all cells the object's bounding box overlaps.
     * @param {Phaser.GameObjects.Sprite | Phaser.GameObjects.Image} gameObject - The object providing visibility.
     */
    updateVisibilityAround(gameObject) {
        if (!gameObject || !gameObject.active) return;

        let bounds;

        // Get bounds differently for Sprites vs Images
        if (typeof gameObject.getBounds === 'function') {
            // Likely a Sprite
            bounds = gameObject.getBounds();
        } else {
            // Likely an Image or object without getBounds - calculate manually
            const width = gameObject.displayWidth || gameObject.width;
            const height = gameObject.displayHeight || gameObject.height;
            // Use nullish coalescing for origin defaults
            const originXFactor = gameObject.originX ?? 0.5;
            const originYFactor = gameObject.originY ?? 0.5;
            const topLeftX = gameObject.x - width * originXFactor;
            const topLeftY = gameObject.y - height * originYFactor;
            const bottomRightX = topLeftX + width;
            const bottomRightY = topLeftY + height;
            bounds = new Phaser.Geom.Rectangle(topLeftX, topLeftY, width, height); // Use Phaser Rect for consistency
        }


        // Convert world bounds corners to grid coordinates
        const topLeftGrid = this.worldToGrid(bounds.x, bounds.y);
        // Use bounds.right and bounds.bottom which are calculated correctly by Phaser.Geom.Rectangle
        const bottomRightGrid = this.worldToGrid(bounds.right, bounds.bottom);

        // Iterate through all grid cells covered by the bounds
        for (let gx = topLeftGrid.gridX; gx <= bottomRightGrid.gridX; gx++) {
            for (let gy = topLeftGrid.gridY; gy <= bottomRightGrid.gridY; gy++) {
                this.revealCell(gx, gy);
            }
        }
    }


    /**
     * Finds the grid coordinates of the nearest hidden fog cell to a unit.
     * @param {Phaser.GameObjects.Sprite} unit - The unit searching for hidden cells.
     * @returns {{gridX: number, gridY: number} | null} Coordinates of the nearest hidden cell, or null if all are revealed.
     */
    findNearestHiddenCell(unit) {
        let nearestCell = null;
        let minDistanceSq = Infinity;

        for (let y = 0; y < this.gridHeight; y++) {
            for (let x = 0; x < this.gridWidth; x++) {
                if (!this.fogGrid[y][x]) { // If the cell is hidden
                    // Calculate world coordinates of the cell center
                    const cellCenterX = x * FOG_CELL_SIZE + FOG_CELL_SIZE / 2;
                    const cellCenterY = y * FOG_CELL_SIZE + FOG_CELL_SIZE / 2;

                    // Calculate squared distance from unit to cell center
                    const distanceSq = Phaser.Math.Distance.Squared(unit.x, unit.y, cellCenterX, cellCenterY);

                    if (distanceSq < minDistanceSq) {
                        minDistanceSq = distanceSq;
                        nearestCell = { gridX: x, gridY: y };
                    }
                }
            }
        }
        return nearestCell;
    }

    // --- END FOG OF WAR HELPERS ---


    /**
     * Checks if a given position is occupied by another unit. (Unchanged)
     */
    isPositionOccupied(x, y, excludingUnit = null) { /* ... same as before ... */
        const unitsToCheck = [this.worker, this.aiWorker, ...this.playerSpearmen, ...this.aiSpearmen];
        for (const unit of unitsToCheck) {
            if (unit && unit.active && unit !== excludingUnit) {
                const distance = Phaser.Math.Distance.Between(x, y, unit.x, unit.y);
                if (distance < UNIT_COLLISION_RADIUS) return true;
            }
        }
        return false;
    }

    /**
     * Finds a nearby empty position around a starting point. (Unchanged)
     */
    findNearbyEmptyPosition(startX, startY, maxRange = 50, excludingUnit = null) { /* ... same as before ... */
        for (let i = 0; i < 10; i++) {
            const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);
            const radius = Phaser.Math.FloatBetween(UNIT_COLLISION_RADIUS, maxRange);
            const checkX = startX + Math.cos(angle) * radius;
            const checkY = startY + Math.sin(angle) * radius;
            if (!this.isPositionOccupied(checkX, checkY, excludingUnit)) {
                return { x: checkX, y: checkY };
            }
        }
        this.logDebug("Could not find nearby empty spot, using original spawn point.");
        return { x: startX, y: startY };
    }


    /**
     * Changes the game's time scale. (Unchanged)
     */
    changeTimeScale(factor) { /* ... same as before ... */
        if (this.gameOver || !this.gameStarted || factor <= 0) return;
        this.time.timeScale *= factor;
        this.time.timeScale = Phaser.Math.Clamp(this.time.timeScale, 0.125, 8);
        this.logDebug(`Time scale set to ${this.time.timeScale.toFixed(3)}x`);
    }

    /**
     * Toggles the visibility of the debug text area. (Unchanged)
     */
    toggleDebugDisplay() { /* ... same as before ... */
        if (this.debugText) {
            this.debugText.visible = !this.debugText.visible;
            if (this.debugText.visible) {
                 this.logDebug(`Debug display toggled ON`);
                 this.debugText.setText('Debug Output:\n' + this.debugHistory.join('\n'));
            } else { console.log("DEBUG: Debug display toggled OFF"); }
        }
    }

    /**
     * Handles clicks on interactive game objects (worker, trees). (Unchanged)
     */
    handleObjectClick(pointer, gameObject) { /* ... same as before ... */
        if (this.gameOver || !this.gameStarted) return;
        this.objectClickedRecently = true;
        this.logDebug(`Clicked ${gameObject.texture?.key || 'unknown object'} (Type: ${gameObject.getData('unitType')})`);
        if (gameObject.getData('unitType') === 'worker' && gameObject.getData('isPlayer')) {
             if (this.selectedWorker === gameObject) {
                 this.logDebug('Worker deselected.'); this.selectedWorker.clearTint(); this.selectedWorker = null;
             } else {
                  if (this.selectedWorker) this.selectedWorker.clearTint();
                  this.logDebug('Worker selected.'); gameObject.setTint(0x00ffff); this.selectedWorker = gameObject;
             }
        } else if (this.selectedWorker) {
            if (gameObject.texture?.key === 'tree_sheet' && this.trees.contains(gameObject)) {
                const targetTree = gameObject;
                const isPlayerChoppingThis = this.worker.isCutting && this.worker.cuttingTarget === targetTree;
                const isAiChoppingThis = this.aiWorker.isCutting && this.aiWorker.cuttingTarget === targetTree;
                const isPlayerMovingToChopThis = this.worker.moving && this.worker.target === targetTree && this.worker.state === 'moving_to_chop';
                const isAiMovingToChopThis = this.aiWorker.moving && this.aiWorker.target === targetTree && this.aiWorker.state === 'moving_to_chop';
                if (isPlayerChoppingThis || isAiChoppingThis || isPlayerMovingToChopThis || isAiMovingToChopThis) {
                    this.logDebug('Invalid command: Tree is busy or targeted.');
                    targetTree.setTintFill(0xff0000);
                    this.time.delayedCall(250, () => { if (targetTree.active) targetTree.clearTint(); });
                } else {
                    const workerToCommand = this.selectedWorker;
                    this.logDebug('Commanding worker to chop selected tree.');
                    this.sendWorkerToTree(workerToCommand, targetTree);
                    workerToCommand.clearTint(); this.selectedWorker = null;
                }
            } else {
                 this.logDebug('Clicked other object. Deselecting worker.');
                 this.selectedWorker.clearTint(); this.selectedWorker = null;
            }
        } else {
             this.logDebug('Clicked object, but no worker selected or target is not player worker.');
        }
    }


    /**
     * Handles clicks on the background (not on an interactive object). (Unchanged)
     */
    handleBackgroundClick(pointer) { /* ... same as before ... */
        if (this.gameOver || !this.gameStarted) return;
        if (this.objectClickedRecently) { this.objectClickedRecently = false; this.logDebug('BG click ignored (object clicked).'); return; }
        this.logDebug('Pointer down detected.');
        if (!pointer.targetObject) {
             this.logDebug('Clicked background.');
            if (this.selectedWorker && this.selectedWorker === this.worker) {
                const workerToMove = this.selectedWorker;
                const targetX = pointer.worldX; const targetY = pointer.worldY;
                this.logDebug(`Move command issued to (${Math.round(targetX)}, ${Math.round(targetY)})`);
                const clickMarker = this.add.circle(targetX, targetY, 10, 0xff0000, 0.8).setDepth(3000);
                 this.tweens.add({ targets: clickMarker, alpha: 0, duration: 1000, ease: 'Power1', onComplete: () => { if(clickMarker.active) clickMarker.destroy(); } });
                 this.logDebug('Stopping current worker actions for move command.');
                if (workerToMove.isCutting) this.stopCutting(workerToMove);
                if (workerToMove.isBuilding) this.stopBuilding(workerToMove);
                if (workerToMove.moving) {
                    this.tweens.killTweensOf(workerToMove); workerToMove.moving = false; workerToMove.target = null;
                    workerToMove.setTexture('worker_sheet'); workerToMove.anims.stop('worker_walk'); workerToMove.setFrame(0); workerToMove.setFlipX(false);
                     if (this.workerWalkSound && this.workerWalkSound.isPlaying) { if (!this.aiWorker || !this.aiWorker.moving) this.workerWalkSound.stop(); }
                }
                workerToMove.cuttingTarget = null; workerToMove.buildingTarget = null; workerToMove.initialChopHealth = null;
                // Use startUnitMove for player commands too
                this.startUnitMove(workerToMove, targetX, targetY, 'moving_to_idle', 'idle');
                // Deselect the worker visually and logically AFTER issuing the command
                workerToMove.clearTint(); this.selectedWorker = null;
            } else {
                 this.logDebug('Clicked background (no player worker selected).');
                 if(this.selectedWorker) { this.selectedWorker.clearTint(); this.selectedWorker = null; this.logDebug('Worker deselected due to background click.'); }
            }
        }
    }


    /**
     * Starts the main game logic after user interaction. (Unchanged)
     */
    startGameLogic() { /* ... same as before ... */
        this.gameStarted = true; this.gameOver = false;
        if(this.worker) this.worker.state = 'idle'; if(this.aiWorker) this.aiWorker.state = 'idle';
        this.logDebug("Game started."); console.log("Game logic started.");
    }


    /**
     * Creates health bar graphics for a given unit. (Unchanged)
     */
     createHealthBar(unit, barWidth, barColor) { /* ... same as before ... */
        if (!unit) return;
        const unitHeight = unit.displayHeight || unit.height || 64;
        const initialYOffset = -unitHeight - 5;
        const x = unit.x; const y = unit.y + initialYOffset;
        if (unit.healthBarBg) unit.healthBarBg.destroy(); if (unit.healthBarFill) unit.healthBarFill.destroy();
        unit.healthBarBg = this.add.rectangle(x, y, barWidth, HEALTH_BAR_HEIGHT, 0x333333).setOrigin(0.5);
        unit.healthBarFill = this.add.rectangle(x - barWidth / 2, y, barWidth, HEALTH_BAR_HEIGHT, barColor).setOrigin(0, 0.5);
        unit.healthBarWidth = barWidth;
        if (unit.healthBarBg) unit.healthBarBg.setDepth(unit.depth + 1); if (unit.healthBarFill) unit.healthBarFill.setDepth(unit.depth + 2);
        this.updateHealthBar(unit);
      }

    /**
     * Creates a temporary health bar for the tree being cut. (Unchanged)
     */
    createTreeHealthBar(tree) { /* ... same as before ... */
        if (!tree || !tree.active || tree.healthBarBg) return;
        const barWidth = 40; const yOffset = -tree.displayHeight - 5;
        const x = tree.x; const y = tree.y + yOffset;
        tree.healthBarBg = this.add.rectangle(x, y, barWidth, HEALTH_BAR_HEIGHT, 0x333333).setOrigin(0.5);
        tree.healthBarFill = this.add.rectangle(x - barWidth / 2, y, barWidth, HEALTH_BAR_HEIGHT, 0xffffff).setOrigin(0, 0.5);
        tree.healthBarWidth = barWidth;
        if (tree.healthBarBg) tree.healthBarBg.setDepth(tree.depth + 1); if (tree.healthBarFill) tree.healthBarFill.setDepth(tree.depth + 2);
        this.updateTreeHealthBar(tree);
    }

     /**
       * Updates the position and fill of a specific tree's health bar. (Unchanged)
       */
      updateTreeHealthBar(tree) { /* ... same as before ... */
       if (!tree || !tree.active || !tree.healthBarBg || !tree.healthBarFill) { this.destroyTreeHealthBar(tree); return; }
       const barWidth = tree.healthBarWidth; const yOffset = -tree.displayHeight - 5;
       const x = tree.x; const y = tree.y + yOffset;
       tree.healthBarBg.setPosition(x, y); tree.healthBarFill.setPosition(x - barWidth / 2, y);
       const fillWidth = Math.max(0, (tree.health / tree.maxHealth) * barWidth);
       tree.healthBarFill.width = fillWidth;
       tree.healthBarBg.setDepth(tree.depth + 1); tree.healthBarFill.setDepth(tree.depth + 2);
      }

    /**
     * Destroys the health bar associated with a specific tree. (Unchanged)
     */
    destroyTreeHealthBar(tree) { /* ... same as before ... */
        if (tree) {
            if (tree.healthBarBg) { tree.healthBarBg.destroy(); tree.healthBarBg = null; }
            if (tree.healthBarFill) { tree.healthBarFill.destroy(); tree.healthBarFill = null; }
        }
    }


    /**
     * Damages the tree currently being cut by the specified worker. (Unchanged)
     */
     damageTree(workerSprite) { /* ... same as before ... */
        if (!this.gameStarted || this.gameOver || !workerSprite || !workerSprite.isCutting || !workerSprite.cuttingTarget || !workerSprite.cuttingTarget.active) { this.stopCutting(workerSprite); return; }
        const tree = workerSprite.cuttingTarget; tree.health -= 1;
        this.updateTreeHealthBar(tree);
        if (tree.health <= 0) { this.cutTree(tree, workerSprite); }
        else if (tree.health <= 3.3) { tree.setFrame(2); }
        else if (tree.health <= 6.6) { tree.setFrame(1); }
        else { tree.setFrame(0); }
      }

    /**
     * Stops the current cutting process for a specific worker. (Unchanged)
     */
     stopCutting(workerSprite) { /* ... same as before ... */
        if (!workerSprite) return;
        const treeToStopCutting = workerSprite.cuttingTarget; const initialHealth = workerSprite.initialChopHealth; let wasCutting = workerSprite.isCutting;
        if (workerSprite.cuttingTimer) { workerSprite.cuttingTimer.remove(false); workerSprite.cuttingTimer = null; }
        workerSprite.isCutting = false; workerSprite.cuttingTarget = null; workerSprite.initialChopHealth = null;
        if (this.chopSound && this.chopSound.isPlaying && wasCutting) {
            let otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
            let otherBusySound = otherWorker && otherWorker.active && (otherWorker.isCutting || otherWorker.isBuilding);
            if (!otherBusySound) this.chopSound.stop();
        }
        if(wasCutting) { workerSprite.setTexture('worker_sheet'); workerSprite.anims.stop('worker_chop'); workerSprite.setFrame(0); workerSprite.setFlipX(false); }
        if (wasCutting && treeToStopCutting && treeToStopCutting.active && initialHealth !== null) {
             if (treeToStopCutting.health > 0) {
                 const healthLost = initialHealth - treeToStopCutting.health; const woodGained = Math.max(0, Math.floor(healthLost));
                 if (woodGained > 0) {
                     if (workerSprite === this.worker) { this.wood += woodGained; this.woodText.setText('Wood: ' + this.wood); this.logDebug(`Stopped chopping. Gained ${woodGained} wood (partial).`); }
                     else if (workerSprite === this.aiWorker) { this.aiWood += woodGained; this.aiWoodText.setText('AI Wood: ' + this.aiWood); this.logDebug(`AI stopped chopping. Gained ${woodGained} wood (partial).`); }
                     this.checkEndCondition();
                 } else { this.logDebug(`Stopped chopping. No partial wood gained.`); }
                 this.updateTreeHealthBar(treeToStopCutting);
             }
             let otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
             if (!otherWorker || !otherWorker.active || !otherWorker.isCutting || otherWorker.cuttingTarget !== treeToStopCutting) this.destroyTreeHealthBar(treeToStopCutting);
        } else if (treeToStopCutting) {
             let otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
             if (!otherWorker || !otherWorker.active || !otherWorker.isCutting || otherWorker.cuttingTarget !== treeToStopCutting) this.destroyTreeHealthBar(treeToStopCutting);
        }
      }


    /**
     * Finalizes cutting the tree, adds wood, removes tree, checks end condition. (Unchanged)
     */
    cutTree(tree, workerSprite) { /* ... same as before ... */
      this.stopCutting(workerSprite);
      if (!tree || !workerSprite) { console.warn("Attempted to cut tree with invalid tree or worker."); this.destroyTreeHealthBar(tree); if(workerSprite) workerSprite.state = 'chopping'; return; }
      const woodFromFelledTree = 10;
      if (workerSprite === this.worker) { this.wood += woodFromFelledTree; this.woodText.setText('Wood: ' + this.wood); this.logDebug(`Tree felled! Gained ${woodFromFelledTree} wood. Total: ${this.wood}`); }
      else if (workerSprite === this.aiWorker) { this.aiWood += woodFromFelledTree; this.aiWoodText.setText('AI Wood: ' + this.aiWood); this.logDebug(`AI felled tree. Gained ${woodFromFelledTree} wood. Total: ${this.aiWood}`); }
      workerSprite.isCutting = false; workerSprite.cuttingTarget = null; workerSprite.initialChopHealth = null; workerSprite.state = 'chopping';
      workerSprite.setTexture('worker_sheet'); workerSprite.anims.stop(); workerSprite.setFrame(0); workerSprite.setFlipX(false);
      this.destroyTreeHealthBar(tree); this.trees.remove(tree, true, true);
      this.checkEndCondition();
    }

    /**
     * Checks if the game should end based on wood counts or house destruction. (Unchanged)
     */
    checkEndCondition() { /* ... same as before ... */
        if (this.gameOver) return;
        if (this.house && !this.house.active) { this.endGame("Computer Wins!", '#ff0000'); return; }
        if (this.aiHouse && !this.aiHouse.active) { this.endGame("You Win!", '#ffff00'); return; }
        const winAmount = 100;
        if (this.wood >= winAmount) { this.endGame("You Win!", '#ffff00'); return; }
        if (this.aiWood >= winAmount) { this.endGame("Computer Wins!", '#ff0000'); return; }
        const remainingTrees = this.trees.countActive(true);
        if (remainingTrees === 0) {
             const playerWorkerBusy = this.worker && this.worker.active && (this.worker.moving || this.worker.isCutting || this.worker.isBuilding);
             const aiWorkerBusy = this.aiWorker && this.aiWorker.active && (this.aiWorker.moving || this.aiWorker.isCutting || this.aiWorker.isBuilding);
             const playerSpearmanBusy = this.playerSpearmen.some(s => s.active && (s.moving || s.isAttacking));
             const aiSpearmanBusy = this.aiSpearmen.some(s => s.active && (s.moving || s.isAttacking));
             const playerBarrackBusy = this.playerBarrack && this.playerBarrack.active && (this.playerBarrack.isBuilding || this.playerBarrack.isTraining);
             const aiBarrackBusy = this.aiBarrack && this.aiBarrack.active && (this.aiBarrack.isBuilding || this.aiBarrack.isTraining);
            if (!playerWorkerBusy && !aiWorkerBusy && !playerSpearmanBusy && !aiSpearmanBusy && !playerBarrackBusy && !aiBarrackBusy) { this.endGame("Draw!", '#ffffff'); return; }
        }
    }

    /**
     * Ends the game, displaying a message and stopping activity. (Unchanged)
     */
    endGame(message, color = '#ffffff') { /* ... same as before ... */
        if (this.gameOver) return; this.gameOver = true; this.gameStarted = false;
        this.logDebug(`Game Over: ${message}`);
        this.add.text(this.sys.game.config.width / 2, this.sys.game.config.height / 2, message, { font: '48px Arial', fill: color, align: 'center' }).setOrigin(0.5).setDepth(2000);
        this.input.enabled = false; this.tweens.killAll();
        if (this.workerWalkSound && this.workerWalkSound.isPlaying) this.workerWalkSound.stop();
        if (this.chopSound && this.chopSound.isPlaying) this.chopSound.stop();
        if (this.spearmanAttackSound && this.spearmanAttackSound.isPlaying) this.spearmanAttackSound.stop();
        [this.worker, this.aiWorker].forEach(w => { if (w && w.active) { if (w.isCutting) this.stopCutting(w); if (w.isBuilding) this.stopBuilding(w); w.state = 'idle'; w.moving = false; w.target = null; w.setTexture('worker_sheet'); w.anims.stop(); w.setFrame(0); w.setFlipX(false); } });
        [...this.playerSpearmen, ...this.aiSpearmen].forEach(spearman => { if (spearman && spearman.active) { if(spearman.isAttacking) this.stopAttacking(spearman); spearman.state = 'idle'; spearman.moving = false; spearman.attackTarget = null; spearman.setTexture('spearman_walk_sheet'); spearman.anims.stop(); spearman.setFrame(0); spearman.setFlipX(false); } });
        [this.playerBarrack, this.aiBarrack].forEach(barrack => { if (barrack && barrack.active) { if (barrack.trainingTimer) barrack.trainingTimer.remove(); this.destroyTrainingText(barrack); barrack.isTraining = false; } });
         if (this.trees) { this.trees.getChildren().forEach(tree => this.destroyTreeHealthBar(tree)); }
        console.log("Game Over:", message);
    }


    /**
     * Updates the position and fill of a unit's health bar. (Unchanged)
     */
    updateHealthBar(unit) { /* ... same as before ... */
        if (!unit || !unit.active || !unit.healthBarBg || !unit.healthBarFill || !unit.healthBarBg.active || !unit.healthBarFill.active) { this.destroyHealthBar(unit); return; }
        const barWidth = unit.healthBarWidth; const unitHeight = unit.displayHeight || unit.height || 64;
        const yOffset = -unitHeight - 5; const x = unit.x; const y = unit.y + yOffset;
        unit.healthBarBg.setPosition(x, y); unit.healthBarFill.setPosition(x - barWidth / 2, y);
        const currentHealth = typeof unit.health === 'number' ? unit.health : 0;
        const maxHealth = typeof unit.maxHealth === 'number' && unit.maxHealth > 0 ? unit.maxHealth : 1;
        const fillRatio = Math.max(0, Math.min(1, currentHealth / maxHealth));
        const fillWidth = fillRatio * barWidth; unit.healthBarFill.width = fillWidth;
    }

     /**
       * Destroys the health bar associated with any unit/building. (Unchanged)
       */
      destroyHealthBar(unit) { /* ... same as before ... */
        if (unit) { if (unit.healthBarBg) { unit.healthBarBg.destroy(); unit.healthBarBg = null; } if (unit.healthBarFill) { unit.healthBarFill.destroy(); unit.healthBarFill = null; } }
      }

     /**
       * Creates a training progress text bubble for a barrack. (Unchanged)
       */
      createTrainingText(barrack) { /* ... same as before ... */
        if (!barrack || !barrack.active || barrack.trainingText) return;
        this.logDebug("Creating training text..."); this.destroyTrainingText(barrack);
        barrack.trainingText = this.add.text(0, 0, '0%', TRAINING_TEXT_STYLE).setOrigin(0.5, 1);
        if (!barrack.trainingText) { this.logDebug("ERROR: Failed to create text object!"); return; }
        this.updateTrainingText(barrack); this.logDebug("Training text created.");
      }

     /**
       * Updates the position and content of a barrack's training text bubble. (Unchanged)
       */
      updateTrainingText(barrack) { /* ... same as before ... */
        if (!barrack || !barrack.active || !barrack.isTraining || !barrack.trainingText || !barrack.trainingText.active) { this.destroyTrainingText(barrack); return; }
        if (!barrack.trainingTimer) return;
        const text = barrack.trainingText; const unitHeight = barrack.displayHeight || barrack.height || 64;
        const yOffset = -unitHeight - 5 - HEALTH_BAR_HEIGHT - 5; const x = barrack.x; const y = barrack.y + yOffset;
        text.setPosition(x, y); const progress = barrack.trainingTimer.getProgress(); const percent = Math.floor(progress * 100);
        text.setText(percent + '%');
      }

     /**
       * Destroys the training text bubble associated with a barrack. (Unchanged)
       */
      destroyTrainingText(barrack) { /* ... same as before ... */
        if (barrack && barrack.trainingText && barrack.trainingText.active) { barrack.trainingText.destroy(); barrack.trainingText = null; }
      }


    /**
     * Finds the closest *visible* active tree to the specified worker.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker to find the closest tree for.
     * @returns {Phaser.GameObjects.Sprite | null} The closest visible tree or null.
     */
    findClosestTree(workerSprite) {
        if (!workerSprite || !this.trees) return null;

        const activeTrees = this.trees.getChildren().filter(tree => tree.active);
        if (activeTrees.length === 0) return null;

        let closestVisibleTree = null;
        let minDistance = Infinity;
        const workerIsPlayer = workerSprite.getData('isPlayer');

        activeTrees.forEach(tree => {
            // --- Visibility Check ---
            const { gridX, gridY } = this.worldToGrid(tree.x, tree.y);
            if (!this.isCellRevealed(gridX, gridY)) {
                return; // Skip this tree, it's in the fog
            }
            // --- End Visibility Check ---

            // --- Target Avoidance Logic (Unchanged) ---
            let isTreeBusy = false;
            if (this.worker && this.worker.active && this.worker !== workerSprite) {
                 if (this.worker.isCutting && this.worker.cuttingTarget === tree) isTreeBusy = true;
                 if (this.worker.moving && this.worker.target === tree && this.worker.state === 'moving_to_chop') isTreeBusy = true;
            }
             if (this.aiWorker && this.aiWorker.active && this.aiWorker !== workerSprite) {
                 if (this.aiWorker.isCutting && this.aiWorker.cuttingTarget === tree) isTreeBusy = true;
                 if (this.aiWorker.moving && this.aiWorker.target === tree && this.aiWorker.state === 'moving_to_chop') isTreeBusy = true;
             }
            if (isTreeBusy) return; // Skip this tree, it's claimed
            // --- End Target Avoidance ---

            const distance = Phaser.Math.Distance.Between(workerSprite.x, workerSprite.y, tree.x, tree.y);
            if (distance < minDistance) {
                minDistance = distance;
                closestVisibleTree = tree;
            }
        });

        return closestVisibleTree; // Return the closest one that is visible and not busy
    }

    /**
     * Sends the specified worker to move towards and cut a specific tree. (Unchanged logic, uses updated findClosestTree)
     */
    sendWorkerToTree(workerSprite, tree) { /* ... same as before ... */
        if (!tree || !tree.active || !workerSprite || !workerSprite.active || this.gameOver) { this.logDebug('Cannot send worker: Invalid target/worker or game over.'); return; }
        const workerId = workerSprite.getData('isPlayer') ? 'Player' : 'AI';
        this.logDebug(`Sending ${workerId} worker to tree.`);
        if (workerSprite.isCutting) this.stopCutting(workerSprite);
        if (workerSprite.isBuilding) this.stopBuilding(workerSprite);
        if (workerSprite.moving) {
            this.tweens.killTweensOf(workerSprite); workerSprite.moving = false;
            workerSprite.setTexture('worker_sheet'); workerSprite.anims.stop(); workerSprite.setFrame(0); workerSprite.setFlipX(false);
            if (this.workerWalkSound && this.workerWalkSound.isPlaying) { let otherWorker = workerId === 'Player' ? this.aiWorker : this.worker; if (!otherWorker || !otherWorker.active || !otherWorker.moving) this.workerWalkSound.stop(); }
        }
        workerSprite.target = null; workerSprite.cuttingTarget = null; workerSprite.buildingTarget = null; workerSprite.initialChopHealth = null;
        workerSprite.target = tree; workerSprite.moving = true; workerSprite.state = 'moving_to_chop';
        const offset = 30; const targetY = tree.y; let targetX; let faceRightOnArrival;
        if (workerSprite.x <= tree.x) { targetX = tree.x - offset; faceRightOnArrival = true; }
        else { targetX = tree.x + offset; faceRightOnArrival = false; }
        this.logDebug(`${workerId} worker moving to tree at (${Math.round(tree.x)}, ${Math.round(tree.y)}). Target: (${Math.round(targetX)}, ${Math.round(targetY)})`);
        const distance = Phaser.Math.Distance.Between(workerSprite.x, workerSprite.y, targetX, targetY);
        const speed = 100; const duration = (distance / speed) * 1000 || 1;
        workerSprite.anims.play('worker_walk', true);
        if (this.workerWalkSound && !this.workerWalkSound.isPlaying) { let otherWorker = workerId === 'Player' ? this.aiWorker : this.worker; if (!otherWorker || !otherWorker.active || !otherWorker.moving) this.workerWalkSound.play({ loop: true }); }
        if (targetX < workerSprite.x) workerSprite.setFlipX(true); else workerSprite.setFlipX(false);
        this.tweens.add({
          targets: workerSprite, x: targetX, y: targetY, duration: duration, ease: 'Linear',
          onComplete: () => {
             if (!workerSprite.active || workerSprite.state !== 'moving_to_chop' || !workerSprite.target || !workerSprite.target.active) {
                 if (workerSprite.active && workerSprite.state === 'moving_to_chop') { this.logDebug(`${workerId} reached location, but target invalid or state changed.`); workerSprite.state = 'idle'; workerSprite.setTexture('worker_sheet'); workerSprite.anims.stop(); workerSprite.setFrame(0); workerSprite.setFlipX(false); }
                 workerSprite.moving = false; workerSprite.target = null;
                 if (this.workerWalkSound && this.workerWalkSound.isPlaying) { let otherWorker = workerId === 'Player' ? this.aiWorker : this.worker; if (!otherWorker || !otherWorker.active || !otherWorker.moving) this.workerWalkSound.stop(); }
                 return;
             }
            workerSprite.moving = false;
            if (this.workerWalkSound && this.workerWalkSound.isPlaying) { let otherWorker = workerId === 'Player' ? this.aiWorker : this.worker; if (!otherWorker || !otherWorker.active || !otherWorker.moving) this.workerWalkSound.stop(); }
            const actualTree = workerSprite.target; workerSprite.target = null;
            let otherWorker = workerId === 'Player' ? this.aiWorker : this.worker;
             if (otherWorker && otherWorker.active && ((otherWorker.isCutting && otherWorker.cuttingTarget === actualTree) || (otherWorker.moving && otherWorker.target === actualTree && otherWorker.state === 'moving_to_chop'))) {
                 this.logDebug(`${workerId} Tree claimed by other worker. Finding another.`); workerSprite.state = 'chopping'; workerSprite.setTexture('worker_sheet'); workerSprite.anims.stop(); workerSprite.setFrame(0); return;
             }
            workerSprite.state = 'chopping'; workerSprite.isCutting = true; workerSprite.cuttingTarget = actualTree; workerSprite.initialChopHealth = actualTree.health;
            this.logDebug(`${workerId} reached tree. Starting cut (H:${actualTree.health})`);
            this.createTreeHealthBar(actualTree);
            workerSprite.setFlipX(!faceRightOnArrival); workerSprite.setTexture('worker_chop_sheet'); workerSprite.anims.play('worker_chop', true);
             if (this.chopSound && !this.chopSound.isPlaying) { let otherWorkerBusy = otherWorker && otherWorker.active && (otherWorker.isCutting || otherWorker.isBuilding); if (!otherWorkerBusy) this.chopSound.play({ loop: true }); }
            workerSprite.cuttingTimer = this.time.addEvent({ delay: 1000, callback: () => this.damageTree(workerSprite), callbackScope: this, loop: true });
          },
          onStop: () => {
             if (!workerSprite.active) return; const wasMoving = workerSprite.moving; workerSprite.moving = false; workerSprite.target = null;
             if (workerSprite.state === 'moving_to_chop') { workerSprite.state = 'chopping'; this.logDebug(`${workerId} worker move to tree interrupted, trying to find tree.`); }
             else if (workerSprite.state === 'moving_to_idle'){ workerSprite.state = 'idle'; this.logDebug(`${workerId} worker move interrupted, going idle.`); }
             if(wasMoving) { workerSprite.setTexture('worker_sheet'); workerSprite.anims.stop(); workerSprite.setFrame(0); workerSprite.setFlipX(false); }
             if (this.workerWalkSound && this.workerWalkSound.isPlaying && wasMoving) { let otherWorker = workerId === 'Player' ? this.aiWorker : this.worker; if (!otherWorker || !otherWorker.active || !otherWorker.moving) this.workerWalkSound.stop(); }
          }
        });
    }

     /**
       * Starts the process of building a barrack for a specific side. (Reveal FoW on completion)
       */
      startBuildingBarrack(workerSprite, side = 'player') { /* ... same logic as before up to tween ... */
       const isPlayer = side === 'player'; const woodCount = isPlayer ? this.wood : this.aiWood; const existingBarrack = isPlayer ? this.playerBarrack : this.aiBarrack;
       const isBuildingThisBarrack = isPlayer ? this.playerBarrackBuilding : this.aiBarrackBuilding; const house = isPlayer ? this.house : this.aiHouse; const woodCost = BARRACK_WOOD_COST;
       if (!workerSprite || !workerSprite.active || !house || !house.active || (existingBarrack && existingBarrack.active) || isBuildingThisBarrack || woodCount < woodCost ) { if (!isPlayer && workerSprite.state === 'idle') workerSprite.state = 'chopping'; return; }
       this.logDebug(`Starting ${side} barrack construction.`);
       if (isPlayer) { this.playerBarrackBuilding = true; this.wood -= woodCost; this.woodText.setText('Wood: ' + this.wood); }
       else { this.aiBarrackBuilding = true; this.aiWood -= woodCost; this.aiWoodText.setText('AI Wood: ' + this.aiWood); }
       if (workerSprite.isCutting) this.stopCutting(workerSprite); if (workerSprite.isBuilding) this.stopBuilding(workerSprite);
       if (workerSprite.moving) { this.tweens.killTweensOf(workerSprite); workerSprite.moving = false; workerSprite.target = null; workerSprite.setTexture('worker_sheet'); workerSprite.anims.stop(); workerSprite.setFrame(0); workerSprite.setFlipX(false); if (this.workerWalkSound && this.workerWalkSound.isPlaying) { let otherWorker = isPlayer ? this.aiWorker : this.worker; if (!otherWorker || !otherWorker.active || !otherWorker.moving) this.workerWalkSound.stop(); } }
       workerSprite.cuttingTarget = null; workerSprite.buildingTarget = null; workerSprite.initialChopHealth = null;
       const buildX = isPlayer ? house.x + 80 : house.x - 80; const buildY = house.y;
       const newBarrack = this.add.sprite(buildX, buildY, 'barrack').setOrigin(0.5, 1);
       newBarrack.health = 0; newBarrack.maxHealth = BARRACK_HEALTH; newBarrack.isBuilding = true; newBarrack.isTraining = false; newBarrack.trainingTimer = null; newBarrack.trainingText = null;
       newBarrack.setData('unitType', 'barrack'); newBarrack.setData('isPlayer', isPlayer); newBarrack.setAlpha(0.5);
       const barColor = isPlayer ? PLAYER_HEALTH_BAR_COLOR : AI_HEALTH_BAR_COLOR; this.createHealthBar(newBarrack, BUILDING_HEALTH_BAR_WIDTH, barColor);
       if (isPlayer) { this.playerBarrack = newBarrack; } else { this.aiBarrack = newBarrack; }
       // --- Reveal FoW for the placeholder immediately ---
       this.updateVisibilityAround(newBarrack);
       // --- Send worker to build site ---
       workerSprite.state = 'moving_to_build'; workerSprite.target = newBarrack;
       const offset = 40; const targetYBuild = buildY; let targetXBuild; let faceRightOnArrivalBuild;
       if (workerSprite.x <= buildX) { targetXBuild = buildX - offset; faceRightOnArrivalBuild = true; } else { targetXBuild = buildX + offset; faceRightOnArrivalBuild = false; }
       const distance = Phaser.Math.Distance.Between(workerSprite.x, workerSprite.y, targetXBuild, targetYBuild); const speed = 100; const duration = (distance / speed) * 1000 || 1;
       workerSprite.anims.play('worker_walk', true); if (targetXBuild < workerSprite.x) workerSprite.setFlipX(true); else workerSprite.setFlipX(false); workerSprite.moving = true;
       if (this.workerWalkSound && !this.workerWalkSound.isPlaying) { let otherWorker = isPlayer ? this.aiWorker : this.worker; if (!otherWorker || !otherWorker.active || !otherWorker.moving) this.workerWalkSound.play({ loop: true }); }
       this.tweens.add({
           targets: workerSprite, x: targetXBuild, y: targetYBuild, duration: duration, ease: 'Linear',
           onComplete: () => {
               if (!workerSprite.active || workerSprite.state !== 'moving_to_build' || !workerSprite.target || !workerSprite.target.active) {
                   if(workerSprite.active && workerSprite.state === 'moving_to_build') { this.logDebug(`${side} worker reached build site, but target invalid or state changed.`); workerSprite.state = 'idle'; workerSprite.setTexture('worker_sheet'); workerSprite.anims.stop(); workerSprite.setFrame(0); workerSprite.setFlipX(false); const barrackToCancel = workerSprite.target; if (barrackToCancel && barrackToCancel.active && barrackToCancel.isBuilding) { this.cancelBuilding(barrackToCancel, side, woodCost); } else { if(isPlayer) this.playerBarrackBuilding = false; else this.aiBarrackBuilding = false; } }
                   workerSprite.moving = false; workerSprite.target = null;
                   if (this.workerWalkSound && this.workerWalkSound.isPlaying) { let otherWorker = isPlayer ? this.aiWorker : this.worker; if (!otherWorker || !otherWorker.active || !otherWorker.moving) this.workerWalkSound.stop(); }
                   return;
               }
               workerSprite.moving = false;
               if (this.workerWalkSound && this.workerWalkSound.isPlaying) { let otherWorker = isPlayer ? this.aiWorker : this.worker; if (!otherWorker || !otherWorker.active || !otherWorker.moving) this.workerWalkSound.stop(); }
               workerSprite.state = 'building'; workerSprite.isBuilding = true; workerSprite.buildingTarget = workerSprite.target;
               this.logDebug(`${side} worker arrived at build site. Starting construction.`);
               workerSprite.setFlipX(!faceRightOnArrivalBuild); workerSprite.setTexture('worker_chop_sheet'); workerSprite.anims.play('worker_chop', true);
               if (this.chopSound && !this.chopSound.isPlaying) { let otherWorker = isPlayer ? this.aiWorker : this.worker; let otherWorkerBusy = otherWorker && otherWorker.active && (otherWorker.isCutting || otherWorker.isBuilding); if (!otherWorkerBusy) this.chopSound.play({ loop: true }); }
               workerSprite.buildingTimer = this.time.addEvent({ delay: 1000, callback: () => this.buildStructure(workerSprite), callbackScope: this, loop: true });
           },
            onStop: () => {
               if (!workerSprite.active) return; const wasMoving = workerSprite.moving; workerSprite.moving = false;
               if (workerSprite.state === 'moving_to_build') { workerSprite.state = 'idle'; this.logDebug(`${side} worker move to build site interrupted.`); const barrackToCancel = workerSprite.target; if(barrackToCancel && barrackToCancel.active && barrackToCancel.isBuilding) { this.cancelBuilding(barrackToCancel, side, woodCost); } else { if(isPlayer) this.playerBarrackBuilding = false; else this.aiBarrackBuilding = false; } }
               workerSprite.target = null;
               if(wasMoving) { workerSprite.setTexture('worker_sheet'); workerSprite.anims.stop(); workerSprite.setFrame(0); workerSprite.setFlipX(false); }
               if (this.workerWalkSound && this.workerWalkSound.isPlaying && wasMoving) { let otherWorker = isPlayer ? this.aiWorker : this.worker; if (!otherWorker || !otherWorker.active || !otherWorker.moving) this.workerWalkSound.stop(); }
           }
       });
      }

    /**
     * Cancels the building process, destroys the placeholder, refunds wood. (Unchanged)
     */
    cancelBuilding(barrackPlaceholder, side, woodCost) { /* ... same as before ... */
        if (!barrackPlaceholder || !barrackPlaceholder.active) return;
        this.logDebug(`Cancelling ${side} barrack construction.`); this.destroyHealthBar(barrackPlaceholder); this.destroyTrainingText(barrackPlaceholder); barrackPlaceholder.destroy();
        const isPlayer = side === 'player';
        if (isPlayer) { this.playerBarrack = null; this.playerBarrackBuilding = false; this.wood += woodCost; this.woodText.setText('Wood: ' + this.wood); this.logDebug(`Player refunded ${woodCost} wood.`); }
        else { this.aiBarrack = null; this.aiBarrackBuilding = false; this.aiWood += woodCost; this.aiWoodText.setText('AI Wood: ' + this.aiWood); this.logDebug(`AI refunded ${woodCost} wood.`); }
    }


     /**
       * Increases health of the structure being built. Reveals FoW on completion.
       */
      buildStructure(workerSprite) { /* ... same logic as before, but reveal FoW on completion ... */
       if (this.gameOver || !workerSprite || !workerSprite.active || !workerSprite.isBuilding || !workerSprite.buildingTarget || !workerSprite.buildingTarget.active) {
            this.stopBuilding(workerSprite);
            if(workerSprite && workerSprite.active && workerSprite.isBuilding && !workerSprite.buildingTarget) { const side = workerSprite.getData('isPlayer') ? 'player' : 'ai'; this.logDebug(`Build target disappeared while ${side} worker was building.`); this.stopBuilding(workerSprite); workerSprite.state = 'idle'; }
            return;
       }
       const building = workerSprite.buildingTarget; building.health += 1;
       this.updateHealthBar(building); building.setAlpha(0.5 + 0.5 * (building.health / building.maxHealth));
       if (building.health >= building.maxHealth) {
            building.health = building.maxHealth; building.setAlpha(1); building.isBuilding = false;
            this.updateHealthBar(building);
            const side = workerSprite.getData('isPlayer') ? 'Player' : 'AI'; this.logDebug(`${side} barrack construction complete!`);
            if (workerSprite.getData('isPlayer')) { this.playerBarrackBuilding = false; } else { this.aiBarrackBuilding = false; }
            // --- Reveal FoW for the completed building ---
            this.updateVisibilityAround(building);
            // --- Stop worker ---
            this.stopBuilding(workerSprite); workerSprite.state = 'chopping';
       }
      }

      /**
       * Stops the current building process for a specific worker. (Unchanged)
       */
      stopBuilding(workerSprite) { /* ... same as before ... */
       if (!workerSprite || !workerSprite.isBuilding) return;
       const side = workerSprite.getData('isPlayer') ? 'Player' : 'AI';
       if (workerSprite.buildingTimer) { workerSprite.buildingTimer.remove(false); workerSprite.buildingTimer = null; }
       if (this.chopSound && this.chopSound.isPlaying) { const otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker; const otherWorkerBusy = otherWorker && otherWorker.active && (otherWorker.isCutting || otherWorker.isBuilding); if (!otherWorkerBusy) this.chopSound.stop(); }
       workerSprite.isBuilding = false; workerSprite.buildingTarget = null; workerSprite.setTexture('worker_sheet'); workerSprite.anims.stop('worker_chop'); workerSprite.setFrame(0); workerSprite.setFlipX(false);
      }


    /**
     * Handles a worker's state machine logic, including exploring nearest hidden cell.
     */
    handleWorkerState(workerSprite) {
        if (!this.gameStarted || this.gameOver || !workerSprite || !workerSprite.active) return;

        const isPlayer = workerSprite.getData('isPlayer');
        const side = isPlayer ? 'player' : 'ai';

        // --- Check for Build Order (only if idle-like state) ---
        if (!workerSprite.moving && !workerSprite.isCutting && !workerSprite.isBuilding && workerSprite.state !== 'moving_to_explore') {
             const woodCount = isPlayer ? this.wood : this.aiWood; const existingBarrack = isPlayer ? this.playerBarrack : this.aiBarrack;
             const isBuildingThisBarrack = isPlayer ? this.playerBarrackBuilding : this.aiBarrackBuilding; const house = isPlayer ? this.house : this.aiHouse;
             if (house && house.active && !(existingBarrack && existingBarrack.active) && !isBuildingThisBarrack && woodCount >= BARRACK_WOOD_COST) {
                 this.startBuildingBarrack(workerSprite, side); return;
             }
        }

        // --- Default Actions (Chopping/Idle/Explore) ---
        // Only act if the worker is not currently busy moving, cutting, or building
        if (!workerSprite.moving && !workerSprite.isCutting && !workerSprite.isBuilding) {
            if (workerSprite.state === 'chopping' || workerSprite.state === 'idle') {
                const closestVisibleTree = this.findClosestTree(workerSprite); // Uses updated function
                if (closestVisibleTree) {
                    if (workerSprite.state === 'idle') this.logDebug(`${side} worker idle, found visible tree.`);
                    this.sendWorkerToTree(workerSprite, closestVisibleTree);
                } else {
                    // No visible trees left - find nearest hidden cell to explore
                    const nearestHidden = this.findNearestHiddenCell(workerSprite);
                    if (nearestHidden) {
                        this.logDebug(`No visible trees. ${side} Worker exploring nearest hidden cell at (${nearestHidden.gridX}, ${nearestHidden.gridY}).`);
                        const targetX = nearestHidden.gridX * FOG_CELL_SIZE + FOG_CELL_SIZE / 2;
                        const targetY = nearestHidden.gridY * FOG_CELL_SIZE + FOG_CELL_SIZE / 2;
                        this.startUnitMove(workerSprite, targetX, targetY, 'moving_to_explore', 'idle'); // Move to explore, become idle on arrival
                    } else {
                        // No visible trees AND no hidden cells - truly idle
                        if (workerSprite.state !== 'idle') {
                             this.logDebug(`No visible trees or hidden cells. ${side} Worker truly idle.`);
                             workerSprite.state = 'idle';
                             workerSprite.setTexture('worker_sheet'); workerSprite.anims.stop(); workerSprite.setFrame(0); workerSprite.setFlipX(false);
                        }
                        // Check for draw condition if truly idle
                        if (this.trees.countActive(true) === 0) this.checkEndCondition();
                    }
                }
            }
            // Reset state if somehow stuck
             else if (workerSprite.state === 'moving_to_chop' || workerSprite.state === 'moving_to_idle' || workerSprite.state === 'moving_to_build' || workerSprite.state === 'building' || workerSprite.state === 'moving_to_explore') {
                 this.logDebug(`${side} Worker stuck in ${workerSprite.state} without flag. Resetting to idle.`);
                 workerSprite.state = 'idle'; workerSprite.setTexture('worker_sheet'); workerSprite.anims.stop(); workerSprite.setFrame(0); workerSprite.setFlipX(false);
             }
        }
    }

    /**
     * Handles the training logic for a given barrack. (Unchanged)
     */
     handleBarrackTraining(barrack, isPlayer) { /* ... same as before ... */
        if (!barrack || !barrack.active || barrack.isBuilding || barrack.isTraining) return;
        const spearmanArray = isPlayer ? this.playerSpearmen : this.aiSpearmen; const woodCount = isPlayer ? this.wood : this.aiWood; const side = isPlayer ? 'Player' : 'AI';
        if (spearmanArray.length < SPEARMAN_LIMIT && woodCount >= SPEARMAN_WOOD_COST) {
            barrack.isTraining = true;
            if (isPlayer) { this.wood -= SPEARMAN_WOOD_COST; this.woodText.setText('Wood: ' + this.wood); }
            else { this.aiWood -= SPEARMAN_WOOD_COST; this.aiWoodText.setText('AI Wood: ' + this.aiWood); }
            this.logDebug(`${side} Barrack starts training spearman (${spearmanArray.length + 1}/${SPEARMAN_LIMIT}). Cost: ${SPEARMAN_WOOD_COST}`);
            this.createTrainingText(barrack);
            barrack.trainingTimer = this.time.addEvent({ delay: SPEARMAN_TRAIN_TIME, callback: () => this.spawnSpearman(barrack, isPlayer), callbackScope: this });
        }
    }

    /**
     * Spawns a spearman near the specified barrack. Reveals FoW.
     */
     spawnSpearman(barrack, isPlayer) { /* ... same logic as before, but reveal FoW ... */
        if (!barrack || !barrack.active || !barrack.isTraining) { this.logDebug("Spawn cancelled: Barrack invalid or not training."); this.destroyTrainingText(barrack); return; }
        barrack.isTraining = false; barrack.trainingTimer = null; this.destroyTrainingText(barrack);
        const spearmanArray = isPlayer ? this.playerSpearmen : this.aiSpearmen; const side = isPlayer ? 'Player' : 'AI';
        if (spearmanArray.length >= SPEARMAN_LIMIT) { this.logDebug(`Spawn cancelled: ${side} spearman limit reached.`); return; }
        const initialSpawnX = barrack.x + (isPlayer ? 40 : -40); const initialSpawnY = barrack.y;
        let finalSpawnPos = { x: initialSpawnX, y: initialSpawnY }; let needsToMove = false;
        if (this.isPositionOccupied(initialSpawnX, initialSpawnY, null)) { this.logDebug("Spawn point occupied, finding nearby spot..."); finalSpawnPos = this.findNearbyEmptyPosition(initialSpawnX, initialSpawnY, 50, null); if (finalSpawnPos.x !== initialSpawnX || finalSpawnPos.y !== initialSpawnY) needsToMove = true; }
        const spearman = this.add.sprite(finalSpawnPos.x, finalSpawnPos.y, 'spearman_walk_sheet').setOrigin(0.5, 1);
        spearman.health = SPEARMAN_HEALTH; spearman.maxHealth = SPEARMAN_HEALTH; spearman.state = 'idle'; spearman.moving = false; spearman.attackTarget = null; spearman.isAttacking = false; spearman.attackTimer = null;
        spearman.setData('unitType', 'spearman'); spearman.setData('isPlayer', isPlayer); spearman.setFrame(0); spearman.setFlipX(!isPlayer);
        spearmanArray.push(spearman);
        const barColor = isPlayer ? PLAYER_HEALTH_BAR_COLOR : AI_HEALTH_BAR_COLOR; this.createHealthBar(spearman, SPEARMAN_HEALTH_BAR_WIDTH, barColor);
        this.logDebug(`${side} spearman spawned! (${spearmanArray.length}/${SPEARMAN_LIMIT}) at (${Math.round(finalSpawnPos.x)}, ${Math.round(finalSpawnPos.y)})`);
        // --- Reveal FoW for the new spearman ---
        this.updateVisibilityAround(spearman);
        // --- Handle movement if needed (unchanged) ---
        if (needsToMove) {
             this.logDebug(`Spearman moving from initial spawn (${Math.round(initialSpawnX)}, ${Math.round(initialSpawnY)}) to final (${Math.round(finalSpawnPos.x)}, ${Math.round(finalSpawnPos.y)})`);
             spearman.setPosition(initialSpawnX, initialSpawnY); spearman.state = 'moving'; spearman.moving = true; spearman.anims.play('spearman_walk', true);
             const distance = Phaser.Math.Distance.Between(initialSpawnX, initialSpawnY, finalSpawnPos.x, finalSpawnPos.y); const speed = 80; const duration = (distance / speed) * 1000 || 1;
             if (finalSpawnPos.x < initialSpawnX) spearman.setFlipX(true); else spearman.setFlipX(false);
             this.tweens.add({
                 targets: spearman, x: finalSpawnPos.x, y: finalSpawnPos.y, duration: duration, ease: 'Linear',
                 onComplete: () => { if (!spearman.active) return; spearman.moving = false; spearman.state = 'idle'; spearman.anims.stop(); spearman.setTexture('spearman_walk_sheet'); spearman.setFrame(0); spearman.setFlipX(!isPlayer); this.logDebug("Spearman finished spawn move."); },
                 onStop: () => { if (!spearman.active) return; spearman.moving = false; spearman.state = 'idle'; spearman.anims.stop(); spearman.setTexture('spearman_walk_sheet'); spearman.setFrame(0); spearman.setFlipX(!isPlayer); this.logDebug("Spearman spawn move interrupted."); }
             });
        }
    }

    // --- COMBAT FUNCTIONS (Modified for Visibility) ---

    /**
     * Finds the closest *visible* active enemy target for a unit.
     */
    findClosestEnemyTarget(unit) {
        if (!unit || !unit.active) return null;

        const isPlayerUnit = unit.getData('isPlayer');
        let potentialTargets = [];

        // Gather potential targets (unchanged)
        if (isPlayerUnit) {
            if (this.aiWorker && this.aiWorker.active) potentialTargets.push(this.aiWorker);
            if (this.aiBarrack && this.aiBarrack.active) potentialTargets.push(this.aiBarrack);
            if (this.aiHouse && this.aiHouse.active) potentialTargets.push(this.aiHouse);
            potentialTargets = potentialTargets.concat(this.aiSpearmen.filter(s => s.active));
        } else {
            if (this.worker && this.worker.active) potentialTargets.push(this.worker);
            if (this.playerBarrack && this.playerBarrack.active) potentialTargets.push(this.playerBarrack);
            if (this.house && this.house.active) potentialTargets.push(this.house);
            potentialTargets = potentialTargets.concat(this.playerSpearmen.filter(s => s.active));
        }

        if (potentialTargets.length === 0) return null;

        let closestVisibleTarget = null;
        let minDistanceSq = Infinity;

        potentialTargets.forEach(target => {
            // --- Visibility Check ---
            const { gridX, gridY } = this.worldToGrid(target.x, target.y);
            if (!this.isCellRevealed(gridX, gridY)) {
                return; // Skip this target, it's in the fog
            }
            // --- End Visibility Check ---

            const distanceSq = Phaser.Math.Distance.Squared(unit.x, unit.y, target.x, target.y);
            if (distanceSq < minDistanceSq) {
                minDistanceSq = distanceSq;
                closestVisibleTarget = target;
            }
        });

        return closestVisibleTarget; // Return the closest one that is visible
    }

     /**
      * Sends a spearman to move within attack range of a target. (Unchanged logic, uses updated findClosestEnemyTarget)
      */
      sendSpearmanToAttack(spearman, target) { /* ... same as before ... */
        if (!spearman || !spearman.active || !target || !target.active || this.gameOver) { if(spearman && spearman.active) spearman.state = 'idle'; return; }
        const side = spearman.getData('isPlayer') ? 'Player' : 'AI'; this.logDebug(`${side} spearman moving to attack ${target.getData('unitType') || 'target'}.`);
        if (spearman.isAttacking) this.stopAttacking(spearman);
        if (spearman.moving) { this.tweens.killTweensOf(spearman); spearman.moving = false; spearman.setTexture('spearman_walk_sheet'); spearman.anims.stop(); spearman.setFrame(0); }
        spearman.attackTarget = null;
        spearman.target = target; spearman.moving = true; spearman.state = 'moving_to_attack';
        const angleToTarget = Phaser.Math.Angle.Between(spearman.x, spearman.y, target.x, target.y);
        const targetX = target.x - Math.cos(angleToTarget) * (SPEARMAN_ATTACK_RANGE - 5);
        const targetY = target.y - Math.sin(angleToTarget) * (SPEARMAN_ATTACK_RANGE - 5);
        const distance = Phaser.Math.Distance.Between(spearman.x, spearman.y, targetX, targetY); const speed = 80; const duration = (distance / speed) * 1000 || 1;
        spearman.anims.play('spearman_walk', true); if (targetX < spearman.x) spearman.setFlipX(true); else spearman.setFlipX(false);
        if (this.workerWalkSound && !this.workerWalkSound.isPlaying) { let pMoving = this.worker && this.worker.active && this.worker.moving; let aMoving = this.aiWorker && this.aiWorker.active && this.aiWorker.moving; let oMoving = this.playerSpearmen.some(s => s.active && s !== spearman && s.moving) || this.aiSpearmen.some(s => s.active && s !== spearman && s.moving); if (!pMoving && !aMoving && !oMoving) this.workerWalkSound.play({ loop: true }); }
        this.tweens.add({
            targets: spearman, x: targetX, y: targetY, duration: duration, ease: 'Linear',
            onComplete: () => {
                if (!spearman.active || spearman.state !== 'moving_to_attack' || !spearman.target || !spearman.target.active) {
                    if(spearman.active && spearman.state === 'moving_to_attack') { this.logDebug(`${side} spearman reached attack location, but target invalid/state changed.`); spearman.state = 'idle'; spearman.setTexture('spearman_walk_sheet'); spearman.anims.stop(); spearman.setFrame(0); spearman.setFlipX(!spearman.getData('isPlayer')); }
                    spearman.moving = false; spearman.target = null;
                    if (this.workerWalkSound && this.workerWalkSound.isPlaying) { let pMoving = this.worker && this.worker.active && this.worker.moving; let aMoving = this.aiWorker && this.aiWorker.active && this.aiWorker.moving; let oMoving = this.playerSpearmen.some(s => s.active && s.moving) || this.aiSpearmen.some(s => s.active && s.moving); if (!pMoving && !aMoving && !oMoving) this.workerWalkSound.stop(); }
                    return;
                }
                spearman.moving = false;
                if (this.workerWalkSound && this.workerWalkSound.isPlaying) { let pMoving = this.worker && this.worker.active && this.worker.moving; let aMoving = this.aiWorker && this.aiWorker.active && this.aiWorker.moving; let oMoving = this.playerSpearmen.some(s => s.active && s !== spearman && s.moving) || this.aiSpearmen.some(s => s.active && s !== spearman && s.moving); if (!pMoving && !aMoving && !oMoving) this.workerWalkSound.stop(); }
                const finalTarget = spearman.target; spearman.target = null; const finalDistance = Phaser.Math.Distance.Between(spearman.x, spearman.y, finalTarget.x, finalTarget.y);
                if (finalDistance <= SPEARMAN_ATTACK_RANGE) { this.startAttacking(spearman, finalTarget); }
                else { this.logDebug(`${side} spearman arrived but target out of range (${finalDistance.toFixed(0)} > ${SPEARMAN_ATTACK_RANGE}). Re-evaluating.`); spearman.state = 'idle'; spearman.setTexture('spearman_walk_sheet'); spearman.anims.stop(); spearman.setFrame(0); spearman.setFlipX(!spearman.getData('isPlayer')); }
            },
            onStop: () => {
                 if (!spearman.active) return; const wasMoving = spearman.moving; spearman.moving = false; spearman.target = null;
                 if (spearman.state === 'moving_to_attack') { spearman.state = 'idle'; this.logDebug(`${side} spearman move to attack interrupted.`); }
                 if(wasMoving) { spearman.setTexture('spearman_walk_sheet'); spearman.anims.stop(); spearman.setFrame(0); spearman.setFlipX(!spearman.getData('isPlayer')); }
                 if (this.workerWalkSound && this.workerWalkSound.isPlaying && wasMoving) { let pMoving = this.worker && this.worker.active && this.worker.moving; let aMoving = this.aiWorker && this.aiWorker.active && this.aiWorker.moving; let oMoving = this.playerSpearmen.some(s => s.active && s.moving) || this.aiSpearmen.some(s => s.active && s.moving); if (!pMoving && !aMoving && !oMoving) this.workerWalkSound.stop(); }
            }
        });
      }

     /**
       * Starts the attack sequence for a spearman. (Unchanged)
       */
      startAttacking(spearman, target) { /* ... same as before ... */
        if (!spearman || !spearman.active || !target || !target.active || spearman.isAttacking || this.gameOver) return;
        const side = spearman.getData('isPlayer') ? 'Player' : 'AI'; this.logDebug(`${side} spearman starting attack on ${target.getData('unitType') || 'target'}.`);
        spearman.state = 'attacking'; spearman.isAttacking = true; spearman.attackTarget = target;
        if (target.x < spearman.x) spearman.setFlipX(true); else spearman.setFlipX(false);
        spearman.setTexture('spearman_attack_sheet'); spearman.anims.play('spearman_attack', true);
        if (this.spearmanAttackSound && !this.spearmanAttackSound.isPlaying) this.spearmanAttackSound.play({ loop: true });
        spearman.attackTimer = this.time.addEvent({ delay: SPEARMAN_ATTACK_DELAY, callback: () => this.damageTarget(spearman), callbackScope: this, loop: true });
      }

    /**
     * Stops the attack sequence for a spearman. (Unchanged)
     */
    stopAttacking(spearman) { /* ... same as before ... */
        if (!spearman || !spearman.isAttacking) return;
        const side = spearman.getData('isPlayer') ? 'Player' : 'AI';
        if (spearman.attackTimer) { spearman.attackTimer.remove(false); spearman.attackTimer = null; }
        spearman.isAttacking = false; spearman.attackTarget = null;
        if (this.spearmanAttackSound && this.spearmanAttackSound.isPlaying) this.spearmanAttackSound.stop();
        if (spearman.active) { spearman.setTexture('spearman_walk_sheet'); spearman.anims.stop('spearman_attack'); spearman.setFrame(0); spearman.setFlipX(!spearman.getData('isPlayer')); }
    }

    /**
     * Applies damage to the spearman's current target. (Unchanged)
     */
    damageTarget(spearman) { /* ... same as before ... */
        if (this.gameOver || !spearman || !spearman.active || !spearman.isAttacking || !spearman.attackTarget || !spearman.attackTarget.active) { if (spearman && spearman.active && spearman.isAttacking) { this.stopAttacking(spearman); spearman.state = 'idle'; } return; }
        const target = spearman.attackTarget; const side = spearman.getData('isPlayer') ? 'Player' : 'AI';
        const distance = Phaser.Math.Distance.Between(spearman.x, spearman.y, target.x, target.y);
        if (distance > SPEARMAN_ATTACK_RANGE) { this.logDebug(`${side} spearman target moved out of range. Stopping attack.`); this.stopAttacking(spearman); spearman.state = 'idle'; return; }
        target.takeDamage(SPEARMAN_DPS, spearman);
    }

    /**
     * Handles a spearman's state machine logic, including exploring nearest hidden cell.
     */
    handleSpearmanState(spearman) {
        if (!this.gameStarted || this.gameOver || !spearman || !spearman.active) return;

        const side = spearman.getData('isPlayer') ? 'Player' : 'AI';

        // Only act if idle (not moving or attacking)
        if (spearman.state === 'idle' && !spearman.moving && !spearman.isAttacking) {
            const target = this.findClosestEnemyTarget(spearman); // Uses updated function

            if (target) {
                const distance = Phaser.Math.Distance.Between(spearman.x, spearman.y, target.x, target.y);
                if (distance <= SPEARMAN_ATTACK_RANGE) {
                    this.startAttacking(spearman, target);
                } else {
                    this.sendSpearmanToAttack(spearman, target);
                }
            } else {
                // No visible targets found - find nearest hidden cell to explore
                const nearestHidden = this.findNearestHiddenCell(spearman);
                if (nearestHidden) {
                     this.logDebug(`No visible targets. ${side} Spearman exploring nearest hidden cell at (${nearestHidden.gridX}, ${nearestHidden.gridY}).`);
                     const targetX = nearestHidden.gridX * FOG_CELL_SIZE + FOG_CELL_SIZE / 2;
                     const targetY = nearestHidden.gridY * FOG_CELL_SIZE + FOG_CELL_SIZE / 2;
                     this.startUnitMove(spearman, targetX, targetY, 'moving_to_explore', 'idle'); // Move to explore, become idle on arrival
                } else {
                    // No visible targets AND no hidden cells - truly idle
                     if (spearman.state !== 'idle') {
                          this.logDebug(`No visible targets or hidden cells. ${side} Spearman truly idle.`);
                          spearman.state = 'idle';
                          spearman.setTexture('spearman_walk_sheet'); spearman.anims.stop(); spearman.setFrame(0); spearman.setFlipX(!spearman.getData('isPlayer'));
                     }
                }
            }
        }
        // Handle attacking state when target becomes invalid (unchanged)
        else if (spearman.state === 'attacking' && (!spearman.attackTarget || !spearman.attackTarget.active)) {
             this.logDebug(`${side} spearman's target disappeared while attacking. Stopping.`);
             this.stopAttacking(spearman); spearman.state = 'idle';
        }
         // Safety check: If stuck in moving state without flag
         else if ((spearman.state === 'moving_to_attack' || spearman.state === 'moving_to_explore') && !spearman.moving) {
              this.logDebug(`${side} spearman stuck in ${spearman.state} without moving flag. Resetting to idle.`);
              spearman.state = 'idle'; spearman.target = null; spearman.setTexture('spearman_walk_sheet');
              spearman.anims.stop(); spearman.setFrame(0); spearman.setFlipX(!spearman.getData('isPlayer'));
         }
    }

    /**
     * Initiates a movement tween for a unit towards a specific point.
     * @param {Phaser.GameObjects.Sprite} unit - The worker or spearman to move.
     * @param {number} targetX - The destination x-coordinate.
     * @param {number} targetY - The destination y-coordinate.
     * @param {string} movingState - The state to set while moving (e.g., 'moving_to_explore').
     * @param {string} arrivalState - The state to set when the destination is reached (e.g., 'idle').
     */
    startUnitMove(unit, targetX, targetY, movingState, arrivalState) {
        if (!unit || !unit.active || unit.moving || unit.isCutting || unit.isBuilding || unit.isAttacking) return; // Don't move if busy

        const unitType = unit.getData('unitType');
        const side = unit.getData('isPlayer') ? 'Player' : 'AI';
        unit.state = movingState; // Set the specified moving state
        unit.moving = true;
        unit.target = null; // Clear any previous interaction target

        // Clamp target to game bounds (just in case)
        targetX = Phaser.Math.Clamp(targetX, 0, this.sys.game.config.width);
        targetY = Phaser.Math.Clamp(targetY, 0, this.sys.game.config.height);

        this.logDebug(`${side} ${unitType} moving to (${Math.round(targetX)}, ${Math.round(targetY)}). State: ${movingState}`);

        const speed = (unitType === 'worker') ? 100 : 80; // Workers move faster
        const distance = Phaser.Math.Distance.Between(unit.x, unit.y, targetX, targetY);
        const moveDuration = (distance / speed) * 1000 || 1;
        const animKey = (unitType === 'worker') ? 'worker_walk' : 'spearman_walk';

        unit.anims.play(animKey, true);
        if (targetX < unit.x) unit.setFlipX(true); else unit.setFlipX(false);

        // Start walk sound if needed (checking other units)
        if (this.workerWalkSound && !this.workerWalkSound.isPlaying) {
             let pWorkerMoving = this.worker && this.worker.active && this.worker.moving && this.worker !== unit;
             let aWorkerMoving = this.aiWorker && this.aiWorker.active && this.aiWorker.moving && this.aiWorker !== unit;
             let otherSpearmanMoving = this.playerSpearmen.some(s => s.active && s !== unit && s.moving) || this.aiSpearmen.some(s => s.active && s !== unit && s.moving);
             if (!pWorkerMoving && !aWorkerMoving && !otherSpearmanMoving) this.workerWalkSound.play({ loop: true });
         }

        this.tweens.add({
            targets: unit,
            x: targetX,
            y: targetY,
            duration: moveDuration,
            ease: 'Linear',
            onComplete: () => {
                if (!unit.active || unit.state !== movingState) return; // Check state
                unit.moving = false;
                unit.state = arrivalState; // Set the specified arrival state
                unit.anims.stop();
                unit.setTexture(unitType === 'worker' ? 'worker_sheet' : 'spearman_walk_sheet');
                unit.setFrame(0);
                // Reset facing: workers default right, spearmen face opponent side
                unit.setFlipX(unitType === 'spearman' ? !unit.getData('isPlayer') : false);
                this.logDebug(`${side} ${unitType} finished move, now ${arrivalState}.`);
                // Stop walk sound if needed
                if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                     let pWorkerMoving = this.worker && this.worker.active && this.worker.moving;
                     let aWorkerMoving = this.aiWorker && this.aiWorker.active && this.aiWorker.moving;
                     let otherSpearmanMoving = this.playerSpearmen.some(s => s.active && s.moving) || this.aiSpearmen.some(s => s.active && s.moving);
                     if (!pWorkerMoving && !aWorkerMoving && !otherSpearmanMoving) this.workerWalkSound.stop();
                 }
            },
            onStop: () => {
                if (!unit.active) return;
                const wasMoving = unit.moving;
                unit.moving = false;
                if (unit.state === movingState) { // Only reset if still in this state
                    unit.state = 'idle'; // Default to idle if interrupted
                    unit.anims.stop();
                    unit.setTexture(unitType === 'worker' ? 'worker_sheet' : 'spearman_walk_sheet');
                    unit.setFrame(0);
                    unit.setFlipX(unitType === 'spearman' ? !unit.getData('isPlayer') : false);
                    this.logDebug(`${side} ${unitType} move (${movingState}) interrupted, going idle.`);
                }
                // Stop walk sound if needed
                if (this.workerWalkSound && this.workerWalkSound.isPlaying && wasMoving) {
                     let pWorkerMoving = this.worker && this.worker.active && this.worker.moving;
                     let aWorkerMoving = this.aiWorker && this.aiWorker.active && this.aiWorker.moving;
                     let otherSpearmanMoving = this.playerSpearmen.some(s => s.active && s.moving) || this.aiSpearmen.some(s => s.active && s.moving);
                     if (!pWorkerMoving && !aWorkerMoving && !otherSpearmanMoving) this.workerWalkSound.stop();
                 }
            }
        });
    }


    // --- END COMBAT & MOVEMENT ---


    /**
     * Game loop update function. Runs continuously.
     */
    update(time, delta) {
        if (!this.gameStarted || this.gameOver) return;

        // --- Update Fog of War based on unit positions ---
        const allUnits = [this.worker, this.aiWorker, ...this.playerSpearmen, ...this.aiSpearmen];
        allUnits.forEach(unit => {
            if (unit && unit.active) {
                this.updateVisibilityAround(unit); // Use the updated function
            }
        });
        // Buildings reveal once on creation/completion, no need to update FoW for them every frame

        // --- Handle States ---
        if (this.worker && this.worker.active) this.handleWorkerState(this.worker);
        if (this.aiWorker && this.aiWorker.active) this.handleWorkerState(this.aiWorker);
        this.handleBarrackTraining(this.playerBarrack, true);
        this.handleBarrackTraining(this.aiBarrack, false);
        this.playerSpearmen.forEach(s => { if (s.active) this.handleSpearmanState(s); });
        this.aiSpearmen.forEach(s => { if (s.active) this.handleSpearmanState(s); });

        // --- Unit Cleanup --- (Unchanged)
        this.playerSpearmen = this.playerSpearmen.filter(s => s.active);
        this.aiSpearmen = this.aiSpearmen.filter(s => s.active);

        // --- Depth Sorting & Visual Updates --- (Unchanged)
        const depthSortedSprites = [];
        if (this.worker && this.worker.active) depthSortedSprites.push(this.worker);
        if (this.aiWorker && this.aiWorker.active) depthSortedSprites.push(this.aiWorker);
        if (this.house && this.house.active) depthSortedSprites.push(this.house);
        if (this.aiHouse && this.aiHouse.active) depthSortedSprites.push(this.aiHouse);
        if (this.playerBarrack && this.playerBarrack.active) depthSortedSprites.push(this.playerBarrack);
        if (this.aiBarrack && this.aiBarrack.active) depthSortedSprites.push(this.aiBarrack);
        this.playerSpearmen.forEach(s => { if (s.active) depthSortedSprites.push(s); });
        this.aiSpearmen.forEach(s => { if (s.active) depthSortedSprites.push(s); });
        if (this.trees) { this.trees.getChildren().forEach(tree => { if (tree.active) { depthSortedSprites.push(tree); if(tree.healthBarBg) this.updateTreeHealthBar(tree); } else { this.destroyTreeHealthBar(tree); } }); }
        depthSortedSprites.sort((a, b) => { const yA = a.y; const yB = b.y; if (yA < yB) return -1; if (yA > yB) return 1; return 0; });
        depthSortedSprites.forEach((sprite, index) => {
             if (sprite.active) {
                 sprite.setDepth(index);
                 if (sprite.healthBarBg) { this.updateHealthBar(sprite); sprite.healthBarBg.setDepth(index + 1); sprite.healthBarFill.setDepth(index + 2); }
                 if (sprite.trainingText) { this.updateTrainingText(sprite); sprite.trainingText.setDepth(index + 10); }
             }
        });

        // --- Target Invalidation Checks --- (Unchanged)
        [this.worker, this.aiWorker].forEach( w => {
            if (!w || !w.active) return;
            if (w.moving && w.target && w.state === 'moving_to_chop' && !w.target.active) { const workerType = w.getData('isPlayer') ? "Player" : "AI"; this.logDebug(`${workerType} target tree disappeared during move.`); this.tweens.killTweensOf(w); }
             if (w.moving && w.target && w.state === 'moving_to_build' && !w.target.active) { const workerType = w.getData('isPlayer') ? "Player" : "AI"; this.logDebug(`${workerType} build target disappeared during move.`); this.tweens.killTweensOf(w); }
        });

    } // End update()
  } // End DemoScene Class

  /**
   * Phaser game configuration object. (Unchanged)
   */
  const config = { /* ... same as before ... */
    type: Phaser.AUTO, width: 800, height: 600, parent: 'phaser-game-container',
    physics: { default: 'arcade', arcade: { debug: false } },
    scene: [DemoScene],
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
    render: { pixelArt: true }
  };

  // Create a new Phaser game instance when the window loads (Unchanged)
  window.onload = () => { const game = new Phaser.Game(config); };

</script>
</body>
</html>
