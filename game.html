<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Simple RTS Demo with Worker Animation</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <style>
    body { margin: 0; background-color: #333; }
    canvas { display: block; margin: 20px auto; border-radius: 8px; }
  </style>
</head>
<body>
<script>
  class DemoScene extends Phaser.Scene {
    constructor() {
      super({ key: 'DemoScene' });
      this.wood = 0;
      this.worker = null;
      this.trees = null;
      this.house = null;
      this.woodText = null;
      this.debugText = null;
    }

    preload() {
      this.load.spritesheet('worker_sheet', 'https://grantchen08.github.io/nezha/worker_walk.png', {
          frameWidth: 32,
          frameHeight: 64
      });
      this.load.image('tree', 'https://raw.githubusercontent.com/photonstorm/phaser3-examples/master/public/assets/sprites/tree.png');
      this.load.image('house', 'https://raw.githubusercontent.com/photonstorm/phaser3-examples/master/public/assets/sprites/house.png');
      this.load.on('loaderror', (file) => {
          console.error(`Error loading asset: ${file.key} from ${file.url}`);
          if (this.debugText) {
            this.debugText.setText(`Debug Output:\nError loading ${file.key}`);
          }
      });
    }

    create() {
      this.cameras.main.setBackgroundColor('#228B22'); // Set background to dark green

      this.wood = 0;
      this.woodText = this.add.text(10, 10, 'Wood: 0', { font: '16px Arial', fill: '#ffffff' });

      this.debugText = this.add.text(10, 40, 'Debug Output:', {
        font: '14px Arial',
        fill: '#ffffff',
        wordWrap: { width: 200 }
      });
      this.debugText.setText("Debug Output:\nGame started. Click worker to select.");

      this.house = this.add.image(100, 500, 'house');
      this.house.setScale(0.5);

      this.worker = this.add.sprite(this.sys.game.config.width / 2, this.sys.game.config.height / 2, 'worker_sheet');
      this.worker.setFrame(0);
      this.worker.setInteractive();
      this.worker.selected = false;
      this.worker.moving = false;
      this.worker.target = null;
      // this.worker.setScale(2);

      this.anims.create({
          key: 'walk',
          frames: this.anims.generateFrameNumbers('worker_sheet', { start: 0, end: 3 }),
          frameRate: 8,
          repeat: -1
      });

      this.worker.on('pointerdown', (pointer) => {
        if (!this.worker.moving) {
          this.worker.selected = true;
          this.worker.setTint(0xffff00);
          this.debugText.setText("Debug Output:\nWorker clicked and selected.\nClick a tree to send worker.");
        }
      });

      this.input.on('pointerdown', (pointer, gameObjects) => {
        if (gameObjects.length === 0 && this.worker.selected && !this.worker.moving) {
          this.worker.selected = false;
          this.worker.clearTint();
          this.debugText.setText("Debug Output:\nBackground clicked. Worker deselected.");
        }
      });

      this.trees = this.add.group();
      const treeCount = 20;
      for (let i = 0; i < treeCount; i++) {
        let x = Phaser.Math.Between(50, this.sys.game.config.width - 50);
        let y = Phaser.Math.Between(50, this.sys.game.config.height - 100);
        if (Phaser.Math.Distance.Between(x, y, this.house.x, this.house.y) < 100) {
            i--; continue;
        }
        let tree = this.add.image(x, y, 'tree');
        tree.setInteractive();
        tree.woodValue = 10;
        this.trees.add(tree);

        tree.on('pointerdown', () => {
          if (this.worker.selected && !this.worker.moving) {
            this.worker.target = tree;
            this.worker.moving = true;
            this.worker.selected = false;
            this.worker.clearTint();
            this.debugText.setText(`Debug Output:\nTree clicked. Moving worker to (${Math.round(tree.x)}, ${Math.round(tree.y)}).`);

            const distance = Phaser.Math.Distance.Between(this.worker.x, this.worker.y, tree.x, tree.y);
            const speed = 100;
            const duration = (distance / speed) * 1000;

            this.worker.anims.play('walk', true);

            if (tree.x < this.worker.x) {
                this.worker.setFlipX(false);
            } else {
                this.worker.setFlipX(true);
            }

            this.tweens.add({
              targets: this.worker,
              x: tree.x,
              y: tree.y,
              duration: duration,
              ease: 'Linear',
              onComplete: () => {
                this.worker.anims.stop();
                this.worker.setFrame(0);
                this.worker.setFlipX(false);
                this.startCutting(tree);
              }
            });
          }
        });
      }
    }

    startCutting(tree) {
      if (!tree || !tree.active) {
          this.worker.moving = false;
          this.worker.target = null;
          this.debugText.setText(`Debug Output:\nTarget tree no longer exists.`);
          this.worker.anims.stop();
          this.worker.setFrame(0);
          return;
      }

      this.debugText.setText(`Debug Output:\nWorker reached tree at (${Math.round(tree.x)}, ${Math.round(tree.y)}). Cutting tree...`);

      const barWidth = 40;
      const barHeight = 8;
      const barYOffset = tree.height ? tree.height / 2 + 5 : 30;

      const progressBarBackground = this.add.rectangle(
          tree.x, tree.y + barYOffset, barWidth, barHeight, 0x333333
      ).setOrigin(0.5);

      const progressBar = this.add.rectangle(
          tree.x - barWidth / 2, tree.y + barYOffset, 0, barHeight, 0x00ff00
      ).setOrigin(0, 0.5);

      if (tree.active) {
          tree.progressBar = progressBar;
          tree.progressBarBackground = progressBarBackground;
      } else {
          progressBar.destroy();
          progressBarBackground.destroy();
          this.worker.moving = false;
          this.worker.target = null;
          this.worker.anims.stop();
          this.worker.setFrame(0);
          this.debugText.setText(`Debug Output:\nTree disappeared before cutting started.`);
          return;
      }

      let progressObj = { progress: 0 };

      this.tweens.add({
        targets: progressObj,
        progress: 1,
        duration: 5000,
        ease: 'Linear',
        onUpdate: () => {
           if (progressBar && progressBar.active) {
               progressBar.width = progressObj.progress * barWidth;
           }
        },
        onComplete: () => {
          if (progressBar && progressBar.active) progressBar.destroy();
          if (progressBarBackground && progressBarBackground.active) progressBarBackground.destroy();

          if (tree && tree.active) {
              this.cutTree(tree);
              this.debugText.setText(`Debug Output:\nTree at (${Math.round(tree.x)}, ${Math.round(tree.y)}) cut. Wood: ${this.wood}`);
          } else {
              this.debugText.setText(`Debug Output:\nTree cutting finished, but tree was already gone.`);
          }

          this.worker.moving = false;
          this.worker.target = null;
          this.worker.anims.stop();
          this.worker.setFrame(0);
          this.worker.setFlipX(false);
        }
      });
    }

    cutTree(tree) {
      if (!tree || !tree.active) {
        console.warn("Attempted to cut an invalid or inactive tree.");
        return;
      }
      this.wood += tree.woodValue;
      this.woodText.setText('Wood: ' + this.wood);
      this.trees.remove(tree, true, true);

      const winAmount = 100;
      if (this.wood >= winAmount) {
        this.add.text(this.sys.game.config.width / 2, this.sys.game.config.height / 2,
                      `You win!\nCollected ${winAmount} wood!`,
                      { font: '32px Arial', fill: '#ffff00', align: 'center' })
                      .setOrigin(0.5);
        this.input.enabled = false;
      }
    }

    update(time, delta) {
        if (this.worker.moving && this.worker.target && !this.worker.target.active) {
            console.log("Target destroyed during movement, stopping worker.");
            this.tweens.killTweensOf(this.worker);
            this.worker.anims.stop();
            this.worker.setFrame(0);
            this.worker.setFlipX(false);
            this.worker.moving = false;
            this.worker.target = null;
            this.debugText.setText(`Debug Output:\nTarget tree disappeared. Worker stopped.`);
        }
    }
  }

  const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    physics: {
        default: 'arcade',
        arcade: { debug: false }
    },
    scene: [DemoScene]
  };

  const game = new Phaser.Game(config);
</script>
</body>
</html>
