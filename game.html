<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Simple RTS Demo with Worker Animation</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <style>
    /* Basic styling for the body and canvas */
    body { margin: 0; background-color: #333; display: flex; justify-content: center; align-items: center; min-height: 100vh; position: relative; } /* Added position relative */
    canvas { display: block; margin: 20px auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
    /* Style for the start overlay */
    #start-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        font-size: 24px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        z-index: 10000; /* Ensure it's on top */
        font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
<div id="start-overlay">Click or Tap to Start</div>

<script>
  // Global Constants
  const BARRACK_WOOD_COST = 50;
  const PLAYER_HEALTH_BAR_COLOR = 0x00ff00; // Green for player units/buildings
  const AI_HEALTH_BAR_COLOR = 0xff0000; // Red for AI units/buildings
  const BUILDING_HEALTH_BAR_WIDTH = 32; // Width for building health bars
  const UNIT_HEALTH_BAR_WIDTH = 28; // Width for unit health bars

  /**
   * Represents the main scene for the RTS demo.
   * Handles game logic, asset loading, and rendering.
   */
  class DemoScene extends Phaser.Scene {
    constructor() {
      super({ key: 'DemoScene' });
      // Game state variables
      this.wood = 0; // Player's wood count
      this.aiWood = 0; // AI's wood count
      this.worker = null; // The player-controlled worker sprite
      this.house = null; // The player house sprite
      this.aiHouse = null; // AI house sprite
      this.aiWorker = null; // AI worker sprite
      this.trees = null; // Group containing tree sprites
      this.playerBarrack = null; // Reference to the player's barrack building
      this.playerBarrackBuilding = false; // Flag: Is the player barrack currently under construction?
      this.aiBarrack = null; // Reference to the AI's barrack building
      this.aiBarrackBuilding = false; // Flag: Is the AI barrack currently under construction?
      this.woodText = null; // Text object to display player wood count
      this.aiWoodText = null; // Text object to display AI wood count
      this.debugText = null; // Text object for displaying debug messages
      this.workerWalkSound = null; // Sound effect for worker walking
      this.chopSound = null; // Sound effect for chopping
      this.gameStarted = false; // Flag to prevent logic running before start
      this.gameOver = false; // Flag to prevent multiple end game calls
      this.selectedWorker = null; // Keep track of the selected worker
      this.objectClickedRecently = false; // Flag to prevent immediate background click after object click
      this.debugHistory = []; // Array to store debug message history
      this.maxDebugHistory = 10; // Max number of debug messages to keep
    }

    /**
     * Logs a message to the on-screen debug area, maintaining a history.
     * @param {string} message The message to log.
     */
    logDebug(message) {
        if (!message) return; // Ignore empty messages

        // Add the new message to the history
        // Add timestamp for clarity
        const time = new Date();
        const timestamp = `${time.getHours()}:${String(time.getMinutes()).padStart(2, '0')}:${String(time.getSeconds()).padStart(2, '0')}`;
        this.debugHistory.push(`[${timestamp}] ${message}`);


        // If history exceeds the max size, remove the oldest message (FIFO)
        if (this.debugHistory.length > this.maxDebugHistory) {
            this.debugHistory.shift();
        }

        // Update the on-screen debug text if it exists
        if (this.debugText && this.debugText.visible) { // Only update if visible
            this.debugText.setText('Debug Output:\n' + this.debugHistory.join('\n'));
        }
         // Also log to console for easier debugging
        console.log("DEBUG:", message);
    }


    /**
     * Preloads game assets (images, spritesheets, audio).
     * This function runs before the 'create' function.
     */
    preload() {
      // Load the worker spritesheet
      this.load.spritesheet('worker_sheet', 'https://grantchen08.github.io/nezha/worker_walk.png', {
          frameWidth: 32,
          frameHeight: 64
      });
      // Load the worker chopping spritesheet
      this.load.spritesheet('worker_chop_sheet', 'https://grantchen08.github.io/nezha/worker_chop.png', {
          frameWidth: 64,
          frameHeight: 64
      });
       // Load the barrack image
      this.load.image('barrack', 'https://grantchen08.github.io/nezha/barrack.png');
      // Load the walking sound effect
      this.load.audio('worker_walk', 'https://grantchen08.github.io/nezha/worker_walk.mp3');
      // Load the tree spritesheet
      this.load.spritesheet('tree_sheet', 'https://grantchen08.github.io/nezha/tree.png', {
          frameWidth: 64,
          frameHeight: 64
      });
      // Load the house image
      this.load.image('house', 'https://grantchen08.github.io/nezha/house.png');
      // Load the chopping sound effect
      this.load.audio('chop_sound', 'https://grantchen08.github.io/nezha/chop_tree.mp3');

      // Basic error handling for asset loading
      this.load.on('loaderror', (file) => {
          const errorMsg = `Error loading ${file.key}`;
          console.error(`Error loading asset: ${file.key} from ${file.url}`);
          this.logDebug(errorMsg); // Use new log function
      });
    }

    /**
     * Creates game objects and initializes the scene.
     * This function runs once after 'preload' is complete.
     */
    create() {
      const gameWidth = this.sys.game.config.width;
      const gameHeight = this.sys.game.config.height;

      // Set background color
      this.cameras.main.setBackgroundColor('#228B22'); // Forest green

      // Initialize wood counts and display text
      this.wood = 0; // Start with 0 wood
      this.aiWood = 0;
      this.woodText = this.add.text(10, 10, 'Wood: 0', { font: '16px Arial', fill: '#ffffff' });
      this.woodText.setDepth(1000);
      this.aiWoodText = this.add.text(gameWidth - 10, 10, 'AI Wood: 0', { font: '16px Arial', fill: '#ffffff' })
          .setOrigin(1, 0) // Align to top-right
          .setDepth(1000);


      // Initialize debug text display area
      this.debugText = this.add.text(10, 40, 'Debug Output:', {
        font: '14px Arial',
        fill: '#ffffff',
        wordWrap: { width: 200 },
        lineSpacing: 4 // Add some spacing between lines
      });
      this.debugText.setDepth(1000);
      this.debugText.visible = false; // Start hidden
      this.logDebug("Click overlay to start."); // Log initial message even if hidden


      // --- Player House Setup ---
      this.house = this.add.image(100, gameHeight - 100, 'house'); // Bottom-left
      this.house.setOrigin(0.5, 1);
      this.house.health = 50;
      this.house.maxHealth = 50;
      this.createHealthBar(this.house, BUILDING_HEALTH_BAR_WIDTH, PLAYER_HEALTH_BAR_COLOR); // Use constants

      // --- Player Worker Setup ---
      this.worker = this.add.sprite(150, gameHeight - 150, 'worker_sheet').setOrigin(0.5, 1); // Near player house
      this.worker.setFrame(0);
      this.worker.state = 'idle'; // Start idle until game starts
      this.worker.moving = false;
      this.worker.target = null; // Target object (tree or build site marker)
      this.worker.isCutting = false;
      this.worker.cuttingTarget = null; // Specific tree being cut
      this.worker.cuttingTimer = null; // Timer stored on worker
      this.worker.isBuilding = false; // Is the worker currently building?
      this.worker.buildingTarget = null; // Specific building being built
      this.worker.buildingTimer = null; // Timer for building progress
      this.worker.health = 10;
      this.worker.maxHealth = 10;
      this.worker.initialChopHealth = null; // Store tree health when starting chop
      this.createHealthBar(this.worker, UNIT_HEALTH_BAR_WIDTH, PLAYER_HEALTH_BAR_COLOR); // Use constants
      this.worker.setInteractive(); // Make the worker clickable

      // --- AI House Setup ---
      this.aiHouse = this.add.image(gameWidth - 100, gameHeight - 100, 'house'); // Bottom-right
      this.aiHouse.setOrigin(0.5, 1);
      this.aiHouse.health = 50;
      this.aiHouse.maxHealth = 50;
      this.createHealthBar(this.aiHouse, BUILDING_HEALTH_BAR_WIDTH, AI_HEALTH_BAR_COLOR); // Use constants

      // --- AI Worker Setup ---
      this.aiWorker = this.add.sprite(gameWidth - 150, gameHeight - 150, 'worker_sheet').setOrigin(0.5, 1); // Near AI house
      this.aiWorker.setFrame(0);
      this.aiWorker.state = 'idle'; // Start idle until game starts
      this.aiWorker.moving = false;
      this.aiWorker.target = null;
      this.aiWorker.isCutting = false;
      this.aiWorker.cuttingTarget = null;
      this.aiWorker.cuttingTimer = null; // Timer stored on worker
      this.aiWorker.isBuilding = false; // AI building flag
      this.aiWorker.buildingTarget = null; // AI building target
      this.aiWorker.buildingTimer = null; // AI building timer
      this.aiWorker.health = 10;
      this.aiWorker.maxHealth = 10;
      this.aiWorker.initialChopHealth = null; // Store tree health when starting chop
      this.createHealthBar(this.aiWorker, UNIT_HEALTH_BAR_WIDTH, AI_HEALTH_BAR_COLOR); // Use constants
      // AI worker is not interactive for the player


      // Load sounds (shared)
      this.workerWalkSound = this.sound.add('worker_walk');
      this.chopSound = this.sound.add('chop_sound');

      // Create animations (shared)
      this.anims.create({
          key: 'walk',
          frames: this.anims.generateFrameNumbers('worker_sheet', { start: 0, end: 1 }), // Updated end frame to 1 for 2x1 grid
          frameRate: 8,
          repeat: -1
      });
      this.anims.create({
          key: 'chop', // Used for both chopping and building
          frames: this.anims.generateFrameNumbers('worker_chop_sheet', { start: 0, end: 1 }),
          frameRate: 4,
          repeat: -1
      });

      // --- Tree Setup ---
      this.trees = this.add.group();
      const treeCount = 20;
      for (let i = 0; i < treeCount; i++) {
        // Avoid spawning too close to *either* house base area
        let x, y;
        let tooClose;
        do {
            x = Phaser.Math.Between(50, gameWidth - 50);
            y = Phaser.Math.Between(50, gameHeight - 100); // Keep trees away from bottom edge a bit more

            const playerHouseDist = Phaser.Math.Distance.Between(x, y, this.house.x, this.house.y - this.house.height / 2);
            const aiHouseDist = Phaser.Math.Distance.Between(x, y, this.aiHouse.x, this.aiHouse.y - this.aiHouse.height / 2);
            const houseRadius = Math.max(this.house.width, this.house.height) / 2 + 36; // Use displayWidth/Height?

            tooClose = (playerHouseDist < houseRadius * 1.5) || (aiHouseDist < houseRadius * 1.5); // Increase buffer slightly

        } while (tooClose);


        let tree = this.add.sprite(x, y, 'tree_sheet').setOrigin(0.5, 1);
        tree.setFrame(0);
        tree.health = 10; // Initial health
        tree.maxHealth = 10; // Max health
        this.trees.add(tree);
        tree.setInteractive(); // Make trees clickable
      }

       // --- Input Handling ---
       this.input.on('gameobjectdown', this.handleObjectClick, this);
       this.input.on('pointerdown', this.handleBackgroundClick, this);
       // Add listener for the 'D' key
       this.input.keyboard.on('keydown-D', this.toggleDebugDisplay, this);
       // Add listener for 's' key (lowercase) to speed up
       this.input.keyboard.on('keydown-S', (event) => {
            if (event.shiftKey) { // Check if Shift is held for uppercase 'S'
                this.changeTimeScale(0.5); // Slow down
            } else {
                this.changeTimeScale(2); // Speed up (lowercase 's')
            }
       });


       // --- Start Overlay Logic ---
       const overlay = document.getElementById('start-overlay');
       if (overlay) {
            overlay.addEventListener('pointerdown', () => {
                if (!this.gameStarted && !this.gameOver) { // Ensure game not already over
                    overlay.style.display = 'none';
                    if (this.sound.context.state === 'suspended') {
                        this.sound.context.resume().then(() => {
                            console.log('Audio Context resumed!');
                            this.startGameLogic();
                        }).catch(e => console.error('Error resuming audio context:', e));
                    } else {
                         this.startGameLogic();
                    }
                }
            }, { once: true });
       } else {
            console.warn("Start overlay not found!");
            this.startGameLogic(); // Attempt to start anyway if overlay missing
       }
    }

    /**
     * Changes the game's time scale.
     * @param {number} factor - The factor to multiply the current time scale by (e.g., 2 to double, 0.5 to halve).
     */
    changeTimeScale(factor) {
        if (this.gameOver || !this.gameStarted) return; // Don't change speed if game not running

        // Ensure factor is positive
        if (factor <= 0) {
            this.logDebug("Invalid time scale factor.");
            return;
        }

        this.time.timeScale *= factor;

        // Optional: Clamp the time scale to reasonable limits
        this.time.timeScale = Phaser.Math.Clamp(this.time.timeScale, 0.125, 8); // e.g., min 1/8, max 8x speed

        this.logDebug(`Time scale set to ${this.time.timeScale.toFixed(3)}x`);

        // Adjust sound playback rates if desired (more complex, might need individual sound adjustment)
        // Example (adjusting global sound playback rate - might affect pitch):
        // this.sound.setRate(this.time.timeScale);
    }

    /**
     * Toggles the visibility of the debug text area.
     */
    toggleDebugDisplay() {
        if (this.debugText) {
            this.debugText.visible = !this.debugText.visible;
            // Optionally log the toggle action itself (if debug is visible)
            if (this.debugText.visible) {
                 this.logDebug(`Debug display toggled ON`);
                 // Refresh text content when turned on
                 this.debugText.setText('Debug Output:\n' + this.debugHistory.join('\n'));
            } else {
                 // If turning off, log to console instead
                 console.log("DEBUG: Debug display toggled OFF");
            }
        }
    }

    /**
     * Handles clicks on interactive game objects (worker, trees).
     */
    handleObjectClick(pointer, gameObject) {
        if (this.gameOver || !this.gameStarted) return; // Ignore clicks if game over or not started
        this.objectClickedRecently = true; // Set the flag immediately
        this.logDebug(`Clicked ${gameObject.texture?.key || 'unknown object'}`);

        if (this.selectedWorker) {
            // --- Worker is already selected ---
            if (gameObject === this.selectedWorker) {
                // Clicked the selected worker again: Deselect
                this.logDebug('Worker deselected.');
                this.selectedWorker.clearTint();
                this.selectedWorker = null;
            } else if (gameObject.texture?.key === 'tree_sheet' && this.trees.contains(gameObject)) {
                // Clicked a tree while worker selected: Check if tree is busy
                const targetTree = gameObject;
                // Check if this specific tree is currently being cut by any worker
                const isPlayerChoppingThis = this.worker.isCutting && this.worker.cuttingTarget === targetTree;
                const isAiChoppingThis = this.aiWorker.isCutting && this.aiWorker.cuttingTarget === targetTree;
                // Also check if another worker is moving specifically to chop this tree
                const isPlayerMovingToChopThis = this.worker.moving && this.worker.target === targetTree && this.worker.state === 'moving_to_chop';
                const isAiMovingToChopThis = this.aiWorker.moving && this.aiWorker.target === targetTree && this.aiWorker.state === 'moving_to_chop';


                if (isPlayerChoppingThis || isAiChoppingThis || isPlayerMovingToChopThis || isAiMovingToChopThis) {
                    // Tree is busy or targeted - flash red and do nothing else
                    this.logDebug('Invalid command: Tree is busy or targeted.');
                    targetTree.setTintFill(0xff0000); // Red tint fill
                    this.time.delayedCall(250, () => { // Remove tint after short delay
                        if (targetTree.active) { // Check if tree still exists
                             targetTree.clearTint();
                        }
                    });
                    // Keep worker selected
                } else {
                    // Tree is available: Command worker to chop
                    const workerToCommand = this.selectedWorker;
                    this.logDebug('Commanding worker to chop selected tree.');
                    this.sendWorkerToTree(workerToCommand, targetTree);
                    // Deselect after issuing command
                    workerToCommand.clearTint();
                    this.selectedWorker = null;
                }
            } else {
                // Clicked something else interactive while worker selected: Deselect
                this.logDebug('Clicked other object. Deselecting worker.');
                this.selectedWorker.clearTint();
                this.selectedWorker = null;
            }
        } else {
            // --- No worker currently selected ---
            if (gameObject === this.worker) {
                // Clicked the worker: Select it
                this.logDebug('Worker selected. Applying tint.');
                gameObject.setTint(0x00ffff); // Apply bright cyan tint
                this.selectedWorker = gameObject;
            } else {
                // Clicked something else (like a tree) when no worker selected: Do nothing
                this.logDebug('Clicked object, but no worker selected.');
            }
        }
    }


    /**
     * Handles clicks on the background (not on an interactive object).
     */
    handleBackgroundClick(pointer) {
        if (this.gameOver || !this.gameStarted) return; // Ignore clicks if game over or not started

        // Check the flag first
        if (this.objectClickedRecently) {
            this.objectClickedRecently = false; // Reset flag
            this.logDebug('BG click ignored (object clicked).');
            return; // Exit early, do not process this background click
        }

        this.logDebug('Pointer down detected.');

        // Check if the click was not on any interactive game object
        if (!pointer.targetObject) {
             this.logDebug('Clicked background.');

            // If a worker is selected, issue move command
            if (this.selectedWorker) {
                const workerToMove = this.selectedWorker;
                const targetX = pointer.worldX;
                const targetY = pointer.worldY;

                this.logDebug(`Move command issued to (${Math.round(targetX)}, ${Math.round(targetY)})`);

                // --- Show flashing marker ---
                const clickMarker = this.add.circle(targetX, targetY, 10, 0xff0000, 0.8).setDepth(3000);
                 this.tweens.add({
                     targets: clickMarker,
                     alpha: 0,
                     duration: 1000, // 1 second duration
                     ease: 'Power1',
                     onComplete: () => {
                         if(clickMarker.active) clickMarker.destroy();
                     }
                 });

                // --- Stop current actions ---
                 this.logDebug('Stopping current worker actions for move command.');
                if (workerToMove.isCutting) {
                    this.stopCutting(workerToMove); // Handles partial wood
                }
                if (workerToMove.isBuilding) { // NEW: Stop building if moving
                    this.stopBuilding(workerToMove);
                }
                if (workerToMove.moving) {
                    this.tweens.killTweensOf(workerToMove); // Stop existing movement
                    workerToMove.moving = false;
                    workerToMove.target = null; // Clear old target
                    // Reset visuals immediately after stopping tween
                    workerToMove.setTexture('worker_sheet');
                    workerToMove.anims.stop();
                    workerToMove.setFrame(0);
                    workerToMove.setFlipX(false); // Default to right
                     // Stop walk sound if needed
                     if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                         let otherWorker = this.aiWorker;
                         if (!otherWorker || !otherWorker.moving) {
                              this.workerWalkSound.stop();
                         }
                    }
                }
                // Clear any potential targets
                workerToMove.cuttingTarget = null;
                workerToMove.buildingTarget = null;
                workerToMove.initialChopHealth = null;


                // --- Start new movement to clicked point ---
                workerToMove.state = 'moving_to_idle'; // Set a specific state
                const distance = Phaser.Math.Distance.Between(workerToMove.x, workerToMove.y, targetX, targetY);
                const speed = 100; // Pixels per second
                const duration = (distance / speed) * 1000 || 1; // Ensure duration > 0

                // Ensure walk animation plays and sprite is flipped correctly for the new path
                workerToMove.anims.play('walk', true);
                if (targetX < workerToMove.x) {
                    workerToMove.setFlipX(true); // Moving left
                } else {
                    workerToMove.setFlipX(false); // Moving right
                }
                workerToMove.moving = true; // Set moving flag for the new movement

                 // Start walk sound if needed
                 if (this.workerWalkSound && !this.workerWalkSound.isPlaying) {
                     // Check if AI is also moving
                     let otherWorker = this.aiWorker;
                     if (!otherWorker || !otherWorker.moving) { // Start only if AI isn't moving
                          this.workerWalkSound.play({ loop: true });
                     }
                 }

                // Start the actual movement tween
                this.tweens.add({
                    targets: workerToMove,
                    x: targetX,
                    y: targetY,
                    duration: duration,
                    ease: 'Linear',
                    onComplete: () => {
                        // Check if worker still exists and is in the correct state
                        if (!workerToMove.active || workerToMove.state !== 'moving_to_idle') return;

                        workerToMove.moving = false;
                        workerToMove.state = 'idle';
                        workerToMove.setTexture('worker_sheet');
                        workerToMove.anims.stop();
                        workerToMove.setFrame(0);
                        workerToMove.setFlipX(false); // Reset flip to default right on arrival
                        this.logDebug('Worker reached destination and is idle.');
                        // Stop walk sound if needed
                        if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                             let otherWorker = this.aiWorker; // Only AI could be moving now
                             if (!otherWorker || !otherWorker.moving) {
                                  this.workerWalkSound.stop();
                             }
                        }
                    },
                    onStop: () => { // Handle interruption of *this specific* move
                         if (!workerToMove.active) return;
                         // If interrupted, just go idle where it stopped
                         workerToMove.moving = false;
                         if (workerToMove.state === 'moving_to_idle') { // Only change state if it was still moving to idle
                             workerToMove.state = 'idle';
                             workerToMove.setTexture('worker_sheet');
                             workerToMove.anims.stop();
                             workerToMove.setFrame(0);
                             workerToMove.setFlipX(false);
                             this.logDebug('Worker move interrupted, going idle.');
                         }
                         // Stop walk sound if needed
                         if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                             let otherWorker = this.aiWorker;
                             if (!otherWorker || !otherWorker.moving) {
                                  this.workerWalkSound.stop();
                             }
                         }
                    }
                });

                // Deselect the worker visually and logically AFTER issuing the command
                workerToMove.clearTint();
                this.selectedWorker = null;


            } else {
                // No worker was selected, just log background click
                 this.logDebug('Clicked background (no worker selected).');
            }
        }
    }


    /**
     * Starts the main game logic after user interaction.
     */
    startGameLogic() {
        this.gameStarted = true;
        this.gameOver = false;
        // Don't automatically set state to chopping, let handleWorkerState decide
        this.worker.state = 'idle';
        this.aiWorker.state = 'idle';
        this.logDebug("Game started.");
        console.log("Game logic started.");
    }


    /**
     * Creates health bar graphics for a given unit.
     * @param {Phaser.GameObjects.Sprite | Phaser.GameObjects.Image} unit - The unit to add the health bar to.
     * @param {number} barWidth - The width of the health bar.
     * @param {number} barColor - The color of the health fill.
     */
     createHealthBar(unit, barWidth, barColor) {
        if (!unit) return;
        const barHeight = 8;
        // Use displayHeight if available, otherwise height
        const unitHeight = unit.displayHeight || unit.height || 64;
        const initialYOffset = -unitHeight - 5;
        const x = unit.x;
        const y = unit.y + initialYOffset;

        // Ensure previous bars are destroyed if they exist (e.g., recreating)
        if (unit.healthBarBg) unit.healthBarBg.destroy();
        if (unit.healthBarFill) unit.healthBarFill.destroy();

        unit.healthBarBg = this.add.rectangle(x, y, barWidth, barHeight, 0x333333).setOrigin(0.5);
        unit.healthBarFill = this.add.rectangle(x - barWidth / 2, y, barWidth, barHeight, barColor).setOrigin(0, 0.5);
        unit.healthBarWidth = barWidth; // Store the width on the unit

        // Explicitly set depth upon creation
        if (unit.healthBarBg) unit.healthBarBg.setDepth(unit.depth + 1);
        if (unit.healthBarFill) unit.healthBarFill.setDepth(unit.depth + 2);

        // Ensure health bars are initially drawn above the unit
        this.updateHealthBar(unit); // Call update to set initial position and fill correctly
      }

    /**
     * Creates a temporary health bar for the tree being cut.
     */
    createTreeHealthBar(tree) {
        if (!tree || !tree.active || tree.healthBarBg) return; // Don't create if it already exists or tree inactive

        const barWidth = 40; // Keep tree bar width separate
        const barHeight = 8;
        const yOffset = -tree.displayHeight - 5; // Use displayHeight
        const x = tree.x;
        const y = tree.y + yOffset;

        tree.healthBarBg = this.add.rectangle(x, y, barWidth, barHeight, 0x333333).setOrigin(0.5);
        tree.healthBarFill = this.add.rectangle(x - barWidth / 2, y, barWidth, barHeight, 0xffffff).setOrigin(0, 0.5); // White for tree
        tree.healthBarWidth = barWidth;

        // Explicitly set depth upon creation
        if (tree.healthBarBg) tree.healthBarBg.setDepth(tree.depth + 1);
        if (tree.healthBarFill) tree.healthBarFill.setDepth(tree.depth + 2);

        this.updateTreeHealthBar(tree); // Update position and fill immediately
    }

     /**
       * Updates the position and fill of a specific tree's health bar.
       */
      updateTreeHealthBar(tree) {
         if (!tree || !tree.active || !tree.healthBarBg || !tree.healthBarFill) {
              // If bar doesn't exist or tree inactive, attempt to destroy remnants
              this.destroyTreeHealthBar(tree);
              return;
         }
         const barWidth = tree.healthBarWidth;
         const yOffset = -tree.displayHeight - 5; // Use displayHeight
         const x = tree.x;
         const y = tree.y + yOffset;

         tree.healthBarBg.setPosition(x, y);
         tree.healthBarFill.setPosition(x - barWidth / 2, y);

         const fillWidth = Math.max(0, (tree.health / tree.maxHealth) * barWidth);
         tree.healthBarFill.width = fillWidth;

         // Ensure health bars are drawn above the tree
         tree.healthBarBg.setDepth(tree.depth + 1);
         tree.healthBarFill.setDepth(tree.depth + 2);
      }

    /**
     * Destroys the health bar associated with a specific tree.
     */
    destroyTreeHealthBar(tree) {
        if (tree) {
            if (tree.healthBarBg) {
                tree.healthBarBg.destroy();
                tree.healthBarBg = null;
            }
            if (tree.healthBarFill) {
                tree.healthBarFill.destroy();
                tree.healthBarFill = null;
            }
        }
    }


    /**
     * Damages the tree currently being cut by the specified worker. Called by timer.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker doing the cutting.
     */
     damageTree(workerSprite) {
        if (!this.gameStarted || this.gameOver || !workerSprite || !workerSprite.isCutting || !workerSprite.cuttingTarget || !workerSprite.cuttingTarget.active) {
            this.stopCutting(workerSprite); // Stop cutting for this specific worker if state is invalid
            return;
        }

        const tree = workerSprite.cuttingTarget;
        tree.health -= 1; // Reduce health by 1 each time

        this.updateTreeHealthBar(tree); // Update the bar visually

        if (tree.health <= 0) {
            // Tree is felled
            this.cutTree(tree, workerSprite); // Pass worker to cutTree
        } else if (tree.health <= 3.3) {
            tree.setFrame(2); // Show damaged frame
        } else if (tree.health <= 6.6) {
            tree.setFrame(1); // Show slightly damaged frame
        } else {
            tree.setFrame(0); // Full health frame
        }
      }

    /**
     * Stops the current cutting process for a specific worker and resets its state.
     * Handles partial wood collection if the tree is not fully cut.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker to stop.
     */
     stopCutting(workerSprite) {
        if (!workerSprite) return;

        const treeToStopCutting = workerSprite.cuttingTarget; // Store the target before resetting
        const initialHealth = workerSprite.initialChopHealth; // Get health when chop started
        let wasCutting = workerSprite.isCutting; // Check if it *was* cutting before resetting flags

        // Clear the specific worker's timer
        if (workerSprite.cuttingTimer) {
            workerSprite.cuttingTimer.remove(false); // false = don't call callback on remove
            workerSprite.cuttingTimer = null;
        }

        workerSprite.isCutting = false; // Set flag false now
        workerSprite.cuttingTarget = null; // Clear target
        workerSprite.initialChopHealth = null; // Reset initial health tracker

        // --- Sound Stop Logic ---
        if (this.chopSound && this.chopSound.isPlaying && wasCutting) {
            // Check if the *other* worker is still cutting OR building (uses same sound)
            let otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
            let otherBusySound = otherWorker && (otherWorker.isCutting || otherWorker.isBuilding);
            if (!otherBusySound) { // Stop only if other worker isn't making the same sound
                this.chopSound.stop();
            }
        }

        // Reset worker appearance (only if it was actually cutting)
        if(wasCutting) {
            workerSprite.setTexture('worker_sheet');
            workerSprite.anims.stop();
            workerSprite.setFrame(0);
            workerSprite.setFlipX(false); // Reset flip
        }

        // --- Partial Wood Collection & Health Bar ---
        if (wasCutting && treeToStopCutting && treeToStopCutting.active && initialHealth !== null) {
             // Check if tree health is above 0 (i.e., not felled by cutTree)
             if (treeToStopCutting.health > 0) {
                 const healthLost = initialHealth - treeToStopCutting.health;
                 const woodGained = Math.max(0, Math.floor(healthLost)); // e.g., 1 wood per HP lost

                 if (woodGained > 0) {
                     if (workerSprite === this.worker) {
                         this.wood += woodGained;
                         this.woodText.setText('Wood: ' + this.wood);
                         this.logDebug(`Stopped chopping. Gained ${woodGained} wood (partial).`);
                     } else if (workerSprite === this.aiWorker) {
                         this.aiWood += woodGained;
                         this.aiWoodText.setText('AI Wood: ' + this.aiWood);
                         this.logDebug(`AI stopped chopping. Gained ${woodGained} wood (partial).`);
                     }
                     this.checkEndCondition(); // Check if partial wood caused win
                 } else {
                      this.logDebug(`Stopped chopping. No partial wood gained.`);
                 }

                 // Update tree health bar one last time if it still exists
                 this.updateTreeHealthBar(treeToStopCutting);

             } // else: tree health is <= 0, cutTree handled wood, don't award partial

             // Destroy health bar only if the other worker isn't also cutting it
             let otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
             if (!otherWorker || !otherWorker.isCutting || otherWorker.cuttingTarget !== treeToStopCutting) {
                  this.destroyTreeHealthBar(treeToStopCutting);
             }

        } else if (treeToStopCutting) {
             // If not cutting or tree invalid, still try to clean up bar if needed
             let otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
             if (!otherWorker || !otherWorker.isCutting || otherWorker.cuttingTarget !== treeToStopCutting) {
                  this.destroyTreeHealthBar(treeToStopCutting);
             }
        }
      }


    /**
     * Finalizes cutting the tree, adds wood, removes tree, checks end condition.
     * @param {Phaser.GameObjects.Sprite} tree - The tree sprite that was cut.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker who cut the tree.
     */
    cutTree(tree, workerSprite) {
      // Stop the cutting process formally (clears timer, sounds, etc.)
      // Note: partial wood won't be awarded here because health <= 0 check in stopCutting
      this.stopCutting(workerSprite);

      if (!tree || !workerSprite) { // Check worker too
        console.warn("Attempted to cut tree with invalid tree or worker.");
        this.destroyTreeHealthBar(tree);
        if(workerSprite) workerSprite.state = 'chopping'; // Try to find new task
        return;
      }

      // Award full wood amount for felling the tree
      const woodFromFelledTree = 10;
      if (workerSprite === this.worker) {
          this.wood += woodFromFelledTree;
          this.woodText.setText('Wood: ' + this.wood);
          this.logDebug(`Tree felled! Gained ${woodFromFelledTree} wood. Total: ${this.wood}`);
      } else if (workerSprite === this.aiWorker) {
          this.aiWood += woodFromFelledTree;
          this.aiWoodText.setText('AI Wood: ' + this.aiWood);
          this.logDebug(`AI felled tree. Gained ${woodFromFelledTree} wood. Total: ${this.aiWood}`);
      }

      // Ensure worker state is reset correctly after felling
      workerSprite.isCutting = false; // Should be done by stopCutting, but ensure
      workerSprite.cuttingTarget = null;
      workerSprite.initialChopHealth = null;
      workerSprite.state = 'chopping'; // Set state to find next tree
      workerSprite.setTexture('worker_sheet');
      workerSprite.anims.stop();
      workerSprite.setFrame(0);
      workerSprite.setFlipX(false);


      // Destroy the tree health bar explicitly
      this.destroyTreeHealthBar(tree);
      this.trees.remove(tree, true, true); // Remove from group and destroy sprite

      // Check end condition AFTER wood is updated and tree removed
      this.checkEndCondition();

      // Worker automatically looks for next tree via handleWorkerState in update loop
      // State was already set to 'chopping'
    }

    /**
     * Checks if the game should end based on wood counts or lack of trees.
     */
    checkEndCondition() {
        if (this.gameOver) return; // Don't check if already ended

        const winAmount = 100;

        if (this.wood >= winAmount) {
            this.endGame("You Win!", '#ffff00'); // Yellow for win
            return;
        }

        if (this.aiWood >= winAmount) {
            this.endGame("Computer Wins!", '#ff0000'); // Red for loss
            return;
        }

        const remainingTrees = this.trees.countActive(true);
        if (remainingTrees === 0) {
            // Check if any worker is still busy (moving or cutting or building)
             const playerBusy = this.worker && (this.worker.moving || this.worker.isCutting || this.worker.isBuilding);
             const aiBusy = this.aiWorker && (this.aiWorker.moving || this.aiWorker.isCutting || this.aiWorker.isBuilding); // Include AI building check

            if (!playerBusy && !aiBusy) { // Only draw if no trees AND no workers busy
                 this.endGame("Draw!", '#ffffff'); // White for draw
                 return;
            }
        }
    }

    /**
     * Ends the game, displaying a message and stopping activity.
     * @param {string} message - The message to display (e.g., "You Win!").
     * @param {string} color - The color for the message text.
     */
    endGame(message, color = '#ffffff') {
        if (this.gameOver) return; // Prevent multiple calls

        this.gameOver = true;
        this.gameStarted = false; // Stop main game logic in update

        this.logDebug(`Game Over: ${message}`); // Use new log function

        this.add.text(this.sys.game.config.width / 2, this.sys.game.config.height / 2,
                                message,
                                { font: '48px Arial', fill: color, align: 'center' })
                                .setOrigin(0.5)
                                .setDepth(2000); // Ensure message is on top

        // Stop everything
        this.input.enabled = false; // Disable input on game over
        this.tweens.killAll(); // Stop all movement tweens

        // Stop sounds
        if (this.workerWalkSound && this.workerWalkSound.isPlaying) this.workerWalkSound.stop();
        if (this.chopSound && this.chopSound.isPlaying) this.chopSound.stop();
        // this.sound.stopAll(); // Use with caution if other sounds exist

        // Stop timers and reset workers visually/state-wise
        [this.worker, this.aiWorker].forEach(w => {
            if (w) {
                 if (w.isCutting) this.stopCutting(w);
                 if (w.isBuilding) this.stopBuilding(w); // Stop building too
                 w.state = 'idle'; // Ensure state is idle
                 w.moving = false; // Ensure moving is false
                 w.target = null; // Clear target
                 w.setTexture('worker_sheet');
                 w.anims.stop();
                 w.setFrame(0);
                 w.setFlipX(false);
            }
        });

         // Destroy any remaining tree health bars
         if (this.trees) {
            this.trees.getChildren().forEach(tree => this.destroyTreeHealthBar(tree));
         }
         // Destroy barrack health bars if they exist
         if (this.playerBarrack) this.destroyHealthBar(this.playerBarrack);
         if (this.aiBarrack) this.destroyHealthBar(this.aiBarrack);


        console.log("Game Over:", message);
    }


    /**
     * Updates the position and fill of a unit's health bar.
     */
    updateHealthBar(unit) {
        if (!unit || !unit.active) { // Only check unit active status
             this.destroyHealthBar(unit); // Attempt cleanup if invalid
            return;
        }
        // Check if bar needs to be created (exists, active, but no bar yet)
        if (!unit.healthBarBg || !unit.healthBarFill) {
            // Determine color and width based on type
            let barColor;
            let barWidth;
            let maxHealth; // Need max health too
            if (unit === this.worker || unit === this.aiWorker) {
                barWidth = UNIT_HEALTH_BAR_WIDTH; // Use constant
                maxHealth = 10;
                barColor = (unit === this.worker) ? PLAYER_HEALTH_BAR_COLOR : AI_HEALTH_BAR_COLOR;
            } else if (unit === this.house || unit === this.aiHouse || unit === this.playerBarrack || unit === this.aiBarrack) {
                barWidth = BUILDING_HEALTH_BAR_WIDTH; // Use constant
                maxHealth = 50;
                 if (unit === this.house || unit === this.playerBarrack) {
                     barColor = PLAYER_HEALTH_BAR_COLOR;
                 } else {
                     barColor = AI_HEALTH_BAR_COLOR;
                 }
            } else {
                return; // Don't create bar for unknown types (like trees) here
            }
            // Assign maxHealth if not present (needed for calculation)
            if(unit.maxHealth === undefined) unit.maxHealth = maxHealth;
            this.createHealthBar(unit, barWidth, barColor); // Create the bar
             if (!unit.healthBarBg) return; // Exit if creation failed
        }

        // --- Update existing bar ---
        const barWidth = unit.healthBarWidth;
         // Use displayHeight if available, otherwise height
        const unitHeight = unit.displayHeight || unit.height || 64;
        const yOffset = -unitHeight - 5;
        const x = unit.x;
        const y = unit.y + yOffset;

        unit.healthBarBg.setPosition(x, y);
        unit.healthBarFill.setPosition(x - barWidth / 2, y);

        // Ensure health and maxHealth are valid numbers
        const currentHealth = typeof unit.health === 'number' ? unit.health : 0;
        const maxHealth = typeof unit.maxHealth === 'number' && unit.maxHealth > 0 ? unit.maxHealth : 1;
        const fillRatio = Math.max(0, Math.min(1, currentHealth / maxHealth)); // Clamp between 0 and 1

        const fillWidth = fillRatio * barWidth;
        unit.healthBarFill.width = fillWidth;

        // Set depth (important!)
        // Check if bars exist before setting depth (might have been destroyed)
        if (unit.healthBarBg) unit.healthBarBg.setDepth(unit.depth + 1);
        if (unit.healthBarFill) unit.healthBarFill.setDepth(unit.depth + 2);
    }

     /**
      * Destroys the health bar associated with any unit/building.
      */
     destroyHealthBar(unit) {
        if (unit) {
            if (unit.healthBarBg) {
                unit.healthBarBg.destroy();
                unit.healthBarBg = null;
            }
            if (unit.healthBarFill) {
                unit.healthBarFill.destroy();
                unit.healthBarFill = null;
            }
        }
     }


    /**
     * Finds the closest active tree to the specified worker, avoiding trees targeted by the other worker.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker to find the closest tree for.
     * @returns {Phaser.GameObjects.Sprite | null} The closest tree or null if none found or available.
     */
    findClosestTree(workerSprite) {
        if (!workerSprite || !this.trees) return null;

        const activeTrees = this.trees.getChildren().filter(tree => tree.active);
        if (activeTrees.length === 0) {
            return null; // No trees left at all
        }

        let closestTree = null;
        let minDistance = Infinity;

        activeTrees.forEach(tree => {
            // --- Target Avoidance Logic ---
            let isTreeBusy = false;

            // Check if player worker is targeting/cutting this tree
            if (this.worker && this.worker.active) {
                 if (this.worker.isCutting && this.worker.cuttingTarget === tree) isTreeBusy = true;
                 if (this.worker.moving && this.worker.target === tree && this.worker.state === 'moving_to_chop') isTreeBusy = true;
            }
             // Check if AI worker is targeting/cutting this tree
             if (this.aiWorker && this.aiWorker.active) {
                 if (this.aiWorker.isCutting && this.aiWorker.cuttingTarget === tree) isTreeBusy = true;
                 if (this.aiWorker.moving && this.aiWorker.target === tree && this.aiWorker.state === 'moving_to_chop') isTreeBusy = true;
             }


            if (isTreeBusy) {
                return; // Skip this tree, it's claimed
            }
            // --- End Target Avoidance ---

            const distance = Phaser.Math.Distance.Between(workerSprite.x, workerSprite.y, tree.x, tree.y);
            if (distance < minDistance) {
                minDistance = distance;
                closestTree = tree;
            }
        });

        return closestTree;
    }

    /**
     * Sends the specified worker to move towards and cut a specific tree.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker to send.
     * @param {Phaser.GameObjects.Sprite} tree - The target tree.
     */
    sendWorkerToTree(workerSprite, tree) {
        if (!tree || !tree.active || !workerSprite || this.gameOver) { // Check game over
             this.logDebug('Cannot send worker: Invalid target/worker or game over.');
            return;
        }

         // --- Stop any existing actions before sending to tree ---
         const workerId = workerSprite === this.worker ? 'Player' : 'AI';
         this.logDebug(`Sending ${workerId} worker to tree.`);
         if (workerSprite.isCutting) {
              this.stopCutting(workerSprite); // Will handle partial wood
         }
          if (workerSprite.isBuilding) { // NEW: Stop building if commanded to chop
              this.stopBuilding(workerSprite);
         }
         if (workerSprite.moving) {
              this.tweens.killTweensOf(workerSprite); // Stop existing movement
              workerSprite.moving = false;
              workerSprite.target = null; // Clear old target
              // Reset visuals immediately after stopping tween
              workerSprite.setTexture('worker_sheet');
              workerSprite.anims.stop();
              workerSprite.setFrame(0);
              workerSprite.setFlipX(false); // Default to right
              // Stop walk sound if needed
              if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                  let otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
                  if (!otherWorker || !otherWorker.moving) {
                       this.workerWalkSound.stop();
                  }
             }
         }
          // Clear any potential targets
         workerSprite.cuttingTarget = null;
         workerSprite.buildingTarget = null;
         workerSprite.initialChopHealth = null; // Ensure this is clear before new move
         // --- End Stop Actions ---


        workerSprite.target = tree; // Set the target tree
        workerSprite.moving = true; // Set moving flag
        workerSprite.state = 'moving_to_chop'; // Use a specific state

        const offset = 30; // How close the worker gets to the tree center (adjust as needed)
        const targetY = tree.y; // Move to the same Y level as the tree base
        let targetX;
        let faceRightOnArrival; // Determines the direction to *face* when chopping (not moving)

        // Determine target X based on which side of the tree the worker is on
        if (workerSprite.x <= tree.x) {
            targetX = tree.x - offset; // Approach from the left
            faceRightOnArrival = true; // Need to face right (flipX=false) to chop tree at right
        } else {
            targetX = tree.x + offset; // Approach from the right
            faceRightOnArrival = false; // Need to face left (flipX=true) to chop tree at left
        }

        if (workerSprite === this.worker) { // Only update debug for player
             this.logDebug(`Worker moving to tree at (${Math.round(tree.x)}, ${Math.round(tree.y)}).`); // Use new log function
        }


        const distance = Phaser.Math.Distance.Between(workerSprite.x, workerSprite.y, targetX, targetY);
        const speed = 100; // Pixels per second
        const duration = (distance / speed) * 1000 || 1; // Ensure duration > 0

        workerSprite.anims.play('walk', true); // Play walking animation

        // --- Sound Start Logic ---
        if (this.workerWalkSound && !this.workerWalkSound.isPlaying) {
             this.workerWalkSound.play({ loop: true });
        }
        // --- End Sound Start Logic ---


        // Flip sprite based on movement direction
        if (targetX < workerSprite.x) {
             workerSprite.setFlipX(true); // Moving left
        } else {
             workerSprite.setFlipX(false); // Moving right
        }

        // Start the movement tween
        this.tweens.add({
          targets: workerSprite,
          x: targetX,
          y: targetY,
          duration: duration,
          ease: 'Linear',
          onComplete: () => { // Use arrow function for correct 'this' scope
            // --- Movement Completion Logic ---
             if (!workerSprite.active || workerSprite.state !== 'moving_to_chop') return; // Check if still valid

            workerSprite.moving = false; // Set moving false *before* checking others

            // --- Sound Stop Logic on Arrival ---
            if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                let otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
                if (!otherWorker || !otherWorker.moving) { // Stop only if other worker isn't moving
                     this.workerWalkSound.stop();
                }
            }
            // --- End Sound Stop Logic ---

            // Check if the target tree is still valid and hasn't been claimed
            const actualTree = workerSprite.target; // Get the target again
            workerSprite.target = null; // Clear the movement target

            if (actualTree && actualTree.active && !this.gameOver) {
                // Check again if other worker snagged this tree while moving
                let otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
                 if (otherWorker && otherWorker.active && ((otherWorker.isCutting && otherWorker.cuttingTarget === actualTree) || (otherWorker.moving && otherWorker.target === actualTree && otherWorker.state === 'moving_to_chop'))) {
                     // Other worker claimed this tree, find another
                     if (workerSprite === this.worker) this.logDebug(`Tree claimed by other worker. Finding another.`);
                     workerSprite.state = 'chopping'; // Re-enter state to find new tree automatically
                     workerSprite.setTexture('worker_sheet'); // Reset visual
                     workerSprite.anims.stop();
                     workerSprite.setFrame(0);
                     return; // Exit onComplete early
                 }

                // --- Start Cutting ---
                workerSprite.state = 'chopping'; // Update state
                workerSprite.isCutting = true;
                workerSprite.cuttingTarget = actualTree; // Set the cutting target
                workerSprite.initialChopHealth = actualTree.health; // Store current health
                 if (workerSprite === this.worker) { // Only update debug for player
                    this.logDebug(`Reached tree. Starting cut (H:${actualTree.health})`);
                 }

                this.createTreeHealthBar(actualTree); // Show health bar

                // Set flip based on OPPOSITE of faceRightOnArrival to face the tree
                workerSprite.setFlipX(!faceRightOnArrival);
                workerSprite.setTexture('worker_chop_sheet'); // Switch to chopping texture
                workerSprite.anims.play('chop', true); // Play chopping animation

                // --- Chop Sound Start Logic ---
                 if (this.chopSound && !this.chopSound.isPlaying) {
                     // Check if other worker is also chopping
                     let otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
                     if (!otherWorker || !otherWorker.isCutting) { // Start only if other isn't chopping
                          this.chopSound.play({ loop: true });
                     }
                 }
                // --- End Chop Sound Start Logic ---

                // Store timer on the worker
                workerSprite.cuttingTimer = this.time.addEvent({
                    delay: 1000, // Damage every second
                    callback: () => this.damageTree(workerSprite),
                    callbackScope: this,
                    loop: true
                });
                // --- End Start Cutting ---

            } else {
                // Target became invalid or game ended during movement
                 if (workerSprite === this.worker && !this.gameOver) {
                    this.logDebug(`Reached location, but target invalid.`);
                 }
                 workerSprite.state = 'idle'; // Go idle if target invalid
                 workerSprite.setTexture('worker_sheet'); // Reset visual
                 workerSprite.anims.stop();
                 workerSprite.setFrame(0);
                 workerSprite.setFlipX(false); // Default flip
            }
            // --- End Movement Completion Logic ---
          },
          onStop: () => { // Handle tween being stopped externally (e.g., target destroyed)
             if (!workerSprite.active) return;
             workerSprite.moving = false;
             // If stopped while moving to chop, try chopping again (find new tree)
             if (workerSprite.state === 'moving_to_chop') {
                 workerSprite.state = 'chopping'; // Let handleWorkerState find a new tree
                 this.logDebug('Worker move to tree interrupted, trying to find tree.');
             } else {
                 // Otherwise default to idle
                 workerSprite.state = 'idle';
                 this.logDebug('Worker move interrupted, going idle.');
             }
            // Reset visuals
            workerSprite.setTexture('worker_sheet');
            workerSprite.anims.stop();
            workerSprite.setFrame(0);
            workerSprite.setFlipX(false); // Reset flip to default (facing right)
            workerSprite.target = null; // Ensure target is cleared
             // Stop walk sound if needed
            if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                let otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
                if (!otherWorker || !otherWorker.moving) { // Stop only if other worker isn't moving
                     this.workerWalkSound.stop();
                }
            }
          }
        });
    }

     /**
      * Starts the process of building a barrack for a specific side.
      * @param {Phaser.GameObjects.Sprite} workerSprite - The worker doing the building.
      * @param {string} side - 'player' or 'ai'.
      */
     startBuildingBarrack(workerSprite, side = 'player') {
         const isPlayer = side === 'player';
         const woodCount = isPlayer ? this.wood : this.aiWood;
         const existingBarrack = isPlayer ? this.playerBarrack : this.aiBarrack;
         const isBuildingBarrack = isPlayer ? this.playerBarrackBuilding : this.aiBarrackBuilding;
         const house = isPlayer ? this.house : this.aiHouse;
         // Use global constant
         const woodCost = BARRACK_WOOD_COST;

         if (!workerSprite || !workerSprite.active || existingBarrack || isBuildingBarrack || woodCount < woodCost || !house) {
             this.logDebug(`Cannot start ${side} barrack (invalid conditions).`);
             // If AI failed, ensure it goes back to chopping
             if (!isPlayer) workerSprite.state = 'chopping';
             return;
         }

         this.logDebug(`Starting ${side} barrack construction.`);

         if (isPlayer) {
             this.playerBarrackBuilding = true;
             this.wood -= woodCost;
             this.woodText.setText('Wood: ' + this.wood);
         } else {
             this.aiBarrackBuilding = true;
             this.aiWood -= woodCost;
             this.aiWoodText.setText('AI Wood: ' + this.aiWood);
         }

         // --- Stop any existing actions ---
         if (workerSprite.isCutting) this.stopCutting(workerSprite);
         if (workerSprite.isBuilding) this.stopBuilding(workerSprite);
         if (workerSprite.moving) {
             this.tweens.killTweensOf(workerSprite);
             workerSprite.moving = false;
             workerSprite.target = null;
             workerSprite.setTexture('worker_sheet');
             workerSprite.anims.stop();
             workerSprite.setFrame(0);
             workerSprite.setFlipX(false);
              if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                  let otherWorker = isPlayer ? this.aiWorker : this.worker;
                  if (!otherWorker || !otherWorker.moving) this.workerWalkSound.stop();
              }
         }
         workerSprite.cuttingTarget = null;
         workerSprite.buildingTarget = null;
         workerSprite.initialChopHealth = null;
         // --- End Stop Actions ---

         // Determine build location
         const buildX = isPlayer ? house.x + 80 : house.x - 80; // Player right, AI left
         const buildY = house.y;

         // Create the barrack sprite
         const newBarrack = this.add.sprite(buildX, buildY, 'barrack').setOrigin(0.5, 1);
         newBarrack.health = 0;
         newBarrack.maxHealth = 50;
         newBarrack.isBuilding = true;
         newBarrack.setAlpha(0.5);
         // Use constants for color and width
         const barColor = isPlayer ? PLAYER_HEALTH_BAR_COLOR : AI_HEALTH_BAR_COLOR;
         this.createHealthBar(newBarrack, BUILDING_HEALTH_BAR_WIDTH, barColor);

         if (isPlayer) {
             this.playerBarrack = newBarrack;
         } else {
             this.aiBarrack = newBarrack;
         }

         // --- Send worker to build site ---
         workerSprite.state = 'moving_to_build';
         workerSprite.target = newBarrack; // Target the building

         const offset = 40;
         const targetYBuild = buildY;
         let targetXBuild;
         let faceRightOnArrivalBuild;

         if (workerSprite.x <= buildX) {
             targetXBuild = buildX - offset;
             faceRightOnArrivalBuild = true; // Face right towards building
         } else {
             targetXBuild = buildX + offset;
             faceRightOnArrivalBuild = false; // Face left towards building
         }

         const distance = Phaser.Math.Distance.Between(workerSprite.x, workerSprite.y, targetXBuild, targetYBuild);
         const speed = 100;
         const duration = (distance / speed) * 1000 || 1;

         workerSprite.anims.play('walk', true);
         if (targetXBuild < workerSprite.x) workerSprite.setFlipX(true);
         else workerSprite.setFlipX(false);
         workerSprite.moving = true;

          if (this.workerWalkSound && !this.workerWalkSound.isPlaying) {
               this.workerWalkSound.play({ loop: true });
          }

         this.tweens.add({
             targets: workerSprite,
             x: targetXBuild,
             y: targetYBuild,
             duration: duration,
             ease: 'Linear',
             onComplete: () => {
                 if (!workerSprite.active || workerSprite.state !== 'moving_to_build') return;

                 workerSprite.moving = false;
                  if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                      let otherWorker = isPlayer ? this.aiWorker : this.worker;
                      if (!otherWorker || !otherWorker.moving) this.workerWalkSound.stop();
                 }

                 // --- Start Building ---
                 workerSprite.state = 'building';
                 workerSprite.isBuilding = true;
                 workerSprite.buildingTarget = newBarrack; // Ensure target is set

                 this.logDebug(`${side} worker arrived at build site. Starting construction.`);

                 workerSprite.setFlipX(!faceRightOnArrivalBuild); // Face the building site
                 workerSprite.setTexture('worker_chop_sheet'); // Use 'chop' anim for building
                 workerSprite.anims.play('chop', true);

                 // Start building sound (using chop sound)
                 if (this.chopSound && !this.chopSound.isPlaying) {
                       this.chopSound.play({ loop: true });
                  }

                 // Start building timer
                 workerSprite.buildingTimer = this.time.addEvent({
                     delay: 1000, // 1 health per second
                     callback: () => this.buildStructure(workerSprite),
                     callbackScope: this,
                     loop: true
                 });
             },
              onStop: () => { // If move to build is interrupted
                  if (!workerSprite.active) return;
                  workerSprite.moving = false;
                  workerSprite.state = 'idle'; // Default to idle if move interrupted
                  workerSprite.target = null;
                  workerSprite.setTexture('worker_sheet');
                  workerSprite.anims.stop();
                  workerSprite.setFrame(0);
                  workerSprite.setFlipX(false);
                  this.logDebug(`${side} worker move to build site interrupted.`);
                   if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                       let otherWorker = isPlayer ? this.aiWorker : this.worker;
                       if (!otherWorker || !otherWorker.moving) this.workerWalkSound.stop();
                  }
                  // Cancel the build process
                  const barrackToCancel = isPlayer ? this.playerBarrack : this.aiBarrack;
                  if(barrackToCancel && barrackToCancel.isBuilding) {
                       this.destroyHealthBar(barrackToCancel); // Destroy bar first
                       barrackToCancel.destroy(); // Remove placeholder
                       if (isPlayer) {
                           this.playerBarrack = null;
                           this.playerBarrackBuilding = false;
                           // Refund player wood
                           this.wood += woodCost; this.woodText.setText('Wood: ' + this.wood);
                       } else {
                           this.aiBarrack = null;
                           this.aiBarrackBuilding = false;
                            // Refund AI wood
                           this.aiWood += woodCost; this.aiWoodText.setText('AI Wood: ' + this.aiWood);
                       }
                       this.logDebug(`${side} build process cancelled due to move interruption.`);
                  }
              }
         });
      }


     /**
      * Increases health of the structure being built. Called by timer.
      * @param {Phaser.GameObjects.Sprite} workerSprite - The worker doing the building.
      */
     buildStructure(workerSprite) {
         if (this.gameOver || !workerSprite || !workerSprite.active || !workerSprite.isBuilding || !workerSprite.buildingTarget || !workerSprite.buildingTarget.active) {
             this.stopBuilding(workerSprite); // Stop if state is invalid
             return;
         }

         const building = workerSprite.buildingTarget;
         building.health += 1; // Increase health by 1 per second

         // Update progress visuals
         this.updateHealthBar(building);
         building.setAlpha(0.5 + 0.5 * (building.health / building.maxHealth)); // Become less transparent

         // Check for completion
         if (building.health >= building.maxHealth) {
             building.health = building.maxHealth; // Cap health
             building.setAlpha(1); // Fully visible
             building.isBuilding = false; // Mark as complete
             this.updateHealthBar(building); // Final bar update

             const side = workerSprite === this.worker ? 'Player' : 'AI';
             this.logDebug(`${side} barrack construction complete!`);

             // Update the correct building flag
             if (workerSprite === this.worker) {
                 this.playerBarrackBuilding = false;
             } else {
                 this.aiBarrackBuilding = false;
             }

             // Stop the worker's building action
             this.stopBuilding(workerSprite);
             // Set worker back to finding trees (or idle if none)
             workerSprite.state = 'chopping';
         }
      }

       /**
       * Stops the current building process for a specific worker.
       * @param {Phaser.GameObjects.Sprite} workerSprite - The worker to stop.
       */
      stopBuilding(workerSprite) {
         if (!workerSprite || !workerSprite.isBuilding) return;

         const side = workerSprite === this.worker ? 'Player' : 'AI';
         this.logDebug(`Stopping ${side} building action.`);

         // Clear timer
         if (workerSprite.buildingTimer) {
             workerSprite.buildingTimer.remove(false);
             workerSprite.buildingTimer = null;
         }

         // Stop building sound (chop sound) only if no one else is chopping/building
         if (this.chopSound && this.chopSound.isPlaying) {
             const playerBusySound = this.worker && this.worker.active && (this.worker.isCutting || this.worker.isBuilding) && this.worker !== workerSprite;
             const aiBusySound = this.aiWorker && this.aiWorker.active && (this.aiWorker.isCutting || this.aiWorker.isBuilding) && this.aiWorker !== workerSprite;
             if (!playerBusySound && !aiBusySound) { // Stop if no one else is making the sound
                 this.chopSound.stop();
             }
         }


         // Reset worker state and visuals
         workerSprite.isBuilding = false;
         workerSprite.buildingTarget = null;
         workerSprite.setTexture('worker_sheet');
         workerSprite.anims.stop();
         workerSprite.setFrame(0);
         workerSprite.setFlipX(false);
         // Don't reset state here, let the calling function decide the next state
      }


    /**
     * Handles a worker's state machine logic.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker whose state to handle.
     */
    handleWorkerState(workerSprite) {
        if (!this.gameStarted || this.gameOver || !workerSprite || !workerSprite.active) return; // Exit if game not running or worker invalid

        // --- Check for Build Order ---
        if (workerSprite === this.worker && // Player build check
            !this.playerBarrack && !this.playerBarrackBuilding && this.wood >= BARRACK_WOOD_COST &&
            !workerSprite.moving && !workerSprite.isCutting && !workerSprite.isBuilding)
        {
            this.startBuildingBarrack(workerSprite, 'player');
            return; // Prioritize building
        }
         // AI Build Check
         else if (workerSprite === this.aiWorker &&
            !this.aiBarrack && !this.aiBarrackBuilding && this.aiWood >= BARRACK_WOOD_COST && // Use constant, same cost
            !workerSprite.moving && !workerSprite.isCutting && !workerSprite.isBuilding)
        {
             this.startBuildingBarrack(workerSprite, 'ai');
             return; // Prioritize building
        }


        // --- Default Actions (Chopping/Idle) ---
        // Only act if the worker is not currently busy moving, cutting, or building
        if (!workerSprite.moving && !workerSprite.isCutting && !workerSprite.isBuilding) {
            if (workerSprite.state === 'chopping' || workerSprite.state === 'idle') { // Treat idle as wanting to chop if possible
                // Worker is idle but *should* be chopping - find a tree
                const closestTree = this.findClosestTree(workerSprite);
                if (closestTree) {
                     if (workerSprite.state === 'idle') {
                         this.logDebug(`${workerSprite === this.worker ? 'Player' : 'AI'} worker idle, finding tree.`);
                     }
                    this.sendWorkerToTree(workerSprite, closestTree);
                } else {
                    // No available trees left for this worker
                    if (workerSprite.state !== 'idle') { // Only log if state changes
                        workerSprite.state = 'idle';
                         if (workerSprite === this.worker) { // Only update debug for player
                             this.logDebug("No available trees. Worker idle.");
                         } else {
                              this.logDebug("No available trees. AI Worker idle.");
                         }
                         // Reset visuals to idle
                         workerSprite.setTexture('worker_sheet');
                         workerSprite.anims.stop();
                         workerSprite.setFrame(0);
                         workerSprite.setFlipX(false);
                    }
                     // Check for draw condition again here, in case this was the last action
                     this.checkEndCondition();
                }
            }
             // Reset state if somehow stuck in a moving/building state without the flag set
             else if (workerSprite.state === 'moving_to_chop' || workerSprite.state === 'moving_to_idle' || workerSprite.state === 'moving_to_build' || workerSprite.state === 'building') {
                 this.logDebug(`Worker stuck in ${workerSprite.state} without flag. Resetting to idle.`);
                 workerSprite.state = 'idle';
                 workerSprite.setTexture('worker_sheet');
                 workerSprite.anims.stop();
                 workerSprite.setFrame(0);
                 workerSprite.setFlipX(false);
             }
        }
        // If worker is moving, cutting, or building, the relevant callbacks/timers handle state changes
    }


    /**
     * Game loop update function. Runs continuously.
     */
    update(time, delta) {
        if (!this.gameStarted || this.gameOver) return; // Stop updates if game hasn't started or is over

        // --- Handle Worker States ---
        // Check worker states if they are not busy
        if (this.worker && this.worker.active) {
             this.handleWorkerState(this.worker);
        }
        if (this.aiWorker && this.aiWorker.active) {
             this.handleWorkerState(this.aiWorker);
        }


        // --- Depth Sorting ---
        const depthSortedSprites = [];
        // Add active units and trees to the sorting array
        if (this.worker && this.worker.active) depthSortedSprites.push(this.worker);
        if (this.aiWorker && this.aiWorker.active) depthSortedSprites.push(this.aiWorker);
        if (this.house && this.house.active) depthSortedSprites.push(this.house);
        if (this.aiHouse && this.aiHouse.active) depthSortedSprites.push(this.aiHouse);
        if (this.playerBarrack && this.playerBarrack.active) depthSortedSprites.push(this.playerBarrack); // Add player barrack
        if (this.aiBarrack && this.aiBarrack.active) depthSortedSprites.push(this.aiBarrack); // Add AI barrack

        if (this.trees) {
            this.trees.getChildren().forEach(tree => {
                if (tree.active) {
                    depthSortedSprites.push(tree);
                    // Update active tree health bar position/depth continuously
                    if(tree.healthBarBg) {
                         this.updateTreeHealthBar(tree);
                    }
                } else {
                    // Ensure health bar is destroyed if tree becomes inactive unexpectedly
                    this.destroyTreeHealthBar(tree);
                }
            });
        }

        // Sort based on Y position (lower Y means further back, lower depth)
        depthSortedSprites.sort((a, b) => {
            const yA = a.y;
            const yB = b.y;
            if (yA < yB) return -1;
            if (yA > yB) return 1;
            return 0;
        });

        // Apply the calculated depth
        depthSortedSprites.forEach((sprite, index) => {
            sprite.setDepth(index);
        });

        // --- Update Unit Health Bars (Position and Depth) ---
        // Call these *after* depth sorting the main sprites
        this.updateHealthBar(this.worker);
        this.updateHealthBar(this.house);
        this.updateHealthBar(this.aiWorker);
        this.updateHealthBar(this.aiHouse);
        this.updateHealthBar(this.playerBarrack); // Update player barrack health bar
        this.updateHealthBar(this.aiBarrack); // Update AI barrack health bar
        // Tree health bars are updated during the tree iteration above


        // --- Target / Cutting / Building Checks (Handle cases where target becomes invalid) ---
        [this.worker, this.aiWorker].forEach( w => {
            if (!w || !w.active) return; // Skip inactive workers

            // Check 1: Worker is MOVING TO CHOP, but its target tree becomes inactive/destroyed
            if (w.moving && w.target && w.state === 'moving_to_chop' && !w.target.active) {
                const workerType = w === this.aiWorker ? "AI" : "Player";
                this.logDebug(`${workerType} target tree disappeared during move.`);
                this.tweens.killTweensOf(w); // Stop the movement tween (will trigger onStop)
            }
             // Check 1b: Worker is MOVING TO BUILD, but the building target is somehow destroyed
             if (w.moving && w.target && w.state === 'moving_to_build' && !w.target.active) {
                 const workerType = w === this.aiWorker ? "AI" : "Player";
                 this.logDebug(`${workerType} build target disappeared during move.`);
                 this.tweens.killTweensOf(w); // Stop the movement tween (will trigger onStop)
             }


            // Check 2: Worker is CUTTING, but its cuttingTarget becomes inactive/destroyed
            if (w.isCutting && w.cuttingTarget && !w.cuttingTarget.active) {
                 const workerType = w === this.aiWorker ? "AI" : "Player";
                 this.logDebug(`${workerType} cutting target disappeared.`);
                 this.stopCutting(w); // Gracefully stop the cutting process
                 w.state = 'chopping'; // Re-enter chopping state to find new target
            }

             // Check 3: Worker is BUILDING, but its buildingTarget becomes inactive/destroyed
             if (w.isBuilding && w.buildingTarget && !w.buildingTarget.active) {
                 const workerType = w === this.aiWorker ? "AI" : "Player";
                 this.logDebug(`${workerType} building target disappeared.`);
                 this.stopBuilding(w); // Gracefully stop the building process
                 w.state = 'idle'; // Go idle if building target disappears
             }
        });
    }
  }

  /**
   * Phaser game configuration object.
   */
  const config = {
    type: Phaser.AUTO, // Automatically choose WebGL or Canvas
    width: 800,
    height: 600,
    parent: 'phaser-game-container', // Optional: Specify a div ID to contain the canvas
    physics: {
        default: 'arcade', // Using Arcade Physics for simplicity (though not heavily used here)
        arcade: {
            debug: false // Set to true to see physics bodies if needed
        }
    },
    scene: [DemoScene], // The scene(s) to load
    scale: {
        mode: Phaser.Scale.FIT, // Fit the game within the available space
        autoCenter: Phaser.Scale.CENTER_BOTH // Center the game canvas
    },
    render: {
        pixelArt: true // Optional: Use if assets are pixel art for sharper scaling
    }
  };

  // Create a new Phaser game instance when the window loads
  window.onload = () => {
      const game = new Phaser.Game(config);
  };

</script>
</body>
</html>
