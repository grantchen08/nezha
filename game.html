<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Simple RTS Demo with Worker Animation</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <style>
    /* Basic styling for the body and canvas */
    body { margin: 0; background-color: #333; display: flex; justify-content: center; align-items: center; min-height: 100vh; position: relative; } /* Added position relative */
    canvas { display: block; margin: 20px auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
    /* Style for the start overlay */
    #start-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        font-size: 24px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        z-index: 10000; /* Ensure it's on top */
        font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
<div id="start-overlay">Click or Tap to Start</div>

<script>
  /**
   * Represents the main scene for the RTS demo.
   * Handles game logic, asset loading, and rendering.
   */
  class DemoScene extends Phaser.Scene {
    constructor() {
      super({ key: 'DemoScene' });
      // Game state variables
      this.wood = 0; // Player's wood count
      this.worker = null; // The player-controlled worker sprite
      this.house = null; // The player house sprite
      this.aiHouse = null; // AI house sprite
      this.aiWorker = null; // AI worker sprite
      this.trees = null; // Group containing tree sprites
      this.woodText = null; // Text object to display wood count
      this.debugText = null; // Text object for displaying debug messages
      this.workerWalkSound = null; // Sound effect for worker walking
      //this.cuttingTimer = null; // Timer now stored on worker
      this.chopSound = null; // Sound effect for chopping
      this.gameStarted = false; // Flag to prevent logic running before start
    }

    /**
     * Preloads game assets (images, spritesheets, audio).
     * This function runs before the 'create' function.
     */
    preload() {
      // Load the worker spritesheet
      this.load.spritesheet('worker_sheet', 'https://grantchen08.github.io/nezha/worker_walk.png', {
          frameWidth: 32,
          frameHeight: 64
      });
      // Load the worker chopping spritesheet
      this.load.spritesheet('worker_chop_sheet', 'https://grantchen08.github.io/nezha/worker_chop.png', {
          frameWidth: 64,
          frameHeight: 64
      });
      // Load the walking sound effect
      this.load.audio('worker_walk', 'https://grantchen08.github.io/nezha/worker_walk.mp3');
      // Load the tree spritesheet
      this.load.spritesheet('tree_sheet', 'https://grantchen08.github.io/nezha/tree.png', {
          frameWidth: 64,
          frameHeight: 64
      });
      // Load the house image
      this.load.image('house', 'https://grantchen08.github.io/nezha/house.png');
      // Load the chopping sound effect
      this.load.audio('chop_sound', 'https://grantchen08.github.io/nezha/chop_tree.mp3');

      // Basic error handling for asset loading
      this.load.on('loaderror', (file) => {
          console.error(`Error loading asset: ${file.key} from ${file.url}`);
          if (this.debugText) {
            this.debugText.setText(`Debug Output:\nError loading ${file.key}`);
          } else {
            alert(`Error loading asset: ${file.key}. Check console.`);
          }
      });
    }

    /**
     * Creates game objects and initializes the scene.
     * This function runs once after 'preload' is complete.
     */
    create() {
      const gameWidth = this.sys.game.config.width;
      const gameHeight = this.sys.game.config.height;

      // Set background color
      this.cameras.main.setBackgroundColor('#228B22'); // Forest green

      // Initialize wood count and display text
      this.wood = 0;
      this.woodText = this.add.text(10, 10, 'Wood: 0', { font: '16px Arial', fill: '#ffffff' });
      this.woodText.setDepth(1000);

      // Initialize debug text display area
      this.debugText = this.add.text(10, 40, 'Debug Output:', {
        font: '14px Arial',
        fill: '#ffffff',
        wordWrap: { width: 200 }
      });
      this.debugText.setDepth(1000);
      this.debugText.setText("Debug Output:\nClick overlay to start."); // Initial message

      // --- Player House Setup ---
      this.house = this.add.image(100, gameHeight - 100, 'house'); // Bottom-left
      this.house.setOrigin(0.5, 1);
      this.house.health = 50;
      this.house.maxHealth = 50;
      this.createHealthBar(this.house, 60, 0x00ff00); // Green health bar

      // --- Player Worker Setup ---
      this.worker = this.add.sprite(150, gameHeight - 150, 'worker_sheet').setOrigin(0.5, 1); // Near player house
      this.worker.setFrame(0);
      this.worker.state = 'idle'; // Start idle until game starts
      this.worker.moving = false;
      this.worker.target = null;
      this.worker.isCutting = false;
      this.worker.cuttingTarget = null;
      this.worker.cuttingTimer = null; // Timer stored on worker
      this.worker.health = 10;
      this.worker.maxHealth = 10;
      this.createHealthBar(this.worker, 30, 0x00ff00); // Green health bar

      // --- AI House Setup ---
      this.aiHouse = this.add.image(gameWidth - 100, gameHeight - 100, 'house'); // Bottom-right
      this.aiHouse.setOrigin(0.5, 1);
      this.aiHouse.health = 50;
      this.aiHouse.maxHealth = 50;
      this.createHealthBar(this.aiHouse, 60, 0xff0000); // Red health bar

      // --- AI Worker Setup ---
      this.aiWorker = this.add.sprite(gameWidth - 150, gameHeight - 150, 'worker_sheet').setOrigin(0.5, 1); // Near AI house
      this.aiWorker.setFrame(0);
      this.aiWorker.state = 'idle'; // Start idle until game starts
      this.aiWorker.moving = false;
      this.aiWorker.target = null;
      this.aiWorker.isCutting = false;
      this.aiWorker.cuttingTarget = null;
      this.aiWorker.cuttingTimer = null; // Timer stored on worker
      this.aiWorker.health = 10;
      this.aiWorker.maxHealth = 10;
      this.createHealthBar(this.aiWorker, 30, 0xff0000); // Red health bar


      // Load sounds (shared)
      this.workerWalkSound = this.sound.add('worker_walk');
      this.chopSound = this.sound.add('chop_sound');

      // Create animations (shared)
      this.anims.create({
          key: 'walk',
          frames: this.anims.generateFrameNumbers('worker_sheet', { start: 0, end: 3 }),
          frameRate: 8,
          repeat: -1
      });
      this.anims.create({
          key: 'chop',
          frames: this.anims.generateFrameNumbers('worker_chop_sheet', { start: 0, end: 1 }),
          frameRate: 4,
          repeat: -1
      });

      // --- Tree Setup ---
      this.trees = this.add.group();
      const treeCount = 20;
      for (let i = 0; i < treeCount; i++) {
        // Avoid spawning too close to *either* house base area
        let x, y;
        let tooClose;
        do {
            x = Phaser.Math.Between(50, gameWidth - 50);
            y = Phaser.Math.Between(50, gameHeight - 100); // Keep trees away from bottom edge a bit more

            const playerHouseDist = Phaser.Math.Distance.Between(x, y, this.house.x, this.house.y - this.house.height / 2);
            const aiHouseDist = Phaser.Math.Distance.Between(x, y, this.aiHouse.x, this.aiHouse.y - this.aiHouse.height / 2);
            const houseRadius = Math.max(this.house.width, this.house.height) / 2 + 36; // Use displayWidth/Height?

            tooClose = (playerHouseDist < houseRadius * 1.5) || (aiHouseDist < houseRadius * 1.5); // Increase buffer slightly

        } while (tooClose);


        let tree = this.add.sprite(x, y, 'tree_sheet').setOrigin(0.5, 1);
        tree.setFrame(0);
        tree.health = 10;
        tree.maxHealth = 10;
        this.trees.add(tree);
      }

       // --- Start Overlay Logic ---
       const overlay = document.getElementById('start-overlay');
       if (overlay) {
            overlay.addEventListener('pointerdown', () => {
                if (!this.gameStarted) {
                    overlay.style.display = 'none';
                    if (this.sound.context.state === 'suspended') {
                        this.sound.context.resume().then(() => {
                            console.log('Audio Context resumed!');
                            this.startGameLogic();
                        }).catch(e => console.error('Error resuming audio context:', e));
                    } else {
                         this.startGameLogic();
                    }
                }
            }, { once: true });
       } else {
           console.warn("Start overlay not found!");
           this.startGameLogic();
       }
    }

    /**
     * Starts the main game logic after user interaction.
     */
    startGameLogic() {
        this.gameStarted = true;
        this.worker.state = 'chopping'; // Set player worker state
        this.aiWorker.state = 'chopping'; // Set AI worker state
        this.debugText.setText("Debug Output:\nGame started. Workers finding trees.");
        console.log("Game logic started.");
    }


    /**
     * Creates health bar graphics for a given unit.
     * @param {Phaser.GameObjects.Sprite | Phaser.GameObjects.Image} unit - The unit to add the health bar to.
     * @param {number} barWidth - The width of the health bar.
     * @param {number} barColor - The color of the health fill (e.g., 0x00ff00 for green).
     */
     createHealthBar(unit, barWidth, barColor = 0x00ff00) { // Added barColor parameter
        const barHeight = 8;
        const initialYOffset = -unit.height - 5;
        const x = unit.x;
        const y = unit.y + initialYOffset;

        unit.healthBarBg = this.add.rectangle(x, y, barWidth, barHeight, 0x333333).setOrigin(0.5);
        unit.healthBarFill = this.add.rectangle(x - barWidth / 2, y, barWidth, barHeight, barColor).setOrigin(0, 0.5); // Use barColor
        unit.healthBarWidth = barWidth;
     }

    /**
     * Creates a temporary health bar for the tree being cut.
     */
    createTreeHealthBar(tree) {
        if (!tree || tree.healthBarBg) return;

        const barWidth = 40;
        const barHeight = 8;
        const yOffset = -tree.height - 5;
        const x = tree.x;
        const y = tree.y + yOffset;

        tree.healthBarBg = this.add.rectangle(x, y, barWidth, barHeight, 0x333333).setOrigin(0.5);
        tree.healthBarFill = this.add.rectangle(x - barWidth / 2, y, barWidth, barHeight, 0xffffff).setOrigin(0, 0.5); // White for tree
        tree.healthBarWidth = barWidth;

        this.updateTreeHealthBar(tree);
    }

     /**
      * Updates the position and fill of a specific tree's health bar.
      */
     updateTreeHealthBar(tree) {
         if (!tree || !tree.active || !tree.healthBarBg || !tree.healthBarFill) {
             return;
         }
         const barWidth = tree.healthBarWidth;
         const yOffset = -tree.height - 5;
         const x = tree.x;
         const y = tree.y + yOffset;

         tree.healthBarBg.setPosition(x, y);
         tree.healthBarFill.setPosition(x - barWidth / 2, y);

         const fillWidth = Math.max(0, (tree.health / tree.maxHealth) * barWidth);
         tree.healthBarFill.width = fillWidth;

         tree.healthBarBg.setDepth(tree.depth + 1);
         tree.healthBarFill.setDepth(tree.depth + 2);
     }

    /**
     * Destroys the health bar associated with a specific tree.
     */
    destroyTreeHealthBar(tree) {
        if (tree) {
            if (tree.healthBarBg) {
                tree.healthBarBg.destroy();
                tree.healthBarBg = null;
            }
            if (tree.healthBarFill) {
                tree.healthBarFill.destroy();
                tree.healthBarFill = null;
            }
        }
    }


    /**
     * Damages the tree currently being cut by the specified worker. Called by timer.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker doing the cutting.
     */
     damageTree(workerSprite) {
        if (!this.gameStarted || !workerSprite || !workerSprite.isCutting || !workerSprite.cuttingTarget || !workerSprite.cuttingTarget.active) {
            this.stopCutting(workerSprite); // Stop cutting for this specific worker
            return;
        }

        const tree = workerSprite.cuttingTarget;
        tree.health -= 1;

        this.updateTreeHealthBar(tree);

        // Less verbose debug for AI
        // if (workerSprite === this.worker) {
        //     this.debugText.setText(`Debug Output:\nCutting tree (Health: ${tree.health})`);
        // }

        if (tree.health <= 0) {
            if (workerSprite === this.worker) { // Only show player wood gain
                 this.debugText.setText(`Debug Output:\nTree cut down! Wood: ${this.wood + 10}`);
            }
            this.cutTree(tree, workerSprite); // Pass worker to cutTree
        } else if (tree.health <= 3.3) {
            tree.setFrame(2);
        } else if (tree.health <= 6.6) {
            tree.setFrame(1);
        } else {
            tree.setFrame(0);
        }
     }

    /**
     * Stops the current cutting process for a specific worker and resets its state.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker to stop.
     */
     stopCutting(workerSprite) {
        if (!workerSprite) return;

        const treeToStopCutting = workerSprite.cuttingTarget;

        if (workerSprite.cuttingTimer) {
            workerSprite.cuttingTimer.remove(false);
            workerSprite.cuttingTimer = null;
        }

        // Stop chop sound only if no workers are cutting AFTER this one stops
        workerSprite.isCutting = false; // Temporarily set flag to check other worker
        let otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
        if (this.chopSound && this.chopSound.isPlaying) {
            if (!otherWorker || !otherWorker.isCutting) { // If other worker isn't cutting
                this.chopSound.stop();
            }
        }
        // Restore flag - will be set false again below
        // workerSprite.isCutting = true; // No, keep it false


        workerSprite.setTexture('worker_sheet');
        workerSprite.anims.stop();
        workerSprite.setFrame(0);
        workerSprite.setFlipX(false);

        workerSprite.isCutting = false; // Ensure flag is false
        workerSprite.cuttingTarget = null;

        // Destroy the health bar of the tree that WAS being cut by THIS worker
        // Check if the other worker is still cutting this same tree before destroying bar
        // Re-get otherWorker in case workerSprite was null initially
        otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
        if (!otherWorker || !otherWorker.isCutting || otherWorker.cuttingTarget !== treeToStopCutting) {
             this.destroyTreeHealthBar(treeToStopCutting);
        }
     }


    /**
     * Finalizes cutting the tree, adds wood for player, removes tree, checks win condition.
     * @param {Phaser.GameObjects.Sprite} tree - The tree sprite that was cut.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker who cut the tree.
     */
    cutTree(tree, workerSprite) {
      // stopCutting is called first, destroying the health bar (if applicable) and resetting worker animation
      this.stopCutting(workerSprite);

      if (!tree || !tree.active) {
        console.warn("Attempted to cut an invalid or inactive tree.");
        this.destroyTreeHealthBar(tree); // Ensure bar is gone
        return;
      }

      // Only player gets wood
      if (workerSprite === this.worker) {
          this.wood += 10;
          this.woodText.setText('Wood: ' + this.wood);
      }

      this.trees.remove(tree, true, true); // This destroys the tree sprite

      // Check win condition based on player wood
      const winAmount = 100;
      if (this.wood >= winAmount) {
        this.add.text(this.sys.game.config.width / 2, this.sys.game.config.height / 2,
                       `You win!\nCollected ${winAmount} wood!`,
                       { font: '32px Arial', fill: '#ffff00', align: 'center' })
                       .setOrigin(0.5)
                       .setDepth(2000);
        this.input.enabled = false;
        this.tweens.killAll();
        if (this.workerWalkSound && this.workerWalkSound.isPlaying) this.workerWalkSound.stop();
        if (this.chopSound && this.chopSound.isPlaying) this.chopSound.stop();
        this.sound.stopAll();

        if(this.worker && this.worker.cuttingTimer) this.worker.cuttingTimer.remove();
        if(this.aiWorker && this.aiWorker.cuttingTimer) this.aiWorker.cuttingTimer.remove();
        if(this.worker) this.worker.state = 'idle';
        if(this.aiWorker) this.aiWorker.state = 'idle';
        this.gameStarted = false;
      }
      // After cutting, the worker will automatically look for the next tree in the update loop if game not won
    }

    /**
     * Updates the position and fill of a unit's health bar.
     */
    updateHealthBar(unit) {
        if (!unit || !unit.active || !unit.healthBarBg || !unit.healthBarFill) {
            return;
        }

        const barWidth = unit.healthBarWidth;
        const yOffset = -unit.displayHeight - 5;
        const x = unit.x;
        const y = unit.y + yOffset;

        unit.healthBarBg.setPosition(x, y);
        unit.healthBarFill.setPosition(x - barWidth / 2, y);

        const fillWidth = Math.max(0, (unit.health / unit.maxHealth) * barWidth);
        unit.healthBarFill.width = fillWidth;

        unit.healthBarBg.setDepth(unit.depth + 1);
        unit.healthBarFill.setDepth(unit.depth + 2);
    }

    /**
     * Finds the closest active tree to the specified worker.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker to find the closest tree for.
     * @returns {Phaser.GameObjects.Sprite | null} The closest tree or null if none found.
     */
    findClosestTree(workerSprite) {
        if (!workerSprite || !this.trees) return null;

        const activeTrees = this.trees.getChildren().filter(tree => tree.active);
        if (activeTrees.length === 0) {
            return null;
        }

        let closestTree = null;
        let minDistance = Infinity;

        activeTrees.forEach(tree => {
            // Avoid targeting a tree that the *other* worker is already cutting
            let otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
            if (otherWorker && otherWorker.isCutting && otherWorker.cuttingTarget === tree) {
                return; // Skip this tree
            }

            const distance = Phaser.Math.Distance.Between(workerSprite.x, workerSprite.y, tree.x, tree.y);
            if (distance < minDistance) {
                minDistance = distance;
                closestTree = tree;
            }
        });
        return closestTree;
    }

    /**
     * Sends the specified worker to move towards and cut a specific tree.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker to send.
     * @param {Phaser.GameObjects.Sprite} tree - The target tree.
     */
    sendWorkerToTree(workerSprite, tree) {
        if (!tree || !tree.active || !workerSprite || workerSprite.moving || workerSprite.isCutting) {
            return;
        }

        workerSprite.target = tree;
        workerSprite.moving = true;

        const offset = 50;
        const targetY = tree.y;
        let targetX;
        let faceRightOnArrival;

        if (workerSprite.x <= tree.x) {
            targetX = tree.x - offset;
            faceRightOnArrival = true;
        } else {
            targetX = tree.x + offset;
            faceRightOnArrival = false;
        }

        if (workerSprite === this.worker) { // Only update debug for player
             this.debugText.setText(`Debug Output:\nWorker moving to tree at (${Math.round(tree.x)}, ${Math.round(tree.y)}).`);
        }


        const distance = Phaser.Math.Distance.Between(workerSprite.x, workerSprite.y, targetX, targetY);
        const speed = 100;
        const duration = (distance / speed) * 1000;

        workerSprite.anims.play('walk', true);

        // Play walk sound only if not already playing
        if (this.workerWalkSound && !this.workerWalkSound.isPlaying) {
            this.workerWalkSound.play({ loop: true });
        }


        if (targetX < workerSprite.x) {
             workerSprite.setFlipX(false);
        } else {
             workerSprite.setFlipX(true);
        }

        this.tweens.add({
          targets: workerSprite,
          x: targetX,
          y: targetY,
          duration: duration,
          ease: 'Linear',
          onComplete: () => { // Use arrow function for correct 'this' scope
            // Stop walk sound only if no workers will be moving after this one stops
            workerSprite.moving = false; // Set moving false *before* checking others
            if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                 let otherWorker = (workerSprite === this.worker) ? this.aiWorker : this.worker;
                 if (!otherWorker || !otherWorker.moving) { // Check if other worker exists and is moving
                     this.workerWalkSound.stop();
                 }
            }
            // workerSprite.moving = false; // Already set above

            const actualTree = workerSprite.target;
            if (actualTree && actualTree.active && actualTree === tree) {
                workerSprite.isCutting = true;
                workerSprite.cuttingTarget = actualTree;
                 if (workerSprite === this.worker) { // Only update debug for player
                    this.debugText.setText(`Debug Output:\nReached tree. Starting to cut (Health: ${actualTree.health}).`);
                 }


                this.createTreeHealthBar(actualTree);

                workerSprite.setFlipX(!faceRightOnArrival);
                workerSprite.setTexture('worker_chop_sheet');
                workerSprite.anims.play('chop', true);

                // Play chop sound (shared) only if not already playing
                if (this.chopSound && !this.chopSound.isPlaying) {
                    this.chopSound.play({ loop: true });
                }

                // Store timer on the worker
                workerSprite.cuttingTimer = this.time.addEvent({
                    delay: 1000,
                    // Use arrow function to pass worker context to damageTree
                    callback: () => this.damageTree(workerSprite),
                    callbackScope: this,
                    loop: true
                });
            } else {
                 if (workerSprite === this.worker) {
                     this.debugText.setText(`Debug Output:\nReached location, but target invalid.`);
                 }
                 workerSprite.target = null;
                 workerSprite.setTexture('worker_sheet');
                 workerSprite.anims.stop();
                 workerSprite.setFrame(0);
                 workerSprite.setFlipX(false);
            }
          }
        });
    }

    /**
     * Handles a worker's state machine logic.
     * @param {Phaser.GameObjects.Sprite} workerSprite - The worker whose state to handle.
     */
    handleWorkerState(workerSprite) {
        if (!this.gameStarted || !workerSprite || !workerSprite.active) return;

        if (workerSprite.state === 'chopping' && !workerSprite.moving && !workerSprite.isCutting) {
            const closestTree = this.findClosestTree(workerSprite);
            if (closestTree) {
                this.sendWorkerToTree(workerSprite, closestTree);
            } else {
                // No trees left for this worker
                workerSprite.state = 'idle';
                 if (workerSprite === this.worker) { // Only update debug for player
                    this.debugText.setText("Debug Output:\nNo trees left. Worker idle.");
                 }
                workerSprite.setTexture('worker_sheet');
                workerSprite.anims.stop();
                workerSprite.setFrame(0);
                workerSprite.setFlipX(false);
            }
        } else if (workerSprite.state === 'idle') {
            // Idle state
        }
    }


    /**
     * Game loop update function. Runs continuously.
     */
    update(time, delta) {
        if (!this.gameStarted) return;

        // --- Handle Worker States ---
        this.handleWorkerState(this.worker);
        this.handleWorkerState(this.aiWorker);

        // --- Depth Sorting ---
        const depthSortedSprites = [];
        if (this.worker && this.worker.active) depthSortedSprites.push(this.worker);
        if (this.aiWorker && this.aiWorker.active) depthSortedSprites.push(this.aiWorker); // Add AI worker
        if (this.house && this.house.active) depthSortedSprites.push(this.house);
        if (this.aiHouse && this.aiHouse.active) depthSortedSprites.push(this.aiHouse); // Add AI house

        if (this.trees) {
            this.trees.getChildren().forEach(tree => {
                if (tree.active) {
                    depthSortedSprites.push(tree);
                    if(tree.healthBarBg) { // Update active tree health bar pos/depth
                       this.updateTreeHealthBar(tree);
                    }
                }
            });
        }


        depthSortedSprites.sort((a, b) => {
            const yA = a.y;
            const yB = b.y;
            if (yA < yB) return -1;
            if (yA > yB) return 1;
            if (a.x < b.x) return -1;
            if (a.x > b.x) return 1;
            return 0;
        });

        depthSortedSprites.forEach((sprite, index) => {
            sprite.setDepth(index);
        });

        // --- Update Unit Health Bars ---
        this.updateHealthBar(this.worker);
        this.updateHealthBar(this.house);
        this.updateHealthBar(this.aiWorker); // Update AI worker bar
        this.updateHealthBar(this.aiHouse); // Update AI house bar


        // --- Target / Cutting Checks ---
        [this.worker, this.aiWorker].forEach( w => {
            if (!w) return; // Skip if worker doesn't exist

            if (w.moving && w.target && !w.target.active) {
                console.log("Target destroyed during movement, stopping worker:", w === this.aiWorker ? "AI" : "Player");
                this.tweens.killTweensOf(w);

                // Refined sound stop logic when target destroyed mid-move
                w.moving = false; // Set moving false *before* checking others
                if (this.workerWalkSound && this.workerWalkSound.isPlaying) {
                    let otherWorker = (w === this.worker) ? this.aiWorker : this.worker;
                    if (!otherWorker || !otherWorker.moving) { // Check if other worker exists and is moving
                        this.workerWalkSound.stop();
                    }
                }
                // w.moving = false; // Already set above

                w.setTexture('worker_sheet');
                w.anims.stop();
                w.setFrame(0);
                w.setFlipX(false);
                //w.moving = false; // Already set above
                w.target = null;
                 if (w === this.worker) {
                    this.debugText.setText(`Debug Output:\nTarget tree disappeared. Worker stopped.`);
                 }
            }

            if (w.isCutting && w.cuttingTarget && !w.cuttingTarget.active) {
                 console.log("Target destroyed during cutting, stopping worker:", w === this.aiWorker ? "AI" : "Player");
                 this.stopCutting(w); // Pass the specific worker
                 if (w === this.worker) {
                    this.debugText.setText(`Debug Output:\nCutting target disappeared. Worker stopped.`);
                 }
            }
        });
    }
  }

  /**
   * Phaser game configuration object.
   */
  const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    physics: {
        default: 'arcade',
        arcade: {
            debug: false
        }
    },
    scene: [DemoScene]
  };

  // Create a new Phaser game instance
  const game = new Phaser.Game(config);

</script>
</body>
</html>
