<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Simple RTS Demo with Worker Animation</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <style>
    /* Basic styling for the body and canvas */
    body { margin: 0; background-color: #333; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
    canvas { display: block; margin: 20px auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
  </style>
</head>
<body>
<script>
  /**
   * Represents the main scene for the RTS demo.
   * Handles game logic, asset loading, and rendering.
   */
  class DemoScene extends Phaser.Scene {
    constructor() {
      super({ key: 'DemoScene' });
      // Game state variables
      this.wood = 0; // Player's wood count
      this.worker = null; // The player-controlled worker sprite
      this.trees = null; // Group containing tree sprites
      this.house = null; // The house sprite (visual only for now)
      this.woodText = null; // Text object to display wood count
      this.debugText = null; // Text object for displaying debug messages
      this.workerWalkSound = null; // Sound effect for worker walking
      this.cuttingTimer = null; // Timer event for cutting
      this.chopSound = null; // Sound effect for chopping
    }

    /**
     * Preloads game assets (images, spritesheets, audio).
     * This function runs before the 'create' function.
     */
    preload() {
      // Load the worker spritesheet
      this.load.spritesheet('worker_sheet', 'https://grantchen08.github.io/nezha/worker_walk.png', {
          frameWidth: 32,
          frameHeight: 64
      });
      // Load the walking sound effect
      this.load.audio('worker_walk', 'https://grantchen08.github.io/nezha/worker_walk.mp3');
      // Load the tree spritesheet
      this.load.spritesheet('tree_sheet', 'https://grantchen08.github.io/nezha/tree.png', {
          frameWidth: 64,
          frameHeight: 64
      });
      // Load the house image
      this.load.image('house', 'https://grantchen08.github.io/nezha/house.png');
      // Load the chopping sound effect
      this.load.audio('chop_sound', 'https://grantchen08.github.io/nezha/chop_tree.mp3');

      // Basic error handling for asset loading
      this.load.on('loaderror', (file) => {
          console.error(`Error loading asset: ${file.key} from ${file.url}`);
          if (this.debugText) {
            this.debugText.setText(`Debug Output:\nError loading ${file.key}`);
          } else {
            alert(`Error loading asset: ${file.key}. Check console.`);
          }
      });
    }

    /**
     * Creates game objects and initializes the scene.
     * This function runs once after 'preload' is complete.
     */
    create() {
      // Set background color
      this.cameras.main.setBackgroundColor('#228B22'); // Forest green

      // Initialize wood count and display text
      this.wood = 0;
      this.woodText = this.add.text(10, 10, 'Wood: 0', { font: '16px Arial', fill: '#ffffff' });
      this.woodText.setDepth(1000);

      // Initialize debug text display area
      this.debugText = this.add.text(10, 40, 'Debug Output:', {
        font: '14px Arial',
        fill: '#ffffff',
        wordWrap: { width: 200 }
      });
      this.debugText.setDepth(1000);
      this.debugText.setText("Debug Output:\nGame started. Click worker to select.");

      // Create and place the house sprite
      this.house = this.add.image(100, 500, 'house');

      // Create the worker sprite
      this.worker = this.add.sprite(this.sys.game.config.width / 2, this.sys.game.config.height / 2, 'worker_sheet').setOrigin(0.5, 1);
      this.worker.setFrame(0);
      this.worker.setInteractive();
      this.worker.selected = false;
      this.worker.moving = false;
      this.worker.target = null;
      this.worker.isCutting = false; // Custom property: track if cutting
      this.worker.cuttingTarget = null; // Custom property: store the cutting target

      // Load the walking sound
      this.workerWalkSound = this.sound.add('worker_walk');
      // Load the chopping sound
      this.chopSound = this.sound.add('chop_sound');

      // Create the walking animation
      this.anims.create({
          key: 'walk',
          frames: this.anims.generateFrameNumbers('worker_sheet', { start: 0, end: 3 }),
          frameRate: 8,
          repeat: -1
      });

      // --- Event Handlers ---

      // Handle clicking ON the worker
      this.worker.on('pointerdown', (pointer) => {
        if (!this.worker.moving && !this.worker.isCutting) { // Can only select if idle
          this.worker.selected = true;
          this.worker.setTint(0xffff00);
          this.debugText.setText("Debug Output:\nWorker clicked and selected.\nClick a tree to send worker.");
        }
      });

      // Handle clicking OFF the worker (on the background)
      this.input.on('pointerdown', (pointer, gameObjects) => {
        if (gameObjects.length === 0 && this.worker.selected && !this.worker.moving && !this.worker.isCutting) {
          this.worker.selected = false;
          this.worker.clearTint();
          this.debugText.setText("Debug Output:\nBackground clicked. Worker deselected.");
        }
      });

      // --- Tree Setup ---

      // Create a group to hold the tree sprites
      this.trees = this.add.group();
      const treeCount = 20;

      // Generate trees randomly, avoiding the house area
      for (let i = 0; i < treeCount; i++) {
        let x = Phaser.Math.Between(50, this.sys.game.config.width - 50);
        let y = Phaser.Math.Between(50, this.sys.game.config.height - 100);

        const houseWidth = this.house.displayWidth;
        const houseHeight = this.house.displayHeight;
        const houseCheckX = this.house.x;
        const houseCheckY = this.house.y - houseHeight / 2;
        const houseRadius = Math.max(houseWidth, houseHeight) / 2 + 36;

        if (Phaser.Math.Distance.Between(x, y, houseCheckX, houseCheckY) < houseRadius) {
             i--;
             continue;
        }

        // Create the tree sprite using the spritesheet
        let tree = this.add.sprite(x, y, 'tree_sheet').setOrigin(0.5, 1);
        tree.setFrame(0); // Start with full health frame
        tree.setInteractive();
        tree.health = 10; // Custom property: tree health
        this.trees.add(tree);

        // Handle clicking ON a tree
        tree.on('pointerdown', () => {
          if (this.worker.selected && !this.worker.moving) {
            // If currently cutting, stop the old process first
            if (this.worker.isCutting) {
                this.stopCutting();
            }

            this.worker.target = tree; // Still track the actual tree object
            this.worker.moving = true;
            this.worker.selected = false;
            this.worker.clearTint();


            // Calculate target position NEXT TO the tree on the closest side
            const offset = 40; // Distance offset from tree center
            const targetY = tree.y; // Keep same Y level
            let targetX;
            let faceRightOnArrival; // Flag to determine final facing direction

            if (this.worker.x <= tree.x) {
                // Worker is left or center, move to left side of tree
                targetX = tree.x - offset;
                faceRightOnArrival = true; // Face right towards tree
            } else {
                // Worker is right, move to right side of tree
                targetX = tree.x + offset;
                faceRightOnArrival = false; // Face left towards tree
            }


            this.debugText.setText(`Debug Output:\nTree clicked. Moving worker to (${Math.round(targetX)}, ${Math.round(targetY)}).`);

            const distance = Phaser.Math.Distance.Between(this.worker.x, this.worker.y, targetX, targetY); // Use target position
            const speed = 100;
            const duration = (distance / speed) * 1000;

            this.worker.anims.play('walk', true);
            if (!this.workerWalkSound.isPlaying) {
                 this.workerWalkSound.play({ loop: true });
            }

            // Flip worker based on target X relative to current X
            if (targetX < this.worker.x) {
                 this.worker.setFlipX(false); // Moving left
            } else {
                 this.worker.setFlipX(true); // Moving right
            }

            // Move worker to the calculated position next to the tree
            this.tweens.add({
              targets: this.worker,
              x: targetX, // <-- Use calculated target X
              y: targetY, // <-- Use calculated target Y
              duration: duration,
              ease: 'Linear',
              onComplete: () => {
                // Reached destination, stop moving animation/sound
                this.workerWalkSound.stop();
                this.worker.anims.stop();
                this.worker.setFrame(0);
                // Make worker face the tree based on arrival side
                this.worker.setFlipX(faceRightOnArrival); // <-- Use flag to set facing direction
                this.worker.moving = false;

                // Start cutting the target tree (use the stored tree object)
                const actualTree = this.worker.target; // Get the actual tree object
                if (actualTree && actualTree.active) { // Check if tree still exists
                    this.worker.isCutting = true;
                    this.worker.cuttingTarget = actualTree; // Store the actual tree being cut
                    this.debugText.setText(`Debug Output:\nReached tree. Starting to cut (Health: ${actualTree.health}).`);
                    // Play chopping sound
                    if (this.chopSound && !this.chopSound.isPlaying) {
                        this.chopSound.play({ loop: true });
                    }
                    // Start the damage timer
                    this.cuttingTimer = this.time.addEvent({
                        delay: 1000,
                        callback: this.damageTree,
                        callbackScope: this,
                        loop: true
                    });
                } else {
                     this.debugText.setText(`Debug Output:\nReached tree location, but tree is gone.`);
                     this.worker.target = null; // Clear target if it disappeared
                }
              }
            });
          }
        });
      }
       // Set house origin for depth sorting
       this.house.setOrigin(0.5, 1);
    }


    /**
     * Damages the tree currently being cut by the worker. Called by timer.
     */
     damageTree() {
        // Check if still cutting and target is valid
        if (!this.worker.isCutting || !this.worker.cuttingTarget || !this.worker.cuttingTarget.active) {
            this.stopCutting(); // Stop if target gone or worker interrupted
            return;
        }

        const tree = this.worker.cuttingTarget;
        tree.health -= 1; // Worker DPS is 1

        this.debugText.setText(`Debug Output:\nCutting tree (Health: ${tree.health})`);

        // Update tree frame based on health percentage (10 max health)
        if (tree.health <= 0) {
            this.debugText.setText(`Debug Output:\nTree cut down!`);
            this.cutTree(tree); // Finalize cutting
            // stopCutting() is called within cutTree now
        } else if (tree.health <= 3.3) { // ~33%
            tree.setFrame(2);
        } else if (tree.health <= 6.6) { // ~66%
            tree.setFrame(1);
        } else {
            tree.setFrame(0); // Should already be 0, but safe
        }
     }

    /**
     * Stops the current cutting process and resets worker state.
     */
     stopCutting() {
        if (this.cuttingTimer) {
            this.cuttingTimer.remove(false); // Remove timer
            this.cuttingTimer = null;
        }
        if (this.chopSound && this.chopSound.isPlaying) {
            this.chopSound.stop();
        }
        if (this.worker) { // Check if worker exists
            this.worker.isCutting = false;
            this.worker.cuttingTarget = null;
            // Reset animation if worker exists and isn't moving
            if (!this.worker.moving) {
                 this.worker.anims.stop();
                 this.worker.setFrame(0);
                 this.worker.setFlipX(false); // Reset flip to default
            }
        }
        // Do not update debug text here, context-specific messages are better
     }


    /**
     * Finalizes cutting the tree, adds wood, removes the tree, and checks for win condition.
     * @param {Phaser.GameObjects.Sprite} tree - The tree sprite that was cut.
     */
    cutTree(tree) {
      this.stopCutting(); // Stop the timer and sound, reset cutting state first

      // Safety check: ensure tree is valid before proceeding
      if (!tree || !tree.active) {
        console.warn("Attempted to cut an invalid or inactive tree.");
        return;
      }

      // Increase wood count and update display
      this.wood += 10; // Award fixed amount of wood
      this.woodText.setText('Wood: ' + this.wood);

      // Remove the tree from the group and destroy it
      this.trees.remove(tree, true, true);

      // --- Win Condition Check ---
      const winAmount = 100;
      if (this.wood >= winAmount) {
        this.add.text(this.sys.game.config.width / 2, this.sys.game.config.height / 2,
                       `You win!\nCollected ${winAmount} wood!`,
                       { font: '32px Arial', fill: '#ffff00', align: 'center' })
                       .setOrigin(0.5)
                       .setDepth(2000);
        this.input.enabled = false;
        this.tweens.killAll();
        this.sound.stopAll(); // This will stop the chop sound too
        if(this.cuttingTimer) this.cuttingTimer.remove(); // Ensure timer is gone
      }
    }

    /**
     * Game loop update function. Runs continuously.
     * @param {number} time - The current game time.
     * @param {number} delta - The time elapsed since the last frame (in ms).
     */
    update(time, delta) {
        // --- Depth Sorting ---
        const depthSortedSprites = [];
        if (this.worker && this.worker.active) {
            depthSortedSprites.push(this.worker);
        }
        if (this.trees) {
            this.trees.getChildren().forEach(tree => {
                if (tree.active) {
                    depthSortedSprites.push(tree);
                }
            });
        }
         if (this.house && this.house.active) {
            depthSortedSprites.push(this.house);
        }

        depthSortedSprites.sort((a, b) => {
            const yA = a.y;
            const yB = b.y;
            if (yA < yB) return -1;
            if (yA > yB) return 1;
            if (a.x < b.x) return -1;
            if (a.x > b.x) return 1;
            return 0;
        });

        depthSortedSprites.forEach((sprite, index) => {
            sprite.setDepth(index);
        });

        // --- Target / Cutting Checks ---
        // Check if the worker is moving towards a target that no longer exists
        if (this.worker.moving && this.worker.target && !this.worker.target.active) {
            console.log("Target destroyed during movement, stopping worker.");
            this.tweens.killTweensOf(this.worker); // Stop movement tween
            this.workerWalkSound.stop();
            this.worker.anims.stop();
            this.worker.setFrame(0);
            this.worker.setFlipX(false);
            this.worker.moving = false;
            this.worker.target = null;
            this.debugText.setText(`Debug Output:\nTarget tree disappeared. Worker stopped.`);
        }

        // Check if the worker is cutting a target that no longer exists
        if (this.worker.isCutting && this.worker.cuttingTarget && !this.worker.cuttingTarget.active) {
             console.log("Target destroyed during cutting, stopping worker.");
             this.stopCutting(); // Stop the cutting process (also stops sound)
             this.debugText.setText(`Debug Output:\nCutting target disappeared. Worker stopped.`);
        }

        // --- Remove progress bar update logic ---
    }
  }

  /**
   * Phaser game configuration object.
   */
  const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    physics: {
        default: 'arcade',
        arcade: {
            debug: false
        }
    },
    scene: [DemoScene]
  };

  // Create a new Phaser game instance
  const game = new Phaser.Game(config);

</script>
</body>
</html>
